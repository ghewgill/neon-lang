import re

def literal(s):
    if "\n" in s or '"' in s:
        return "@@\"{}\"@@".format(s)
    elif "\\" in s:
        return "@\"{}\"".format(s)
    elif "\t" in s:
        return "\"{}\"".format(s.replace("\t", "\\t"))
    else:
        return "\"{}\"".format(s)

def unescapex(s):
    s = s.replace("\\x09", "\x09")
    s = s.replace("\\x0a", "\x0a")
    s = s.replace("\\x0c", "\x0c")
    s = s.replace("\\x0d", "\x0d")
    s = s.replace("\\x20", " ")
    s = s.replace("\\x93", "S")
    s = s.replace("\\x81", "\x81")
    s = s.replace("\\xff", "\xff")
    return s

def unescape(s):
    s = s.replace("\\a", "\a")
    s = s.replace("\\e", "\x1b")
    s = s.replace("\\f", "\f")
    s = s.replace("\\n", "\n")
    s = s.replace("\\r", "\r")
    s = s.replace("\\t", "\t")
    s = s.replace("\\x09", "\x09")
    s = s.replace("\\x0a", "\x0a")
    s = s.replace("\\x0c", "\x0c")
    s = s.replace("\\x0d", "\x0d")
    s = s.replace("\\x20", " ")
    s = s.replace("\\x93", "S")
    s = s.replace("\\x81", "\x81")
    s = s.replace("\\xff", "\xff")
    s = s.replace("\\040", " ")
    s = s.replace("\\223", "S")
    s = s.replace("\\$", "$")
    s = s.replace("\\?", "?")
    s = s.replace("\\\"", "\"")
    s = s.replace("\\\\", "\\")
    return s

class Test:
    def __init__(self, pattern, modifiers):
        self.pattern = pattern
        self.modifiers = modifiers
        self.matches = []
        self.nomatches = []

tests = []
with open("data/regex-testoutput1", encoding="latin1") as inf:
    while True:
        for s in inf:
            if s.startswith("/"):
                break
        if not s:
            break
        pattern = s.strip()
        if pattern.endswith("aftertext"):
            break
        #print("pattern", pattern)
        while not re.search("/[a-z]*$", pattern.strip()):
            pattern += inf.readline()
        pattern = pattern[1:]
        m = re.search("/([a-z]*)$", pattern)
        assert m is not None, pattern
        modifiers = m.group(1)
        pattern = pattern[:-1-len(m.group(1))]
        test = Test(pattern, modifiers)
        s = inf.readline()
        while True:
            if s.startswith("\\= Expect no match"):
                s = inf.readline()
                break
            if not s.strip():
                break
            assert s.startswith(" "), s
            target = s.strip()
            if target == "\\":
                target = ""
            #print("  target", target)
            target = unescape(target)
            match = []
            for s in inf:
                if not s.strip() or s[2] != ":":
                    break
                assert int(s[:2]) == len(match)
                match.append(unescapex(s[4:].rstrip("\n")))
            #print("  match", match)
            test.matches.append((target, match))
        while True:
            if not s.strip():
                break
            assert s.startswith(" "), s
            target = s.strip()
            #print("  nomatch", target)
            target = unescape(target)
            assert inf.readline().strip() == "No match"
            test.nomatches.append(target)
            s = inf.readline()
        if (#"\\" not in test.pattern and
            "\\A" not in test.pattern and
            "\\Z" not in test.pattern and
            "\\c" not in test.pattern and
            "\\1" not in test.pattern and
            "\\8" not in test.pattern and
            "\\0" not in test.pattern and
            "\\x0" not in test.pattern and
            "\\223" not in test.pattern and
            "\\323" not in test.pattern and
            "?=" not in test.pattern and
            "?!" not in test.pattern and
            "?#" not in test.pattern and
            "?s" not in test.pattern and
            "?m" not in test.pattern and
            "(?)" not in test.pattern and
            "otherword" not in test.pattern and
            "x" not in modifiers and
            "m" not in modifiers and
            len(tests) not in [104, 167, 168, 172, 176, 180, 186]):
            tests.append(test)
        else:
            tests.append(None)

with open("t/regex-test.neon", "w") as outf:
    print("-- Automatically generated by make_regex_test.py", file=outf)
    print("IMPORT regex", file=outf)
    print(file=outf)
    for i, t in enumerate(tests):
        if t is None:
            continue
        print("FUNCTION test{}()".format(i), file=outf)
        print("    print(\"test{} \" & {})".format(i, literal(t.pattern)), file=outf)
        print("    LET re := regex.prepare({}{})".format(literal(t.pattern), ", ignoreCase WITH TRUE" if "i" in t.modifiers else ""), file=outf)
        print("    VAR r: regex.Result", file=outf)
        for m in t.matches:
            print("    r := regex.searchRegex(re, {})".format(literal(m[0])), file=outf)
            print("    IF r ISA regex.Result.match THEN", file=outf)
            print("        VAR m: regex.Match", file=outf)
            for j, s in enumerate(m[1]):
                print("        m := r.match[{}]".format(j), file=outf)
                print("        IF m ISA regex.Match.found THEN", file=outf)
                print("            TESTCASE m.found.string = {}".format(literal(s)), file=outf)
                print("        ELSE", file=outf)
                print("            TESTCASE m ISA regex.Match.found", file=outf)
                print("        END IF", file=outf)
            print("        TESTCASE r ISA regex.Result.match", file=outf)
            print("    END IF", file=outf)
        for m in t.nomatches:
            print("    r := regex.searchRegex(re, {})".format(literal(m)), file=outf)
            print("    TESTCASE r ISA regex.Result.noMatch", file=outf)
        print("END FUNCTION", file=outf)
    for i, t in enumerate(tests):
        if t is None:
            continue
        print("test{}()".format(i), file=outf)
