import re

def literal(s):
    if "\n" in s or '"' in s:
        return "@@\"{}\"@@".format(s)
    elif "\\" in s:
        return "@\"{}\"".format(s)
    else:
        return "\"{}\"".format(s)

def unescape(s):
    s = s.replace("\\a", "\a")
    s = s.replace("\\e", "\x1b")
    s = s.replace("\\f", "\f")
    s = s.replace("\\n", "\n")
    s = s.replace("\\r", "\r")
    s = s.replace("\\t", "\t")
    s = s.replace("\\x20", " ")
    s = s.replace("\\x0c", "")
    s = s.replace("\\040", " ")
    s = s.replace("\\$", "$")
    s = s.replace("\\?", "?")
    s = s.replace("\\\"", "\"")
    s = s.replace("\\\\", "\\")
    return s

class Test:
    def __init__(self, pattern, modifiers):
        self.pattern = pattern
        self.modifiers = modifiers
        self.matches = []
        self.nomatches = []

tests = []
with open("data/regex-testoutput1", encoding="latin1") as inf:
    while True:
        for s in inf:
            if s.startswith("/"):
                break
        if not s:
            break
        pattern = s.strip()
        if pattern.endswith("aftertext"):
            break
        #print("pattern", pattern)
        while not re.search("/[a-z]*$", pattern.strip()):
            pattern += inf.readline()
        pattern = pattern[1:]
        m = re.search("/([a-z]*)$", pattern)
        assert m is not None, pattern
        modifiers = m.group(1)
        pattern = pattern[:-1-len(m.group(1))]
        test = Test(pattern, modifiers)
        s = inf.readline()
        while True:
            if s.startswith("\\= Expect no match"):
                s = inf.readline()
                break
            if not s.strip():
                break
            assert s.startswith(" "), s
            target = s.strip()
            if target == "\\":
                target = ""
            #print("  target", target)
            target = unescape(target)
            match = []
            for s in inf:
                if not s.strip() or s[2] != ":":
                    break
                assert int(s[:2]) == len(match)
                match.append(s[4:].strip())
            #print("  match", match)
            test.matches.append((target, match))
        while True:
            if not s.strip():
                break
            assert s.startswith(" "), s
            target = s.strip()
            #print("  nomatch", target)
            target = unescape(target)
            assert inf.readline().strip() == "No match"
            test.nomatches.append(target)
            s = inf.readline()
        if (#"\\" not in test.pattern and
            "\\c" not in test.pattern and
            "\\1" not in test.pattern and
            "\\0" not in test.pattern and
            "\\x0" not in test.pattern and
            "?=" not in test.pattern and
            "?!" not in test.pattern and
            "?#" not in test.pattern and
            "x" not in modifiers):
            tests.append(test)
        else:
            tests.append(None)

with open("t/regex-test.neon", "w") as outf:
    print("-- Automatically generated by make_regex_test.py", file=outf)
    print("IMPORT regex", file=outf)
    print(file=outf)
    for i, t in enumerate(tests):
        if t is None:
            continue
        print("FUNCTION test{}()".format(i), file=outf)
        print("    print(\"test{} \" & {})".format(i, literal(t.pattern)), file=outf)
        print("    LET r := regex.prepare({}{})".format(literal(t.pattern), ", ignoreCase WITH TRUE" if "i" in t.modifiers else ""), file=outf)
        for m in t.matches:
            print("    TESTCASE regex.searchRegex(r, {})".format(literal(m[0])), file=outf)
        for m in t.nomatches:
            print("    TESTCASE NOT regex.searchRegex(r, {})".format(literal(m)), file=outf)
        print("END FUNCTION", file=outf)
    for i, t in enumerate(tests):
        if t is None:
            continue
        print("test{}()".format(i), file=outf)
