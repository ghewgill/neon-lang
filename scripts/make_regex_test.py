import re

def literal(s):
    if "\n" in s or '"' in s:
        return "@@\"{}\"@@".format(s)
    elif "\\" in s:
        return "@\"{}\"".format(s)
    else:
        return "\"{}\"".format(s)

class Test:
    def __init__(self, pattern):
        self.pattern = pattern
        self.matches = []
        self.nomatches = []

tests = []
with open("data/regex-testoutput1", encoding="latin1") as inf:
    while True:
        for s in inf:
            if s.startswith("/"):
                break
        if not s:
            break
        pattern = s.strip()
        if pattern.endswith("aftertext"):
            break
        #print("pattern", pattern)
        while not re.search("/[a-z]*$", pattern.strip()):
            pattern += inf.readline()
        pattern = pattern[1:]
        pattern = re.sub("/[a-z]*$", "", pattern)
        test = Test(pattern)
        s = inf.readline()
        while True:
            if s.startswith("\\= Expect no match"):
                s = inf.readline()
                break
            if not s.strip():
                break
            assert s.startswith(" "), s
            target = s.strip()
            #print("  target", target)
            match = []
            for s in inf:
                if not s.strip() or s[2] != ":":
                    break
                assert int(s[:2]) == len(match)
                match.append(s[4:].strip())
            #print("  match", match)
            test.matches.append((target, match))
        while True:
            if not s.strip():
                break
            assert s.startswith(" "), s
            target = s.strip()
            #print("  nomatch", target)
            assert inf.readline().strip() == "No match"
            test.nomatches.append(target)
            s = inf.readline()
        tests.append(test)

with open("t/regex-test.neon", "w") as outf:
    print("-- Automatically generated by make_regex_test.py", file=outf)
    print("IMPORT regex", file=outf)
    print(file=outf)
    for i, t in enumerate(tests):
        print("FUNCTION test{}()".format(i), file=outf)
        print("    LET r := regex.parse({})".format(literal(t.pattern)), file=outf)
        for m in t.matches:
            print("    TESTCASE regex.searchRegex(r, {})".format(literal(m[0])), file=outf)
        for m in t.nomatches:
            print("    TESTCASE NOT regex.searchRegex(r, {})".format(literal(m)), file=outf)
        print("END FUNCTION", file=outf)
    for i in range(len(tests)):
        print("test{}()".format(i), file=outf)
