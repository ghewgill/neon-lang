<!DOCTYPE html>
<html>
  <head>
    <title>Neon Overview</title>
    <meta charset="utf-8"> 
    <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
  </head>
  <body>
    <div id="page">
      <div class="title">
        <a href="/">
          Neon
        </a>
      </div>
      <div class="links">
        <p>
          <a href="/">home</a> |
          <a href="/docs.html">documentation</a> |
          <a href="/download.html">download</a> |
          <a href="https://github.com/ghewgill/neon-lang">source</a>
        </p>
      </div>
      <h1 id="neon-overview">Neon Overview</h1>

<p>The following is a brief description of Neon for experienced programmers.
There are plenty of examples, because experienced programmers know how to read code, and can pick up concepts more quickly by reading code than by reading a description of code.</p>

<p>Neon is a statically typed imperative language, with roots in Pascal, Modula-2, Ada, and <a href="motivation.html">others</a>.
Program structure and modules are influenced by Python.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>% This sample program greets the user
% until an empty line is entered.

LOOP
    LET name: String := input("What is your name? ")
    IF name = "" THEN
        EXIT LOOP
    END IF
    print("Hello, \(name).")
END LOOP
</code></pre>
</div>

<h2 id="general">General</h2>

<p>All identifiers are case sensitive.
Language defined keywords are all upper case.
Semicolons are not used.
Identifier scope is defined by program block structure.
Assignments have value semantics (deep copy).
Forward declarations are not required.
All variables must be explicitly initialised before use.</p>

<h2 id="types">Types</h2>

<p>The scalar types are <code class="highlighter-rouge">Boolean</code> (<code class="highlighter-rouge">TRUE</code> or <code class="highlighter-rouge">FALSE</code>), <code class="highlighter-rouge">Number</code> (decimal floating point), <code class="highlighter-rouge">String</code> (Unicode text), <code class="highlighter-rouge">Bytes</code> (arbitrary blocks of bytes), and enumerations.
Aggregate types are <code class="highlighter-rouge">RECORD</code> (named fields), <code class="highlighter-rouge">Array</code> (arbitrary size vector), and <code class="highlighter-rouge">Dictionary</code> (map indexed by a <code class="highlighter-rouge">String</code> key).
Dynamic heap allocation is supported by a <code class="highlighter-rouge">POINTER</code> type.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>TYPE Colour IS ENUM
    red
    green
    blue
END ENUM

TYPE Person IS RECORD
    name: String
    eyes: Colour
END RECORD

TYPE Node IS CLASS
    value: String
    next: POINTER TO Node
END CLASS

LET b: Boolean := TRUE
LET n: Number := 123.456
LET s: String := "Hello world"
LET y: Bytes := HEXBYTES "00 01 02 03"
LET e: Colour := Colour.green
LET r: Person := Person(name WITH "Alice", eyes WITH Colour.green)
LET a: Array&lt;String&gt; := ["fork", "knife", "spoon"]
LET d: Dictionary&lt;Number&gt; := {"fork": 5, "knife": 6, "spoon": 1}
LET p: POINTER TO Node := NEW Node(value WITH "green")
</code></pre>
</div>

<h2 id="expressions">Expressions</h2>

<p>There is a rich expression syntax including arithmetic, array slicing, conditionals, and string interpolation.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>LET x: Number := 5
LET y: Number := (6 + x) / 2
ASSERT y = 5.5

LET a: Array&lt;String&gt; := ["fork", "knife", "spoon"]
ASSERT a[1 TO LAST] = ["knife", "spoon"]

LET r: String := (IF y &lt; 5 THEN "small" ELSE "big")
ASSERT r = "big"

LET t: String := "y is a \(r) value"
ASSERT t = "y is a big value"
</code></pre>
</div>

<h2 id="statements">Statements</h2>

<p>There are two variable declarations: <code class="highlighter-rouge">LET</code> (read-only value), and <code class="highlighter-rouge">VAR</code> (modifiable value).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>LET a: Number := 5

VAR b: Number
b := a
b := 6

print("\(a), \(b)")
</code></pre>
</div>

<p>There are two conditional blocks: <code class="highlighter-rouge">CASE</code> (multiple branches), and <code class="highlighter-rouge">IF</code> (single test).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>FOR a := 0 TO 9 DO
    VAR s: String
    CASE a
        WHEN &lt; 2 DO
            s := "less than two"
        WHEN 2 DO
            s := "two"
        WHEN 3 TO 5 DO
            s := "three to five"
        WHEN 7, 9 DO
            s := "seven or nine"
        WHEN OTHERS DO
            s := "something else"
    END CASE
    print("\(a) is \(s)")
END FOR

IMPORT random
IF random.uint32() &lt; 10 THEN
    print("small")
END IF
</code></pre>
</div>

<p>There are four kinds of loops: <code class="highlighter-rouge">FOR</code> (bounded iteration), <code class="highlighter-rouge">LOOP</code> (infinite loop), <code class="highlighter-rouge">REPEAT</code> (bottom-tested condition), and <code class="highlighter-rouge">WHILE</code> (top-tested condition).
The <code class="highlighter-rouge">EXIT</code> and <code class="highlighter-rouge">NEXT</code> statements branch out of the loop or to the next iteration, respectively.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>FOR i := 1 TO 10 DO
    print("\(i)")
END FOR

VAR a: Number := 1
LOOP
    print("\(a)")
    IF a = 10 THEN
        EXIT LOOP
    END IF
    INC a
END LOOP

a := 1
REPEAT
    print("\(a)")
    INC a
UNTIL a = 10

a := 1
WHILE a &lt;= 10 DO
    print("\(a)")
    INC a
END WHILE
</code></pre>
</div>

<p>The exception handling statements are <code class="highlighter-rouge">TRY</code> (introduces a new handling scope), and <code class="highlighter-rouge">RAISE</code> to raise an exception.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>EXCEPTION PrinterOutOfPaperException

FUNCTION printFile(name: String)
    % Save the trees, don't print anything.
    RAISE PrinterOutOfPaperException
END FUNCTION

TRY
    printFile("hello.txt")
TRAP PrinterOutOfPaperException DO
    print("Sorry, out of paper.")
END TRY
</code></pre>
</div>

<p>The <code class="highlighter-rouge">ASSERT</code> statement is used to check program invariants.
Execution stops with a diagnostic dump if the condition is not satisfied.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>FUNCTION setRatio(percent: Number)
    ASSERT 0 &lt;= percent &lt;= 100
    % ... use percent value
END FUNCTION
</code></pre>
</div>

<h2 id="functions">Functions</h2>

<p>Functions may or may not return a value.
If a function returns a value, then the return value cannot be silently ignored by the caller.
Function parameters can be <code class="highlighter-rouge">IN</code> (default), <code class="highlighter-rouge">OUT</code> (passed back to caller), or <code class="highlighter-rouge">INOUT</code> (references caller value).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>IMPORT string

FUNCTION func(name: String, OUT result: String, INOUT count: Number)
    result := string.upper(name)
    INC count
END FUNCTION

VAR uname: String
VAR n: Number := 0

% The parameter mode (if not IN) must be explicitly indicated
% on the function call.
func("charlie", OUT uname, INOUT n)

% The caller may choose to pass parameters in a different
% order using the WITH keyword.
func("charlie", INOUT count WITH n, OUT result WITH uname)

ASSERT uname = "CHARLIE"
ASSERT n = 2
</code></pre>
</div>

<h2 id="methods">Methods</h2>

<p>Records may have methods attached to them, to be called with the usual method syntax.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>TYPE Rectangle IS RECORD
    width: Number
    height: Number
END RECORD

FUNCTION Rectangle.area(self: Rectangle): Number
    RETURN self.width * self.height
END FUNCTION

FUNCTION Rectangle.expand(INOUT self: Rectangle, edge: Number)
    self.width := self.width + 2 * edge
    self.height := self.height + 2 * edge
END FUNCTION

LET r: Rectangle := Rectangle(width WITH 4, height WITH 5)
ASSERT r.area() = 20
r.expand(1)
ASSERT r.area() = 42
</code></pre>
</div>

<h2 id="pointers">Pointers</h2>

<p>Pointers can only point to classes.
Pointers are declared with <code class="highlighter-rouge">POINTER TO</code> and allocated with <code class="highlighter-rouge">NEW</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>TYPE Person IS CLASS
    name: String
    age: Number
END CLASS

LET p: POINTER TO Person := NEW Person
p-&gt;name := "Alice"
p-&gt;age := 23
</code></pre>
</div>

<p>Pointers must be checked for validity (non-NIL) before they can be used using the <code class="highlighter-rouge">IF VALID</code> block.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>TYPE Person IS CLASS
    name: String
    age: Number
END CLASS

FUNCTION incrementAge(p: POINTER TO Person)
    IF VALID p THEN
        INC p-&gt;age
    END IF
END FUNCTION
</code></pre>
</div>

    </div>
  </body>
</html>
