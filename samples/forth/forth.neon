%|
 |  File: forth
 |
 |  Implementation of the Forth programming language.
 |%

IMPORT bitwise
IMPORT io
IMPORT math
IMPORT regex
IMPORT string
IMPORT sys

CONSTANT NUMBER_BUFFER_MAX: Number := 80
CONSTANT Digits: String := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

TYPE Stack IS RECORD
    stack: Array<Number>
END RECORD

FUNCTION Stack.drop(INOUT self: Stack, n: Number DEFAULT 1)
    self.stack.resize(self.stack.size() - n)
END FUNCTION

FUNCTION Stack.peek(self: Stack, n: Number DEFAULT 0): Number
    RETURN self.stack[LAST-n]
END FUNCTION

FUNCTION Stack.pop(INOUT self: Stack): Number
    LET x: Number := self.stack[LAST]
    self.stack.resize(self.stack.size()-1)
    RETURN x
END FUNCTION

FUNCTION Stack.push(INOUT self: Stack, x: Number)
    self.stack.append(x MOD 0x100000000)
END FUNCTION

FUNCTION Stack.size(self: Stack): Number
    RETURN self.stack.size()
END FUNCTION

FUNCTION signed32(n: Number): Number
    RETURN IF n >= 0x80000000 THEN n - 0x100000000 ELSE n
END FUNCTION

TYPE ReturnEntry IS RECORD
    ip: Number
    limit: Number
    index: Number
    leave: Number
END RECORD

CONSTANT CORE_STORE        : Number := -1
CONSTANT CORE_NUMBER       : Number := -2
CONSTANT CORE_NUMBER_GT    : Number := -3
CONSTANT CORE_NUMBER_S     : Number := -4
CONSTANT CORE_TICK         : Number := -5
CONSTANT CORE_COMMENT      : Number := -6
CONSTANT CORE_MUL          : Number := -7
CONSTANT CORE_MUL_DIV      : Number := -8
CONSTANT CORE_MUL_DIV_MOD  : Number := -9
CONSTANT CORE_ADD          : Number := -10
CONSTANT CORE_ADD_STORE    : Number := -11
CONSTANT CORE_PLUS_LOOP    : Number := -12
CONSTANT CORE_COMMA        : Number := -13
CONSTANT CORE_SUB          : Number := -14
CONSTANT CORE_PRINT        : Number := -15
CONSTANT CORE_PRINT_QUOTE  : Number := -16
CONSTANT CORE_DIV          : Number := -17
CONSTANT CORE_DIV_MOD      : Number := -18
CONSTANT CORE_0_LESS       : Number := -19
CONSTANT CORE_0_EQUAL      : Number := -20
CONSTANT CORE_1_PLUS       : Number := -21
CONSTANT CORE_1_MINUS      : Number := -22
CONSTANT CORE_2_STORE      : Number := -23
CONSTANT CORE_2_TIMES      : Number := -24
CONSTANT CORE_2_DIVIDE     : Number := -25
CONSTANT CORE_2_FETCH      : Number := -26
CONSTANT CORE_2DROP        : Number := -27
CONSTANT CORE_2DUP         : Number := -28
CONSTANT CORE_2OVER        : Number := -29
CONSTANT CORE_2SWAP        : Number := -30
CONSTANT CORE_DEFINE       : Number := -31
CONSTANT CORE_SEMICOLON    : Number := -32
CONSTANT CORE_LESS         : Number := -33
CONSTANT CORE_LESS_NUMBER  : Number := -34
CONSTANT CORE_NOT_EQUAL    : Number := -35
CONSTANT CORE_EQUAL        : Number := -36
CONSTANT CORE_GREATER      : Number := -37
CONSTANT CORE_TO_BODY      : Number := -38
CONSTANT CORE_TO_IN        : Number := -39
CONSTANT CORE_TO_NUMBER    : Number := -40
CONSTANT CORE_TO_R         : Number := -41
CONSTANT CORE_Q_DUP        : Number := -42
CONSTANT CORE_FETCH        : Number := -43
CONSTANT CORE_ABS          : Number := -44
CONSTANT CORE_ACCEPT       : Number := -45
CONSTANT CORE_ALIGN        : Number := -46
CONSTANT CORE_ALIGNED      : Number := -47
CONSTANT CORE_ALLOT        : Number := -48
CONSTANT CORE_AND          : Number := -49
CONSTANT CORE_BASE         : Number := -50
CONSTANT CORE_BEGIN        : Number := -51
CONSTANT CORE_BL           : Number := -52
CONSTANT CORE_C_STORE      : Number := -53
CONSTANT CORE_C_COMMA      : Number := -54
CONSTANT CORE_C_FETCH      : Number := -55
CONSTANT CORE_CELL_PLUS    : Number := -56
CONSTANT CORE_CELLS        : Number := -57
CONSTANT CORE_CHAR         : Number := -58
CONSTANT CORE_CHAR_PLUS    : Number := -59
CONSTANT CORE_CHARS        : Number := -60
CONSTANT CORE_CONSTANT     : Number := -61
CONSTANT CORE_COUNT        : Number := -62
CONSTANT CORE_CR           : Number := -63
CONSTANT CORE_CREATE       : Number := -64
CONSTANT CORE_DECIMAL      : Number := -65
CONSTANT CORE_DEPTH        : Number := -66
CONSTANT CORE_DO           : Number := -67
CONSTANT CORE_DOES         : Number := -68
CONSTANT CORE_DROP         : Number := -69
CONSTANT CORE_DUP          : Number := -70
CONSTANT CORE_ELSE         : Number := -71
CONSTANT CORE_EMIT         : Number := -72
CONSTANT CORE_ENVIRONMENT_Q: Number := -73
CONSTANT CORE_EVALUATE     : Number := -74
CONSTANT CORE_EXECUTE      : Number := -75
CONSTANT CORE_EXIT         : Number := -76
CONSTANT CORE_FALSE        : Number := -77
CONSTANT CORE_FILL         : Number := -78
CONSTANT CORE_FIND         : Number := -79
CONSTANT CORE_FM_MOD       : Number := -80
CONSTANT CORE_HERE         : Number := -81
CONSTANT CORE_HEX          : Number := -82
CONSTANT CORE_HOLD         : Number := -83
CONSTANT CORE_I            : Number := -84
CONSTANT CORE_IF           : Number := -85
CONSTANT CORE_IMMEDIATE    : Number := -86
CONSTANT CORE_INVERT       : Number := -87
CONSTANT CORE_J            : Number := -88
CONSTANT CORE_LEAVE        : Number := -89
CONSTANT CORE_LITERAL      : Number := -90
CONSTANT CORE_LOOP         : Number := -91
CONSTANT CORE_LSHIFT       : Number := -92
CONSTANT CORE_M_MUL        : Number := -93
CONSTANT CORE_MAX          : Number := -94
CONSTANT CORE_MIN          : Number := -95
CONSTANT CORE_MOD          : Number := -96
CONSTANT CORE_MOVE         : Number := -97
CONSTANT CORE_NEGATE       : Number := -98
CONSTANT CORE_NOT          : Number := -99
CONSTANT CORE_OR           : Number := -100
CONSTANT CORE_OVER         : Number := -101
CONSTANT CORE_PAD          : Number := -102
CONSTANT CORE_POSTPONE     : Number := -103
CONSTANT CORE_R_FROM       : Number := -104
CONSTANT CORE_R_FETCH      : Number := -105
CONSTANT CORE_RECURSE      : Number := -106
CONSTANT CORE_REPEAT       : Number := -107
CONSTANT CORE_ROT          : Number := -108
CONSTANT CORE_RSHIFT       : Number := -109
CONSTANT CORE_S_QUOTE      : Number := -110
CONSTANT CORE_S_TO_D       : Number := -111
CONSTANT CORE_SIGN         : Number := -112
CONSTANT CORE_SM_REM       : Number := -113
CONSTANT CORE_SOURCE       : Number := -114
CONSTANT CORE_SPACE        : Number := -115
CONSTANT CORE_SPACES       : Number := -116
CONSTANT CORE_STATE        : Number := -117
CONSTANT CORE_SWAP         : Number := -118
CONSTANT CORE_THEN         : Number := -119
CONSTANT CORE_TRUE         : Number := -120
CONSTANT CORE_TUCK         : Number := -121
CONSTANT CORE_TYPE         : Number := -122
CONSTANT CORE_U_PRINT      : Number := -123
CONSTANT CORE_U_LESS       : Number := -124
CONSTANT CORE_UM_MOD       : Number := -125
CONSTANT CORE_UM_MUL       : Number := -126
CONSTANT CORE_UNLOOP       : Number := -127
CONSTANT CORE_UNTIL        : Number := -128
CONSTANT CORE_VARIABLE     : Number := -129
CONSTANT CORE_WHILE        : Number := -130
CONSTANT CORE_WORD         : Number := -131
CONSTANT CORE_XOR          : Number := -132
CONSTANT CORE_INTERPRET    : Number := -133
CONSTANT CORE_IMM_TICK     : Number := -134
CONSTANT CORE_IMM_CHAR     : Number := -135
CONSTANT CORE_BACKSLASH    : Number := -136
CONSTANT CORE_COMPILE      : Number := -137

CONSTANT TOOLS_PRINT_S     : Number := -201
CONSTANT TOOLS_QUESTION    : Number := -202
CONSTANT TOOLS_DUMP        : Number := -203
CONSTANT TOOLS_SEE         : Number := -204
CONSTANT TOOLS_WORDS       : Number := -205

CONSTANT TOOLS_EXT_BYE     : Number := -301
CONSTANT TOOLS_EXT_ELSE    : Number := -302
CONSTANT TOOLS_EXT_IF      : Number := -303
CONSTANT TOOLS_EXT_THEN    : Number := -304

CONSTANT INT_BRANCH        : Number := -1001
CONSTANT INT_DO            : Number := -1002
CONSTANT INT_DOES          : Number := -1003
CONSTANT INT_EXIT          : Number := -1004
CONSTANT INT_LEAVE         : Number := -1005
CONSTANT INT_LITERAL       : Number := -1006
CONSTANT INT_LOOP          : Number := -1007
CONSTANT INT_PLUS_LOOP     : Number := -1008
CONSTANT INT_POSTPONE      : Number := -1009
CONSTANT INT_POSTPONE_IMM  : Number := -1010
CONSTANT INT_PRINT_QUOTE   : Number := -1011
CONSTANT INT_Q_BRANCH      : Number := -1012
CONSTANT INT_S_QUOTE       : Number := -1013
CONSTANT INT_UNLOOP        : Number := -1014

TYPE Word IS RECORD
    xt: Number
    immediate: Boolean
END RECORD

VAR dispatch: Array<FUNCTION(INOUT ip: Number)>
dispatch[-CORE_STORE        ] := run_CORE_STORE
dispatch[-CORE_NUMBER       ] := run_CORE_NUMBER
dispatch[-CORE_NUMBER_GT    ] := run_CORE_NUMBER_GT
dispatch[-CORE_NUMBER_S     ] := run_CORE_NUMBER_S
%dispatch[-CORE_TICK         ] := run_CORE_TICK
%dispatch[-CORE_COMMENT      ] := run_CORE_COMMENT
dispatch[-CORE_MUL          ] := run_CORE_MUL
dispatch[-CORE_MUL_DIV      ] := run_CORE_MUL_DIV
dispatch[-CORE_MUL_DIV_MOD  ] := run_CORE_MUL_DIV_MOD
dispatch[-CORE_ADD          ] := run_CORE_ADD
dispatch[-CORE_ADD_STORE    ] := run_CORE_ADD_STORE
%dispatch[-CORE_PLUS_LOOP    ] := run_CORE_PLUS_LOOP
dispatch[-CORE_COMMA        ] := run_CORE_COMMA
dispatch[-CORE_SUB          ] := run_CORE_SUB
dispatch[-CORE_PRINT        ] := run_CORE_PRINT
%dispatch[-CORE_PRINT_QUOTE  ] := run_CORE_PRINT_QUOTE
dispatch[-CORE_DIV          ] := run_CORE_DIV
dispatch[-CORE_DIV_MOD      ] := run_CORE_DIV_MOD
dispatch[-CORE_0_LESS       ] := run_CORE_0_LESS
dispatch[-CORE_0_EQUAL      ] := run_CORE_0_EQUAL
dispatch[-CORE_1_PLUS       ] := run_CORE_1_PLUS
dispatch[-CORE_1_MINUS      ] := run_CORE_1_MINUS
dispatch[-CORE_2_STORE      ] := run_CORE_2_STORE
dispatch[-CORE_2_TIMES      ] := run_CORE_2_TIMES
dispatch[-CORE_2_DIVIDE     ] := run_CORE_2_DIVIDE
dispatch[-CORE_2_FETCH      ] := run_CORE_2_FETCH
dispatch[-CORE_2DROP        ] := run_CORE_2DROP
dispatch[-CORE_2DUP         ] := run_CORE_2DUP
dispatch[-CORE_2OVER        ] := run_CORE_2OVER
dispatch[-CORE_2SWAP        ] := run_CORE_2SWAP
dispatch[-CORE_DEFINE       ] := run_CORE_DEFINE
%dispatch[-CORE_SEMICOLON    ] := run_CORE_SEMICOLON
dispatch[-CORE_LESS         ] := run_CORE_LESS
dispatch[-CORE_LESS_NUMBER  ] := run_CORE_LESS_NUMBER
dispatch[-CORE_NOT_EQUAL    ] := run_CORE_NOT_EQUAL
dispatch[-CORE_EQUAL        ] := run_CORE_EQUAL
dispatch[-CORE_GREATER      ] := run_CORE_GREATER
dispatch[-CORE_TO_BODY      ] := run_CORE_TO_BODY
dispatch[-CORE_TO_IN        ] := run_CORE_TO_IN
dispatch[-CORE_TO_NUMBER    ] := run_CORE_TO_NUMBER
dispatch[-CORE_TO_R         ] := run_CORE_TO_R
dispatch[-CORE_Q_DUP        ] := run_CORE_Q_DUP
dispatch[-CORE_FETCH        ] := run_CORE_FETCH
dispatch[-CORE_ABS          ] := run_CORE_ABS
dispatch[-CORE_ACCEPT       ] := run_CORE_ACCEPT
dispatch[-CORE_ALIGN        ] := run_CORE_ALIGN
dispatch[-CORE_ALIGNED      ] := run_CORE_ALIGNED
dispatch[-CORE_ALLOT        ] := run_CORE_ALLOT
dispatch[-CORE_AND          ] := run_CORE_AND
dispatch[-CORE_BASE         ] := run_CORE_BASE
%dispatch[-CORE_BEGIN        ] := run_CORE_BEGIN
dispatch[-CORE_BL           ] := run_CORE_BL
dispatch[-CORE_C_STORE      ] := run_CORE_C_STORE
dispatch[-CORE_C_COMMA      ] := run_CORE_C_COMMA
dispatch[-CORE_C_FETCH      ] := run_CORE_C_FETCH
dispatch[-CORE_CELL_PLUS    ] := run_CORE_CELL_PLUS
dispatch[-CORE_CELLS        ] := run_CORE_CELLS
dispatch[-CORE_CHAR         ] := run_CORE_CHAR
dispatch[-CORE_CHAR_PLUS    ] := run_CORE_CHAR_PLUS
dispatch[-CORE_CHARS        ] := run_CORE_CHARS
dispatch[-CORE_CONSTANT     ] := run_CORE_CONSTANT
dispatch[-CORE_COUNT        ] := run_CORE_COUNT
dispatch[-CORE_CR           ] := run_CORE_CR
dispatch[-CORE_CREATE       ] := run_CORE_CREATE
dispatch[-CORE_DECIMAL      ] := run_CORE_DECIMAL
dispatch[-CORE_DEPTH        ] := run_CORE_DEPTH
%dispatch[-CORE_DO           ] := run_CORE_DO
%dispatch[-CORE_DOES         ] := run_CORE_DOES
dispatch[-CORE_DROP         ] := run_CORE_DROP
dispatch[-CORE_DUP          ] := run_CORE_DUP
%dispatch[-CORE_ELSE         ] := run_CORE_ELSE
dispatch[-CORE_EMIT         ] := run_CORE_EMIT
dispatch[-CORE_ENVIRONMENT_Q] := run_CORE_ENVIRONMENT_Q
dispatch[-CORE_EVALUATE     ] := run_CORE_EVALUATE
dispatch[-CORE_EXECUTE      ] := run_CORE_EXECUTE
%dispatch[-CORE_EXIT         ] := run_CORE_EXIT
dispatch[-CORE_FALSE        ] := run_CORE_FALSE
dispatch[-CORE_FILL         ] := run_CORE_FILL
dispatch[-CORE_FIND         ] := run_CORE_FIND
dispatch[-CORE_FM_MOD       ] := run_CORE_FM_MOD
dispatch[-CORE_HERE         ] := run_CORE_HERE
dispatch[-CORE_HEX          ] := run_CORE_HEX
dispatch[-CORE_HOLD         ] := run_CORE_HOLD
dispatch[-CORE_I            ] := run_CORE_I
%dispatch[-CORE_IF           ] := run_CORE_IF
dispatch[-CORE_IMMEDIATE    ] := run_CORE_IMMEDIATE
dispatch[-CORE_INVERT       ] := run_CORE_INVERT
dispatch[-CORE_J            ] := run_CORE_J
%dispatch[-CORE_LEAVE        ] := run_CORE_LEAVE
%dispatch[-CORE_LITERAL      ] := run_CORE_LITERAL
%dispatch[-CORE_LOOP         ] := run_CORE_LOOP
dispatch[-CORE_LSHIFT       ] := run_CORE_LSHIFT
dispatch[-CORE_M_MUL        ] := run_CORE_M_MUL
dispatch[-CORE_MAX          ] := run_CORE_MAX
dispatch[-CORE_MIN          ] := run_CORE_MIN
dispatch[-CORE_MOD          ] := run_CORE_MOD
dispatch[-CORE_MOVE         ] := run_CORE_MOVE
dispatch[-CORE_NEGATE       ] := run_CORE_NEGATE
dispatch[-CORE_NOT          ] := run_CORE_NOT
dispatch[-CORE_OR           ] := run_CORE_OR
dispatch[-CORE_OVER         ] := run_CORE_OVER
dispatch[-CORE_PAD          ] := run_CORE_PAD
%dispatch[-CORE_POSTPONE     ] := run_CORE_POSTPONE
dispatch[-CORE_R_FROM       ] := run_CORE_R_FROM
dispatch[-CORE_R_FETCH      ] := run_CORE_R_FETCH
%dispatch[-CORE_RECURSE      ] := run_CORE_RECURSE
%dispatch[-CORE_REPEAT       ] := run_CORE_REPEAT
dispatch[-CORE_ROT          ] := run_CORE_ROT
dispatch[-CORE_RSHIFT       ] := run_CORE_RSHIFT
%dispatch[-CORE_S_QUOTE      ] := run_CORE_S_QUOTE
dispatch[-CORE_S_TO_D       ] := run_CORE_S_TO_D
dispatch[-CORE_SIGN         ] := run_CORE_SIGN
dispatch[-CORE_SM_REM       ] := run_CORE_SM_REM
dispatch[-CORE_SOURCE       ] := run_CORE_SOURCE
dispatch[-CORE_SPACE        ] := run_CORE_SPACE
dispatch[-CORE_SPACES       ] := run_CORE_SPACES
dispatch[-CORE_STATE        ] := run_CORE_STATE
dispatch[-CORE_SWAP         ] := run_CORE_SWAP
%dispatch[-CORE_THEN         ] := run_CORE_THEN
dispatch[-CORE_TRUE         ] := run_CORE_TRUE
dispatch[-CORE_TUCK         ] := run_CORE_TUCK
dispatch[-CORE_TYPE         ] := run_CORE_TYPE
dispatch[-CORE_U_PRINT      ] := run_CORE_U_PRINT
dispatch[-CORE_U_LESS       ] := run_CORE_U_LESS
dispatch[-CORE_UM_MOD       ] := run_CORE_UM_MOD
dispatch[-CORE_UM_MUL       ] := run_CORE_UM_MUL
%dispatch[-CORE_UNLOOP       ] := run_CORE_UNLOOP
%dispatch[-CORE_UNTIL        ] := run_CORE_UNTIL
dispatch[-CORE_VARIABLE     ] := run_CORE_VARIABLE
%dispatch[-CORE_WHILE        ] := run_CORE_WHILE
dispatch[-CORE_WORD         ] := run_CORE_WORD
dispatch[-CORE_XOR          ] := run_CORE_XOR
%dispatch[-CORE_INTERPRET    ] := run_CORE_INTERPRET
%dispatch[-CORE_IMM_TICK     ] := run_CORE_IMM_TICK
%dispatch[-CORE_IMM_CHAR     ] := run_CORE_IMM_CHAR
%dispatch[-CORE_BACKSLASH    ] := run_CORE_BACKSLASH
%dispatch[-CORE_COMPILE      ] := run_CORE_COMPILE
dispatch[-TOOLS_PRINT_S     ] := run_TOOLS_PRINT_S
dispatch[-TOOLS_QUESTION    ] := run_TOOLS_QUESTION
dispatch[-TOOLS_DUMP        ] := run_TOOLS_DUMP
dispatch[-TOOLS_SEE         ] := run_TOOLS_SEE
dispatch[-TOOLS_WORDS       ] := run_TOOLS_WORDS
dispatch[-TOOLS_EXT_BYE     ] := run_TOOLS_EXT_BYE
%dispatch[-TOOLS_EXT_ELSE    ] := run_TOOLS_EXT_ELSE
%dispatch[-TOOLS_EXT_IF      ] := run_TOOLS_EXT_IF
%dispatch[-TOOLS_EXT_THEN    ] := run_TOOLS_EXT_THEN
dispatch[-INT_BRANCH        ] := run_INT_BRANCH
dispatch[-INT_DO            ] := run_INT_DO
dispatch[-INT_DOES          ] := run_INT_DOES
dispatch[-INT_EXIT          ] := run_INT_EXIT
dispatch[-INT_LEAVE         ] := run_INT_LEAVE
dispatch[-INT_LITERAL       ] := run_INT_LITERAL
dispatch[-INT_LOOP          ] := run_INT_LOOP
dispatch[-INT_PLUS_LOOP     ] := run_INT_PLUS_LOOP
dispatch[-INT_POSTPONE      ] := run_INT_POSTPONE
dispatch[-INT_POSTPONE_IMM  ] := run_INT_POSTPONE_IMM
dispatch[-INT_PRINT_QUOTE   ] := run_INT_PRINT_QUOTE
dispatch[-INT_Q_BRANCH      ] := run_INT_Q_BRANCH
dispatch[-INT_S_QUOTE       ] := run_INT_S_QUOTE
dispatch[-INT_UNLOOP        ] := run_INT_UNLOOP

VAR words: Dictionary<Word> := {
    "!": Word(CORE_STORE)
    "#": Word(CORE_NUMBER)
    "#>": Word(CORE_NUMBER_GT)
    "#S": Word(CORE_NUMBER_S)
    "'": Word(CORE_TICK)
    "(": Word(CORE_COMMENT)
    "*": Word(CORE_MUL)
    "*/": Word(CORE_MUL_DIV)
    "*/MOD": Word(CORE_MUL_DIV_MOD)
    "+": Word(CORE_ADD)
    "+!": Word(CORE_ADD_STORE)
    "+LOOP": Word(CORE_PLUS_LOOP)
    ",": Word(CORE_COMMA)
    "-": Word(CORE_SUB)
    ".": Word(CORE_PRINT)
    ".\"": Word(CORE_PRINT_QUOTE)
    ".S": Word(TOOLS_PRINT_S)
    "/": Word(CORE_DIV)
    "/MOD": Word(CORE_DIV_MOD)
    "0<": Word(CORE_0_LESS)
    "0=": Word(CORE_0_EQUAL)
    "1+": Word(CORE_1_PLUS)
    "1-": Word(CORE_1_MINUS)
    "2!": Word(CORE_2_STORE)
    "2*": Word(CORE_2_TIMES)
    "2/": Word(CORE_2_DIVIDE)
    "2@": Word(CORE_2_FETCH)
    "2DROP": Word(CORE_2DROP)
    "2DUP": Word(CORE_2DUP)
    "2OVER": Word(CORE_2OVER)
    "2SWAP": Word(CORE_2SWAP)
    ":": Word(CORE_DEFINE)
    ";": Word(CORE_SEMICOLON)
    "<": Word(CORE_LESS)
    "<#": Word(CORE_LESS_NUMBER)
    "<>": Word(CORE_NOT_EQUAL)
    "=": Word(CORE_EQUAL)
    ">": Word(CORE_GREATER)
    ">BODY": Word(CORE_TO_BODY)
    ">IN": Word(CORE_TO_IN)
    ">NUMBER": Word(CORE_TO_NUMBER)
    ">R": Word(CORE_TO_R)
    "?": Word(TOOLS_QUESTION)
    "?DUP": Word(CORE_Q_DUP)
    "@": Word(CORE_FETCH)
    "ABS": Word(CORE_ABS)
    "ACCEPT": Word(CORE_ACCEPT)
    "ALIGN": Word(CORE_ALIGN)
    "ALIGNED": Word(CORE_ALIGNED)
    "ALLOT": Word(CORE_ALLOT)
    "AND": Word(CORE_AND)
    "BASE": Word(CORE_BASE)
    "BEGIN": Word(CORE_BEGIN)
    "BL": Word(CORE_BL)
    "BYE": Word(TOOLS_EXT_BYE)
    "C!": Word(CORE_C_STORE)
    "C,": Word(CORE_C_COMMA)
    "C@": Word(CORE_C_FETCH)
    "CELL+": Word(CORE_CELL_PLUS)
    "CELLS": Word(CORE_CELLS)
    "CHAR": Word(CORE_CHAR)
    "CHAR+": Word(CORE_CHAR_PLUS)
    "CHARS": Word(CORE_CHARS)
    "CONSTANT": Word(CORE_CONSTANT)
    "COUNT": Word(CORE_COUNT)
    "CR": Word(CORE_CR)
    "CREATE": Word(CORE_CREATE)
    "DECIMAL": Word(CORE_DECIMAL)
    "DEPTH": Word(CORE_DEPTH)
    "DO": Word(CORE_DO)
    "DOES>": Word(CORE_DOES)
    "DROP": Word(CORE_DROP)
    "DUMP": Word(TOOLS_DUMP)
    "DUP": Word(CORE_DUP)
    "ELSE": Word(CORE_ELSE)
    "EMIT": Word(CORE_EMIT)
    "ENVIRONMENT?": Word(CORE_ENVIRONMENT_Q)
    "EVALUATE": Word(CORE_EVALUATE)
    "EXECUTE": Word(CORE_EXECUTE)
    "EXIT": Word(CORE_EXIT)
    "FALSE": Word(CORE_FALSE)
    "FILL": Word(CORE_FILL)
    "FIND": Word(CORE_FIND)
    "FM/MOD": Word(CORE_FM_MOD)
    "HERE": Word(CORE_HERE)
    "HEX": Word(CORE_HEX)
    "HOLD": Word(CORE_HOLD)
    "I": Word(CORE_I)
    "IF": Word(CORE_IF)
    "IMMEDIATE": Word(CORE_IMMEDIATE)
    "INVERT": Word(CORE_INVERT)
    "J": Word(CORE_J)
    "LEAVE": Word(CORE_LEAVE)
    "LITERAL": Word(CORE_LITERAL)
    "LOOP": Word(CORE_LOOP)
    "LSHIFT": Word(CORE_LSHIFT)
    "M*": Word(CORE_M_MUL)
    "MAX": Word(CORE_MAX)
    "MIN": Word(CORE_MIN)
    "MOD": Word(CORE_MOD)
    "MOVE": Word(CORE_MOVE)
    "NEGATE": Word(CORE_NEGATE)
    "NOT": Word(CORE_NOT)
    "OR": Word(CORE_OR)
    "OVER": Word(CORE_OVER)
    "PAD": Word(CORE_PAD)
    "POSTPONE": Word(CORE_POSTPONE)
    "R>": Word(CORE_R_FROM)
    "R@": Word(CORE_R_FETCH)
    "RECURSE": Word(CORE_RECURSE)
    "REPEAT": Word(CORE_REPEAT)
    "ROT": Word(CORE_ROT)
    "RSHIFT": Word(CORE_RSHIFT)
    "S\"": Word(CORE_S_QUOTE)
    "S>D": Word(CORE_S_TO_D)
    "SEE": Word(TOOLS_SEE)
    "SIGN": Word(CORE_SIGN)
    "SM/REM": Word(CORE_SM_REM)
    "SOURCE": Word(CORE_SOURCE)
    "SPACE": Word(CORE_SPACE)
    "SPACES": Word(CORE_SPACES)
    "STATE": Word(CORE_STATE)
    "SWAP": Word(CORE_SWAP)
    "THEN": Word(CORE_THEN)
    "TRUE": Word(CORE_TRUE)
    "TUCK": Word(CORE_TUCK)
    "TYPE": Word(CORE_TYPE)
    "U.": Word(CORE_U_PRINT)
    "U<": Word(CORE_U_LESS)
    "UM/MOD": Word(CORE_UM_MOD)
    "UM*": Word(CORE_UM_MUL)
    "UNLOOP": Word(CORE_UNLOOP)
    "UNTIL": Word(CORE_UNTIL)
    "VARIABLE": Word(CORE_VARIABLE)
    "WHILE": Word(CORE_WHILE)
    "WORD": Word(CORE_WORD)
    "WORDS": Word(TOOLS_WORDS)
    "XOR": Word(CORE_XOR)
    "[": Word(CORE_INTERPRET)
    "[']": Word(CORE_IMM_TICK)
    "[CHAR]": Word(CORE_IMM_CHAR)
    "[ELSE]": Word(TOOLS_EXT_ELSE)
    "[IF]": Word(TOOLS_EXT_IF)
    "[THEN]": Word(TOOLS_EXT_THEN)
    @"\": Word(CORE_BACKSLASH)
    "]": Word(CORE_COMPILE)
}
VAR code: Array<Number> := [0]
VAR stack: Stack
VAR storage: Array<Number>
VAR defining: String
VAR define_start: Number
VAR compilation: Stack
VAR return: Array<ReturnEntry>

FUNCTION alloc(n: Number, INOUT i: Number): Number
    LET r: Number := i
    i := i + n
    RETURN r
END FUNCTION

VAR index: Number := 0
LET cell_state: Number := alloc(1, index)
LET cell_normal_input: Number := alloc(200, index)
LET cell_normal_input_length: Number := alloc(1, index)
LET cell_normal_in: Number := alloc(1, index)
LET cell_eval_input_length: Number := alloc(1, index)
LET cell_eval_in: Number := alloc(1, index)
LET cell_base: Number := alloc(1, index)
LET cell_pad: Number := alloc(84, index)
LET cell_number_buffer: Number := alloc(NUMBER_BUFFER_MAX, index)
VAR number_buffer_size: Number
storage[cell_base] := 10
storage[index] := 0

VAR cell_input: Number := cell_normal_input
VAR cell_input_length: Number := cell_normal_input_length
VAR cell_in: Number := cell_normal_in

FUNCTION get_string_len(addr, len: Number): String
    VAR r: String
    FOR i := 0 TO len-1 DO
        r.append(chr(storage[addr+i]))
    END FOR
    RETURN r
END FUNCTION

FUNCTION get_string(addr: Number): String
    LET len: Number := storage[addr]
    RETURN get_string_len(addr+1, len)
END FUNCTION

FUNCTION run_CORE_STORE(INOUT ip: Number)
    LET addr: Number := stack.pop()
    LET x: Number := stack.pop()
    storage[addr] := x
END FUNCTION

FUNCTION run_CORE_NUMBER(INOUT ip: Number)
    LET ud1h: Number := stack.pop()
    LET ud1l: Number := stack.pop()
    LET ud1: Number := ud1h * 0x100000000 + ud1l
    LET dig: Number := ud1 MOD storage[cell_base]
    LET ud2: Number := math.floor(ud1 / storage[cell_base])
    stack.push(ud2 MOD 0x100000000)
    stack.push(math.floor(ud2 / 0x100000000))
    inc(number_buffer_size)
    storage[cell_number_buffer + NUMBER_BUFFER_MAX - number_buffer_size] := ord(Digits[dig])
END FUNCTION

FUNCTION run_CORE_NUMBER_GT(INOUT ip: Number)
    LET xdh: Number := stack.pop()
    LET xdl: Number := stack.pop()
    stack.push(cell_number_buffer + NUMBER_BUFFER_MAX - number_buffer_size)
    stack.push(number_buffer_size)
END FUNCTION

FUNCTION run_CORE_NUMBER_S(INOUT ip: Number)
    LET ud1h: Number := stack.pop()
    LET ud1l: Number := stack.pop()
    VAR ud1: Number := ud1h * 0x100000000 + ud1l
    REPEAT
        LET dig: Number := ud1 MOD storage[cell_base]
        ud1 := math.floor(ud1 / storage[cell_base])
        inc(number_buffer_size)
        storage[cell_number_buffer + NUMBER_BUFFER_MAX - number_buffer_size] := ord(Digits[dig])
    UNTIL ud1 = 0
    stack.push(0)
    stack.push(0)
END FUNCTION

FUNCTION run_CORE_MUL(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(n1 * n2)
END FUNCTION

FUNCTION run_CORE_MUL_DIV(INOUT ip: Number)
    LET n3: Number := signed32(stack.pop())
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(math.floor(n1 * n2 / n3))
END FUNCTION

FUNCTION run_CORE_MUL_DIV_MOD(INOUT ip: Number)
    LET n3: Number := signed32(stack.pop())
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    LET p: Number := n1 * n2
    stack.push(p MOD n3)
    stack.push(math.floor(p / n3))
END FUNCTION

FUNCTION run_CORE_ADD(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(n1 + n2)
END FUNCTION

FUNCTION run_CORE_ADD_STORE(INOUT ip: Number)
    LET addr: Number := stack.pop()
    LET n: Number := signed32(stack.pop())
    storage[addr] := storage[addr] + n
END FUNCTION

FUNCTION run_CORE_COMMA(INOUT ip: Number)
    LET x: Number := stack.pop()
    storage.append(x)
END FUNCTION

FUNCTION run_CORE_SUB(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(n1 - n2)
END FUNCTION

FUNCTION run_CORE_PRINT(INOUT ip: Number)
    LET n: Number := signed32(stack.pop())
    io.write(io.stdout(), "\(n) ")
END FUNCTION

FUNCTION run_CORE_DIV(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(math.floor(n1 / n2))
END FUNCTION

FUNCTION run_CORE_DIV_MOD(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(n1 MOD n2)
    stack.push(math.floor(n1 / n2))
END FUNCTION

FUNCTION run_CORE_0_LESS(INOUT ip: Number)
    LET n: Number := signed32(stack.pop())
    stack.push(IF n < 0 THEN -1 ELSE 0)
END FUNCTION

FUNCTION run_CORE_0_EQUAL(INOUT ip: Number)
    LET n: Number := stack.pop()
    stack.push(IF n = 0 THEN -1 ELSE 0)
END FUNCTION

FUNCTION run_CORE_1_PLUS(INOUT ip: Number)
    LET n1: Number := signed32(stack.pop())
    stack.push(n1 + 1)
END FUNCTION

FUNCTION run_CORE_1_MINUS(INOUT ip: Number)
    LET n1: Number := signed32(stack.pop())
    stack.push(n1 - 1)
END FUNCTION

FUNCTION run_CORE_2_STORE(INOUT ip: Number)
    LET addr: Number := stack.pop()
    LET x2: Number := stack.pop()
    LET x1: Number := stack.pop()
    storage[addr] := x2
    storage[addr+1] := x1
END FUNCTION

FUNCTION run_CORE_2_TIMES(INOUT ip: Number)
    LET n1: Number := stack.pop()
    stack.push(bitwise.shiftLeft32(n1, 1))
END FUNCTION

FUNCTION run_CORE_2_DIVIDE(INOUT ip: Number)
    LET n1: Number := signed32(stack.pop())
    stack.push(bitwise.shiftRightSigned32(n1, 1))
END FUNCTION

FUNCTION run_CORE_2_FETCH(INOUT ip: Number)
    LET addr: Number := stack.pop()
    stack.push(storage[addr+1])
    stack.push(storage[addr])
END FUNCTION

FUNCTION run_CORE_2DROP(INOUT ip: Number)
    stack.drop(2)
END FUNCTION

FUNCTION run_CORE_2DUP(INOUT ip: Number)
    LET x2: Number := stack.pop()
    LET x1: Number := stack.pop()
    stack.push(x1)
    stack.push(x2)
    stack.push(x1)
    stack.push(x2)
END FUNCTION

FUNCTION run_CORE_2OVER(INOUT ip: Number)
    LET x4: Number := stack.pop()
    LET x3: Number := stack.pop()
    LET x2: Number := stack.pop()
    LET x1: Number := stack.pop()
    stack.push(x1)
    stack.push(x2)
    stack.push(x3)
    stack.push(x4)
    stack.push(x1)
    stack.push(x2)
END FUNCTION

FUNCTION run_CORE_2SWAP(INOUT ip: Number)
    LET x4: Number := stack.pop()
    LET x3: Number := stack.pop()
    LET x2: Number := stack.pop()
    LET x1: Number := stack.pop()
    stack.push(x3)
    stack.push(x4)
    stack.push(x1)
    stack.push(x2)
END FUNCTION

FUNCTION run_CORE_DEFINE(INOUT ip: Number)
    defining := next_word()
    define_start := code.size()
    storage[cell_state] := -1
END FUNCTION

FUNCTION run_CORE_LESS(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(IF n1 < n2 THEN -1 ELSE 0)
END FUNCTION

FUNCTION run_CORE_LESS_NUMBER(INOUT ip: Number)
    number_buffer_size := 0
END FUNCTION

FUNCTION run_CORE_NOT_EQUAL(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(IF n1 # n2 THEN -1 ELSE 0)
END FUNCTION

FUNCTION run_CORE_EQUAL(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(IF n1 = n2 THEN -1 ELSE 0)
END FUNCTION

FUNCTION run_CORE_GREATER(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(IF n1 > n2 THEN -1 ELSE 0)
END FUNCTION

FUNCTION run_CORE_TO_BODY(INOUT ip: Number)
    LET xt: Number := stack.pop()
    ASSERT code[xt] = INT_LITERAL
    ASSERT code[xt+2] = 0 OR code[xt+2] = INT_BRANCH
    ASSERT code[xt+4] = 0
    stack.push(code[xt+1])
END FUNCTION

FUNCTION run_CORE_TO_IN(INOUT ip: Number)
    stack.push(cell_in)
END FUNCTION

FUNCTION run_CORE_TO_NUMBER(INOUT ip: Number)
    VAR u: Number := stack.pop()
    VAR addr: Number := stack.pop()
    LET ud1h: Number := stack.pop()
    LET ud1l: Number := stack.pop()
    VAR ud1: Number := ud1h * 0x100000000 + ud1l
    WHILE u > 0 DO
        LET char: String := chr(storage[addr])
        VAR dig: Number
        IF "0" <= char <= "9" THEN
            dig := ord(char) - ord("0")
        ELSIF "A" <= char <= "Z" THEN
            dig := ord(char) - ord("A") + 10
        ELSE
            EXIT WHILE
        END IF
        IF dig >= storage[cell_base] THEN
            EXIT WHILE
        END IF
        ud1 := ud1 * storage[cell_base] + dig
        inc(addr)
        dec(u)
    END WHILE
    stack.push(ud1 MOD 0x100000000)
    stack.push(math.floor(ud1 / 0x100000000))
    stack.push(addr)
    stack.push(u)
END FUNCTION

FUNCTION run_CORE_TO_R(INOUT ip: Number)
    LET x: Number := stack.pop()
    return.append(ReturnEntry(x))
END FUNCTION

FUNCTION run_CORE_Q_DUP(INOUT ip: Number)
    LET x: Number := stack.pop()
    stack.push(x)
    IF x # 0 THEN
        stack.push(x)
    END IF
END FUNCTION

FUNCTION run_CORE_FETCH(INOUT ip: Number)
    LET addr: Number := stack.pop()
    stack.push(storage[addr])
END FUNCTION

FUNCTION run_CORE_ABS(INOUT ip: Number)
    LET n: Number := signed32(stack.pop())
    stack.push(math.abs(n))
END FUNCTION

FUNCTION run_CORE_ACCEPT(INOUT ip: Number)
    LET n: Number := signed32(stack.pop())
    LET addr: Number := stack.pop()
    LET s: String := input("")
    FOR i := 0 TO min(n-1, s.length()-1) DO
        storage[addr+i] := ord(s[i])
    END FOR
    stack.push(s.length())
END FUNCTION

FUNCTION run_CORE_ALIGN(INOUT ip: Number)
    % no action required
END FUNCTION

FUNCTION run_CORE_ALIGNED(INOUT ip: Number)
    % no action required
END FUNCTION

FUNCTION run_CORE_ALLOT(INOUT ip: Number)
    LET n: Number := signed32(stack.pop())
    storage.resize(storage.size() + n)
END FUNCTION

FUNCTION run_CORE_AND(INOUT ip: Number)
    LET x2: Number := stack.pop()
    LET x1: Number := stack.pop()
    stack.push(bitwise.and32(x1, x2))
END FUNCTION

FUNCTION run_CORE_BASE(INOUT ip: Number)
    stack.push(cell_base)
END FUNCTION

FUNCTION run_CORE_BL(INOUT ip: Number)
    stack.push(ord(" "))
END FUNCTION

FUNCTION run_CORE_C_STORE(INOUT ip: Number)
    LET addr: Number := stack.pop()
    LET x: Number := stack.pop()
    storage[addr] := x
END FUNCTION

FUNCTION run_CORE_C_COMMA(INOUT ip: Number)
    LET x: Number := stack.pop()
    storage.append(x)
END FUNCTION

FUNCTION run_CORE_C_FETCH(INOUT ip: Number)
    LET addr: Number := stack.pop()
    stack.push(storage[addr])
END FUNCTION

FUNCTION run_CORE_CELL_PLUS(INOUT ip: Number)
    LET addr: Number := stack.pop()
    stack.push(addr+1)
END FUNCTION

FUNCTION run_CORE_CELLS(INOUT ip: Number)
    LET n: Number := signed32(stack.pop())
    stack.push(n)
END FUNCTION

FUNCTION run_CORE_CHAR(INOUT ip: Number)
    LET s: String := next_word()
    stack.push(ord(s[FIRST]))
END FUNCTION

FUNCTION run_CORE_CHAR_PLUS(INOUT ip: Number)
    LET addr: Number := stack.pop()
    stack.push(addr+1)
END FUNCTION

FUNCTION run_CORE_CHARS(INOUT ip: Number)
    LET n: Number := signed32(stack.pop())
    stack.push(n)
END FUNCTION

FUNCTION run_CORE_CONSTANT(INOUT ip: Number)
    LET x: Number := stack.pop()
    LET s: String := next_word()
    words[s] := Word(code.size())
    code.append(INT_LITERAL)
    code.append(x)
    code.append(0)
END FUNCTION

FUNCTION run_CORE_COUNT(INOUT ip: Number)
    LET addr: Number := stack.pop()
    stack.push(addr+1)
    stack.push(storage[addr])
END FUNCTION

FUNCTION run_CORE_CR(INOUT ip: Number)
    print("")
END FUNCTION

FUNCTION run_CORE_CREATE(INOUT ip: Number)
    LET s: String := next_word()
    words[s] := Word(code.size())
    code.append(INT_LITERAL)
    code.append(storage.size())
    code.append(0)
    code.append(0)
    code.append(0)
END FUNCTION

FUNCTION run_CORE_DECIMAL(INOUT ip: Number)
    storage[cell_base] := 10
END FUNCTION

FUNCTION run_CORE_DEPTH(INOUT ip: Number)
    stack.push(stack.size())
END FUNCTION

FUNCTION run_CORE_DROP(INOUT ip: Number)
    stack.drop()
END FUNCTION

FUNCTION run_CORE_DUP(INOUT ip: Number)
    LET x: Number := stack.pop()
    stack.push(x)
    stack.push(x)
END FUNCTION

FUNCTION run_CORE_EMIT(INOUT ip: Number)
    LET x: Number := stack.pop()
    io.write(io.stdout(), chr(x))
END FUNCTION

FUNCTION run_CORE_ENVIRONMENT_Q(INOUT ip: Number)
    LET u: Number := stack.pop()
    LET addr: Number := stack.pop()
    CASE get_string_len(addr, u)
        WHEN "FLOATING" DO
            stack.push(0)
        ELSE
            stack.push(0)
    END CASE
END FUNCTION

FUNCTION run_CORE_EVALUATE(INOUT ip: Number)
    LET u: Number := stack.pop()
    LET addr: Number := stack.pop()
    storage[cell_eval_input_length] := u
    storage[cell_eval_in] := 0
    cell_input := addr
    cell_input_length := cell_eval_input_length
    cell_in := cell_eval_in
    interpret()
END FUNCTION

FUNCTION run_CORE_EXECUTE(INOUT ip: Number)
    LET xt: Number := stack.pop()
    IF xt > 0 THEN
        run_compiled(xt)
    ELSE
        run_instruction(xt, ip)
    END IF
END FUNCTION

FUNCTION run_CORE_FALSE(INOUT ip: Number)
    stack.push(0)
END FUNCTION

FUNCTION run_CORE_FILL(INOUT ip: Number)
    LET char: Number := stack.pop()
    VAR u: Number := stack.pop()
    VAR addr: Number := stack.pop()
    WHILE u > 0 DO
        storage[addr] := char
        inc(addr)
        dec(u)
    END WHILE
END FUNCTION

FUNCTION run_CORE_FIND(INOUT ip: Number)
    LET addr: Number := stack.pop()
    LET s: String := get_string(addr)
    IF s IN words THEN
        stack.push(words[s].xt)
        stack.push(IF words[s].immediate THEN 1 ELSE -1)
    ELSE
        stack.push(addr)
        stack.push(0)
    END IF
END FUNCTION

FUNCTION run_CORE_FM_MOD(INOUT ip: Number)
    LET n1: Number := signed32(stack.pop())
    LET d1h: Number := signed32(stack.pop())
    LET d1l: Number := stack.pop()
    LET d1: Number := d1h * 0x100000000 + d1l
    stack.push(d1 MOD n1)
    stack.push(math.floor(d1 / n1))
END FUNCTION

FUNCTION run_CORE_HERE(INOUT ip: Number)
    stack.push(storage.size())
END FUNCTION

FUNCTION run_CORE_HEX(INOUT ip: Number)
    storage[cell_base] := 0x10
END FUNCTION

FUNCTION run_CORE_HOLD(INOUT ip: Number)
    LET char: Number := stack.pop()
    inc(number_buffer_size)
    storage[cell_number_buffer + NUMBER_BUFFER_MAX - number_buffer_size] := char
END FUNCTION

FUNCTION run_CORE_I(INOUT ip: Number)
    stack.push(return[LAST].index)
END FUNCTION

FUNCTION run_CORE_IMMEDIATE(INOUT ip: Number)
    words[defining].immediate := TRUE
END FUNCTION

FUNCTION run_CORE_INVERT(INOUT ip: Number)
    LET x1: Number := stack.pop()
    stack.push(bitwise.not32(x1))
END FUNCTION

FUNCTION run_CORE_J(INOUT ip: Number)
    stack.push(return[LAST-1].index)
END FUNCTION

FUNCTION run_CORE_LSHIFT(INOUT ip: Number)
    LET u: Number := stack.pop()
    LET x1: Number := stack.pop()
    stack.push(bitwise.shiftLeft32(x1, u))
END FUNCTION

FUNCTION run_CORE_M_MUL(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    LET p: Number := n1 * n2
    stack.push(p)
    stack.push(math.floor(p / 0x100000000))
END FUNCTION

FUNCTION run_CORE_MAX(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(max(n1, n2))
END FUNCTION

FUNCTION run_CORE_MIN(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(min(n1, n2))
END FUNCTION

FUNCTION run_CORE_MOD(INOUT ip: Number)
    LET n2: Number := signed32(stack.pop())
    LET n1: Number := signed32(stack.pop())
    stack.push(n1 MOD n2)
END FUNCTION

FUNCTION run_CORE_MOVE(INOUT ip: Number)
    VAR u: Number := stack.pop()
    VAR addr2: Number := stack.pop()
    VAR addr1: Number := stack.pop()
    IF addr2 < addr1 THEN
        WHILE u > 0 DO
            storage[addr2] := storage[addr1]
            inc(addr1)
            inc(addr2)
            dec(u)
        END WHILE
    ELSIF addr1 < addr2 THEN
        addr1 := addr1 + u
        addr2 := addr2 + u
        WHILE u > 0 DO
            dec(addr1)
            dec(addr2)
            storage[addr2] := storage[addr1]
            dec(u)
        END WHILE
    END IF
END FUNCTION

FUNCTION run_CORE_NEGATE(INOUT ip: Number)
    LET n1: Number := signed32(stack.pop())
    stack.push(-n1)
END FUNCTION

FUNCTION run_CORE_NOT(INOUT ip: Number)
    LET n: Number := stack.pop()
    stack.push(IF n # 0 THEN 0 ELSE -1)
END FUNCTION

FUNCTION run_CORE_OR(INOUT ip: Number)
    LET x2: Number := stack.pop()
    LET x1: Number := stack.pop()
    stack.push(bitwise.or32(x1, x2))
END FUNCTION

FUNCTION run_CORE_OVER(INOUT ip: Number)
    stack.push(stack.peek(1))
END FUNCTION

FUNCTION run_CORE_PAD(INOUT ip: Number)
    stack.push(cell_pad)
END FUNCTION

FUNCTION run_CORE_R_FROM(INOUT ip: Number)
    stack.push(return[LAST].ip)
    return.resize(return.size()-1)
END FUNCTION

FUNCTION run_CORE_R_FETCH(INOUT ip: Number)
    stack.push(return[LAST].ip)
END FUNCTION

FUNCTION run_CORE_ROT(INOUT ip: Number)
    LET x3: Number := stack.pop()
    LET x2: Number := stack.pop()
    LET x1: Number := stack.pop()
    stack.push(x2)
    stack.push(x3)
    stack.push(x1)
END FUNCTION

FUNCTION run_CORE_RSHIFT(INOUT ip: Number)
    LET u: Number := stack.pop()
    LET x1: Number := stack.pop()
    stack.push(bitwise.shiftRight32(x1, u))
END FUNCTION

FUNCTION run_CORE_S_TO_D(INOUT ip: Number)
    LET n: Number := signed32(stack.pop())
    stack.push(n)
    stack.push(IF n < 0 THEN -1 ELSE 0)
END FUNCTION

FUNCTION run_CORE_SIGN(INOUT ip: Number)
    LET n: Number := signed32(stack.pop())
    IF n < 0 THEN
        inc(number_buffer_size)
        storage[cell_number_buffer + NUMBER_BUFFER_MAX - number_buffer_size] := ord("-")
    END IF
END FUNCTION

FUNCTION run_CORE_SM_REM(INOUT ip: Number)
    LET n1: Number := signed32(stack.pop())
    LET d1h: Number := signed32(stack.pop())
    LET d1l: Number := stack.pop()
    LET d1: Number := d1h * 0x100000000 + d1l
    stack.push(d1 MOD n1)
    stack.push(math.floor(d1 / n1))
END FUNCTION

FUNCTION run_CORE_SOURCE(INOUT ip: Number)
    stack.push(cell_input)
    stack.push(storage[cell_input_length])
END FUNCTION

FUNCTION run_CORE_SPACE(INOUT ip: Number)
    io.write(io.stdout(), " ")
END FUNCTION

FUNCTION run_CORE_SPACES(INOUT ip: Number)
    VAR n: Number := signed32(stack.pop())
    WHILE n > 0 DO
        io.write(io.stdout(), " ")
        dec(n)
    END WHILE
END FUNCTION

FUNCTION run_CORE_STATE(INOUT ip: Number)
    stack.push(cell_state)
END FUNCTION

FUNCTION run_CORE_SWAP(INOUT ip: Number)
    LET x2: Number := stack.pop()
    LET x1: Number := stack.pop()
    stack.push(x2)
    stack.push(x1)
END FUNCTION

FUNCTION run_CORE_TRUE(INOUT ip: Number)
    stack.push(-1)
END FUNCTION

FUNCTION run_CORE_TUCK(INOUT ip: Number)
    LET x2: Number := stack.pop()
    LET x1: Number := stack.pop()
    stack.push(x2)
    stack.push(x1)
    stack.push(x2)
END FUNCTION

FUNCTION run_CORE_TYPE(INOUT ip: Number)
    LET u: Number := stack.pop()
    LET addr: Number := stack.pop()
    LET s: String := get_string_len(addr, u)
    io.write(io.stdout(), s)
END FUNCTION

FUNCTION run_CORE_U_PRINT(INOUT ip: Number)
    LET n: Number := stack.pop()
    io.write(io.stdout(), "\(n) ")
END FUNCTION

FUNCTION run_CORE_U_LESS(INOUT ip: Number)
    LET u2: Number := stack.pop()
    LET u1: Number := stack.pop()
    stack.push(IF u1 < u2 THEN -1 ELSE 0)
END FUNCTION

FUNCTION run_CORE_UM_MOD(INOUT ip: Number)
    LET u1: Number := stack.pop()
    LET udh: Number := stack.pop()
    LET udl: Number := stack.pop()
    LET ud: Number := udh * 0x100000000 + udl
    stack.push(ud MOD u1)
    stack.push(math.floor(ud / u1))
END FUNCTION

FUNCTION run_CORE_UM_MUL(INOUT ip: Number)
    LET u2: Number := stack.pop()
    LET u1: Number := stack.pop()
    LET p: Number := u1 * u2
    stack.push(p)
    stack.push(math.floor(p / 0x100000000))
END FUNCTION

FUNCTION run_CORE_VARIABLE(INOUT ip: Number)
    LET s: String := next_word()
    words[s] := Word(code.size())
    code.append(INT_LITERAL)
    code.append(storage.size())
    code.append(0)
    storage.append(0)
END FUNCTION

FUNCTION run_CORE_WORD(INOUT ip: Number)
    LET char: Number := stack.pop()
    LET s: String := parse(chr(char))
    % TODO: use a real scratch area that is discarded
    stack.push(storage.size())
    storage.append(s.length())
    FOR i := 0 TO s.length()-1 DO
        storage.append(ord(s[i]))
    END FOR
    storage.append(ord(" "))
END FUNCTION

FUNCTION run_CORE_XOR(INOUT ip: Number)
    LET x2: Number := stack.pop()
    LET x1: Number := stack.pop()
    stack.push(bitwise.xor32(x1, x2))
END FUNCTION

FUNCTION run_TOOLS_QUESTION(INOUT ip: Number)
    LET addr: Number := stack.pop()
    print("\(storage[addr])")
END FUNCTION

FUNCTION run_TOOLS_PRINT_S(INOUT ip: Number)
    FOR i := 0 TO stack.size()-1 DO
        print("\(stack.peek(i))")
    END FOR
END FUNCTION

FUNCTION run_TOOLS_DUMP(INOUT ip: Number)
    LET u: Number := stack.pop()
    LET addr: Number := stack.pop()
    FOR i := 0 TO u-1 DO
        print("\(addr+i): \(storage[addr+i])")
    END FOR
END FUNCTION

FUNCTION run_TOOLS_SEE(INOUT ip: Number)
    LET s: String := next_word()
    IF s IN words THEN
        IF words[s].immediate THEN
            print("(immediate)")
        END IF
        VAR a: Number := words[s].xt
        IF a > 0 THEN
            LOOP
                print("\(a): \(code[a])")
                IF code[a] = 0 THEN
                    EXIT LOOP
                END IF
                inc(a)
            END LOOP
        ELSE
            print("built-in")
        END IF
    ELSE
        print("word not found")
    END IF
END FUNCTION

FUNCTION run_TOOLS_WORDS(INOUT ip: Number)
    LET a: Array<String> := words.keys()
    FOREACH w OF a DO
        print(w)
    END FOREACH
END FUNCTION

FUNCTION run_TOOLS_EXT_BYE(INOUT ip: Number)
    sys.exit(0)
END FUNCTION

FUNCTION run_INT_BRANCH(INOUT ip: Number)
    ip := code[ip+1]
END FUNCTION

FUNCTION run_INT_DO(INOUT ip: Number)
    LET u2: Number := stack.pop()
    LET u1: Number := stack.pop()
    return.append(ReturnEntry(ip+2, u1, u2, code[ip+1]))
    ip := ip + 2
END FUNCTION

FUNCTION run_INT_DOES(INOUT ip: Number)
    ASSERT code[LAST] = 0
    code[code.size()-3] := INT_BRANCH
    code[code.size()-2] := code[ip+1]
    ip := ip + 2
END FUNCTION

FUNCTION run_INT_EXIT(INOUT ip: Number)
    ip := return[LAST].ip
    return.resize(return.size()-1)
END FUNCTION

FUNCTION run_INT_LEAVE(INOUT ip: Number)
    ip := return[LAST].leave
    return.resize(return.size()-1)
END FUNCTION

FUNCTION run_INT_LITERAL(INOUT ip: Number)
    stack.push(code[ip+1])
    ip := ip + 2
END FUNCTION

FUNCTION run_INT_LOOP(INOUT ip: Number)
    LET last: Number := return.size() - 1
    return[last].index := (return[last].index + 1) MOD 0x100000000
    IF return[last].index = return[last].limit THEN
        return.resize(return.size()-1)
    ELSE
        ip := return[last].ip
    END IF
END FUNCTION

FUNCTION run_INT_PLUS_LOOP(INOUT ip: Number)
    LET n: Number := signed32(stack.pop())
    LET last: Number := return.size() - 1
    LET prev: Number := return[last].index
    LET limit: Number := return[last].limit
    return[last].index := (return[last].index + n) MOD 0x100000000
    % print("prev=\(prev) new=\(return[last].index) limit=\(limit) n=\(n)")
    IF (n > 0 AND (IF limit # 0 THEN prev < limit AND (return[last].index >= limit OR return[last].index < prev)
                                ELSE return[last].index < prev))
    OR (n < 0 AND (IF limit # 0 THEN prev >= limit AND (return[last].index < limit OR return[last].index > prev)
                                ELSE return[last].index > prev)) THEN
        return.resize(return.size()-1)
    ELSE
        ip := return[last].ip
    END IF
END FUNCTION

FUNCTION run_INT_POSTPONE(INOUT ip: Number)
    run(code[ip+1], FALSE)
    ip := ip + 2
END FUNCTION

FUNCTION run_INT_POSTPONE_IMM(INOUT ip: Number)
    run(code[ip+1], TRUE)
    ip := ip + 2
END FUNCTION

FUNCTION run_INT_PRINT_QUOTE(INOUT ip: Number)
    io.write(io.stdout(), get_string(code[ip+1]))
    ip := ip + 2
END FUNCTION

FUNCTION run_INT_Q_BRANCH(INOUT ip: Number)
    LET x: Number := stack.pop()
    IF x = 0 THEN
        ip := code[ip+1]
    ELSE
        ip := ip + 2
    END IF
END FUNCTION

FUNCTION run_INT_S_QUOTE(INOUT ip: Number)
    stack.push(code[ip+1]+1)
    stack.push(storage[code[ip+1]])
    ip := ip + 2
END FUNCTION

FUNCTION run_INT_UNLOOP(INOUT ip: Number)
    return.resize(return.size()-1)
END FUNCTION

FUNCTION run_instruction(instr: Number, INOUT ip: Number)
    CASE instr
        WHEN > 0 DO
            return.append(ReturnEntry(ip+1))
            ip := instr
        WHEN 0 DO
            ip := return[LAST].ip
            return.resize(return.size()-1)
        ELSE
            LET f: FUNCTION(INOUT ip: Number) := dispatch[-instr]
            f(ip)
            %print("Unknown instruction: \(instr)")
            %sys.exit(1)
    END CASE
END FUNCTION

FUNCTION run_compiled(start_ip: Number)
    VAR ip: Number := start_ip
    return.append(ReturnEntry(-1))
    WHILE ip > 0 DO
        % print("ip=\(ip) instr=\(code[ip]) size=\(stack.stack.size()) ret=\(return.size()))")
        LET prev_ip: Number := ip
        run_instruction(code[ip], ip)
        IF ip = prev_ip THEN
            inc(ip)
        END IF
    END WHILE
END FUNCTION

FUNCTION run(instr: Number, interpreting: Boolean)
    CASE instr
        WHEN CORE_TICK DO
            IF interpreting THEN
                LET s: String := next_word()
                stack.push(words[s].xt)
            ELSE
                LET s: String := next_word()
                code.append(INT_LITERAL)
                code.append(words[s].xt)
            END IF
        WHEN CORE_COMMENT DO
            LET comment: String := parse(")")
        WHEN CORE_PLUS_LOOP DO
            ASSERT NOT interpreting
            code.append(INT_PLUS_LOOP)
            code[compilation.pop()] := code.size()
        WHEN CORE_PRINT_QUOTE DO
            LET s: String := parse("\"")
            IF interpreting THEN
                io.write(io.stdout(), s)
            ELSE
                code.append(INT_PRINT_QUOTE)
                code.append(storage.size())
                storage.append(s.length())
                FOR i := 0 TO s.length()-1 DO
                    storage.append(ord(s[i]))
                END FOR
            END IF
        WHEN CORE_SEMICOLON DO
            ASSERT NOT interpreting
            code.append(0)
            words[defining] := Word(define_start)
            storage[cell_state] := 0
        WHEN CORE_BACKSLASH DO
            storage[cell_in] := storage[cell_input_length]
        WHEN CORE_BEGIN DO
            ASSERT NOT interpreting
            compilation.push(code.size())
        WHEN CORE_DO DO
            ASSERT NOT interpreting
            code.append(INT_DO)
            compilation.push(code.size())
            code.append(0)
        WHEN CORE_DOES DO
            ASSERT NOT interpreting
            code.append(INT_DOES)
            code.append(code.size()+2)
            code.append(0)
        WHEN CORE_ELSE DO
            ASSERT NOT interpreting
            code.append(INT_BRANCH)
            LET dest: Number := code.size()
            code.append(0)
            code[compilation.pop()] := code.size()
            compilation.push(dest)
        WHEN CORE_EXIT DO
            ASSERT NOT interpreting
            code.append(INT_EXIT)
        WHEN CORE_IF DO
            ASSERT NOT interpreting
            code.append(INT_Q_BRANCH)
            compilation.push(code.size())
            code.append(0)
        WHEN CORE_LEAVE DO
            ASSERT NOT interpreting
            code.append(INT_LEAVE)
        WHEN CORE_LITERAL DO
            ASSERT NOT interpreting
            LET x: Number := stack.pop()
            code.append(INT_LITERAL)
            code.append(x)
        WHEN CORE_LOOP DO
            ASSERT NOT interpreting
            code.append(INT_LOOP)
            code[compilation.pop()] := code.size()
        WHEN CORE_POSTPONE DO
            ASSERT NOT interpreting
            LET s: String := next_word()
            code.append(IF words[s].immediate THEN INT_POSTPONE_IMM ELSE INT_POSTPONE)
            code.append(words[s].xt)
        WHEN CORE_RECURSE DO
            ASSERT NOT interpreting
            code.append(define_start)
        WHEN CORE_REPEAT DO
            ASSERT NOT interpreting
            LET dest: Number := compilation.pop()
            LET orig: Number := compilation.pop()
            code.append(INT_BRANCH)
            code.append(dest)
            code[orig] := code.size()
        WHEN CORE_S_QUOTE DO
            ASSERT NOT interpreting
            LET s: String := parse("\"")
            code.append(INT_S_QUOTE)
            code.append(storage.size())
            storage.append(s.length())
            FOR i := 0 TO s.length()-1 DO
                storage.append(ord(s[i]))
            END FOR
        WHEN CORE_THEN DO
            ASSERT NOT interpreting
            code[compilation.pop()] := code.size()
        WHEN CORE_UNLOOP DO
            ASSERT NOT interpreting
            code.append(INT_UNLOOP)
        WHEN CORE_UNTIL DO
            ASSERT NOT interpreting
            code.append(INT_Q_BRANCH)
            code.append(compilation.pop())
        WHEN CORE_WHILE DO
            ASSERT NOT interpreting
            LET dest: Number := compilation.pop()
            code.append(INT_Q_BRANCH)
            compilation.push(code.size())
            code.append(0)
            compilation.push(dest)
        WHEN CORE_INTERPRET DO
            storage[cell_state] := 0
        WHEN CORE_IMM_TICK DO
            ASSERT NOT interpreting
            LET s: String := next_word()
            code.append(INT_LITERAL)
            code.append(words[s].xt)
        WHEN CORE_IMM_CHAR DO
            ASSERT NOT interpreting
            LET s: String := next_word()
            code.append(INT_LITERAL)
            code.append(ord(s[FIRST]))
        WHEN CORE_COMPILE DO
            storage[cell_state] := -1
        WHEN TOOLS_EXT_ELSE DO
            VAR depth: Number := 0
            LOOP
                LET s: String := next_word()
                IF s = "[IF]" THEN
                    inc(depth)
                ELSIF s = "[THEN]" THEN
                    IF depth = 0 THEN
                        EXIT LOOP
                    END IF
                    dec(depth)
                END IF
            END LOOP
        WHEN TOOLS_EXT_IF DO
            LET flag: Number := stack.pop()
            IF flag = 0 THEN
                VAR depth: Number := 0
                LOOP
                    LET s: String := next_word()
                    IF s = "[IF]" THEN
                        inc(depth)
                    ELSIF s = "[ELSE]" THEN
                        IF depth = 0 THEN
                            EXIT LOOP
                        END IF
                    ELSIF s = "[THEN]" THEN
                        IF depth = 0 THEN
                            EXIT LOOP
                        END IF
                        dec(depth)
                    END IF
                END LOOP
            END IF
        WHEN TOOLS_EXT_THEN DO
            % nothing
        ELSE
            IF interpreting THEN
                IF instr > 0 THEN
                    run_compiled(instr)
                ELSE
                    VAR ip: Number := 0
                    run_instruction(instr, ip)
                END IF
            ELSE
                code.append(instr)
            END IF
    END CASE
END FUNCTION

FUNCTION skip()
    WHILE storage[cell_in] < storage[cell_input_length] AND chr(storage[cell_input+storage[cell_in]]) <= " " DO
        inc(storage[cell_in])
    END WHILE
END FUNCTION

FUNCTION digit(char: String): Number
    IF "0" <= char <= "9" THEN
        RETURN ord(char) - ord("0")
    ELSIF "A" <= char <= "Z" THEN
        RETURN ord(char) - ord("A") + 10
    ELSE
        ASSERT FALSE % invalid char
    END IF
    RETURN 0
END FUNCTION

FUNCTION convert(word: String, base: Number): Number
    VAR n: Number := 0
    LET negative: Boolean := word[0] = "-"
    VAR i: Number := 0
    IF negative THEN
        inc(i)
    END IF
    WHILE i < word.length() DO
        n := n * base + digit(word[i])
        inc(i)
    END WHILE
    IF negative THEN
        n := -n
    END IF
    RETURN n
END FUNCTION

FUNCTION execute(word: String)
    LET interpreting: Boolean := storage[cell_state] = 0
    IF word IN words THEN
        run(words[word].xt, interpreting OR words[word].immediate)
    ELSE
        VAR n: Number
        VAR m: regex.Match
        LET base: Number := storage[cell_base]
        IF regex.search("^-?[\(Digits[0 TO base-1])]+$", word, m) THEN
            n := convert(word, base)
        ELSIF regex.search(@"^#-?[0-9]+$", word, m) THEN
            n := convert(word[1 TO LAST], 10)
        ELSIF regex.search(@"^\$-?[0-9A-F]+$", word, m) THEN
            n := convert(word[1 TO LAST], 0x10)
        ELSIF regex.search(@"^%-?[01]+$", word, m) THEN
            n := convert(word[1 TO LAST], 0b10)
        ELSIF regex.search(@"'.'?$", word, m) THEN
            n := ord(word[1])
        ELSE
            print("Unknown word: \(word)")
            sys.exit(1)
        END IF
        IF interpreting THEN
            stack.push(n)
        ELSE
            code.append(INT_LITERAL)
            code.append(n)
        END IF
    END IF
END FUNCTION

VAR current_file: io.File

FUNCTION refill(): Boolean
    IF cell_input # cell_normal_input THEN
        cell_input := cell_normal_input
        cell_input_length := cell_normal_input_length
        cell_in := cell_normal_in
        RETURN FALSE
    END IF
    VAR s: String
    IF NOT io.readLine(current_file, s) THEN
        RETURN FALSE
    END IF
    FOR i := 0 TO s.length()-1 DO
        storage[cell_input+i] := ord(s[i])
    END FOR
    storage[cell_input_length] := s.length()
    storage[cell_in] := 0
    RETURN TRUE
END FUNCTION

FUNCTION parse(delimiter: String): String
    VAR r: String
    WHILE storage[cell_in] < storage[cell_input_length] DO
        LET c: String := chr(storage[cell_input+storage[cell_in]])
        inc(storage[cell_in])
        IF c = delimiter OR (delimiter = " " AND c <= delimiter) THEN
            EXIT WHILE
        END IF
        r.append(c)
    END WHILE
    RETURN r
END FUNCTION

FUNCTION next_word(): String
    LOOP
        skip()
        IF storage[cell_in] >= storage[cell_input_length] THEN
            IF NOT refill() THEN
                RETURN ""
            END IF
            NEXT LOOP
        END IF
        RETURN string.upper(parse(" "))
    END LOOP
END FUNCTION

FUNCTION interpret()
    LOOP
        LET word: String := next_word()
        IF word = "" THEN
            EXIT LOOP
        END IF
        execute(word)
    END LOOP
END FUNCTION

LET files: Array<String> := sys.argv()[1 TO LAST]
FOREACH fn OF files DO
    current_file := io.open(fn, io.Mode.read)
    interpret()
    io.close(current_file)
END FOREACH

current_file := io.stdin()
interpret()
