%|
 ****************************************************************************
 *
 *                   "DHRYSTONE" Benchmark Program
 *                   -----------------------------
 *
 *  Version:    C, Version 2.1
 *
 *  File:       dhry.h (part 1 of 3)
 *
 *  Date:       May 25, 1988
 *
 *  Author:     Reinhold P. Weicker
 *                      Siemens AG, AUT E 51
 *                      Postfach 3220
 *                      8520 Erlangen
 *                      Germany (West)
 *                              Phone:  [+49]-9131-7-20330
 *                                      (8-17 Central European Time)
 *                              Usenet: ..!mcsun!unido!estevax!weicker
 *
 *              Original Version (in Ada) published in
 *              "Communications of the ACM" vol. 27., no. 10 (Oct. 1984),
 *              pp. 1013 - 1030, together with the statistics
 *              on which the distribution of statements etc. is based.
 *
 *              In this C version, the following C library functions are used:
 *              - strcpy, strcmp (inside the measurement loop)
 *              - printf, scanf (outside the measurement loop)
 *              In addition, Berkeley UNIX system calls "times ()" or "time ()"
 *              are used for execution time measurement. For measurements
 *              on other systems, these calls have to be changed.
 *
 *  Collection of Results:
 *              Reinhold Weicker (address see above) and
 *
 *              Rick Richardson
 *              PC Research. Inc.
 *              94 Apple Orchard Drive
 *              Tinton Falls, NJ 07724
 *                      Phone:  (201) 389-8963 (9-17 EST)
 *                      Usenet: ...!uunet!pcrat!rick
 *
 *      Please send results to Rick Richardson and/or Reinhold Weicker.
 *      Complete information should be given on hardware and software used.
 *      Hardware information includes: Machine type, CPU, type and size
 *      of caches; for microprocessors: clock frequency, memory speed
 *      (number of wait states).
 *      Software information includes: Compiler (and runtime library)
 *      manufacturer and version, compilation switches, OS version.
 *      The Operating System version may give an indication about the
 *      compiler; Dhrystone itself performs no OS calls in the measurement loop.
 *
 *      The complete output generated by the program should be mailed
 *      such that at least some checks for correctness can be made.
 *
 ***************************************************************************
 *
 *  History:    This version C/2.1 has been made for two reasons:
 *
 *              1) There is an obvious need for a common C version of
 *              Dhrystone, since C is at present the most popular system
 *              programming language for the class of processors
 *              (microcomputers, minicomputers) where Dhrystone is used most.
 *              There should be, as far as possible, only one C version of
 *              Dhrystone such that results can be compared without
 *              restrictions. In the past, the C versions distributed
 *              by Rick Richardson (Version 1.1) and by Reinhold Weicker
 *              had small (though not significant) differences.
 *
 *              2) As far as it is possible without changes to the Dhrystone
 *              statistics, optimizing compilers should be prevented from
 *              removing significant statements.
 *
 *              This C version has been developed in cooperation with
 *              Rick Richardson (Tinton Falls, NJ), it incorporates many
 *              ideas from the "Version 1.1" distributed previously by
 *              him over the UNIX network Usenet.
 *              I also thank Chaim Benedelac (National Semiconductor),
 *              David Ditzel (SUN), Earl Killian and John Mashey (MIPS),
 *              Alan Smith and Rafael Saavedra-Barrera (UC at Berkeley)
 *              for their help with comments on earlier versions of the
 *              benchmark.
 *
 *  Changes:    In the initialization part, this version follows mostly
 *              Rick Richardson's version distributed via Usenet, not the
 *              version distributed earlier via floppy disk by Reinhold Weicker.
 *              As a concession to older compilers, names have been made
 *              unique within the first 8 characters.
 *              Inside the measurement loop, this version follows the
 *              version previously distributed by Reinhold Weicker.
 *
 *              At several places in the benchmark, code has been added,
 *              but within the measurement loop only in branches that
 *              are not executed. The intention is that optimizing compilers
 *              should be prevented from moving code out of the measurement
 *              loop, or from removing code altogether. Since the statements
 *              that are executed within the measurement loop have NOT been
 *              changed, the numbers defining the "Dhrystone distribution"
 *              (distribution of statements, operand types and locality)
 *              still hold. Except for sophisticated optimizing compilers,
 *              execution times for this version should be the same as
 *              for previous versions.
 *
 *              Since it has proven difficult to subtract the time for the
 *              measurement loop overhead in a correct way, the loop check
 *              has been made a part of the benchmark. This does have
 *              an impact - though a very minor one - on the distribution
 *              statistics which have been updated for this version.
 *
 *              All changes within the measurement loop are described
 *              and discussed in the companion paper "Rationale for
 *              Dhrystone version 2".
 *
 *              Because of the self-imposed limitation that the order and
 *              distribution of the executed statements should not be
 *              changed, there are still cases where optimizing compilers
 *              may not generate code for some statements. To a certain
 *              degree, this is unavoidable for small synthetic benchmarks.
 *              Users of the benchmark are advised to check code listings
 *              whether code is generated for all statements of Dhrystone.
 *
 *              Version 2.1 is identical to version 2.0 distributed via
 *              the UNIX network Usenet in March 1988 except that it corrects
 *              some minor deficiencies that were found by users of version 2.0.
 *              The only change within the measurement loop is that a
 *              non-executed "else" part was added to the "if" statement in
 *              Func_3, and a non-executed "else" part removed from Proc_3.
 *
 ***************************************************************************
 *
 * Defines:     The following "Defines" are possible:
 *              -DREG=register          (default: Not defined)
 *                      As an approximation to what an average C programmer
 *                      might do, the "register" storage class is applied
 *                      (if enabled by -DREG=register)
 *                      - for local variables, if they are used (dynamically)
 *                        five or more times
 *                      - for parameters if they are used (dynamically)
 *                        six or more times
 *                      Note that an optimal "register" strategy is
 *                      compiler-dependent, and that "register" declarations
 *                      do not necessarily lead to faster execution.
 *              -DNOSTRUCTASSIGN        (default: Not defined)
 *                      Define if the C compiler does not support
 *                      assignment of structures.
 *              -DNOENUMS               (default: Not defined)
 *                      Define if the C compiler does not support
 *                      enumeration types.
 *              -DTIMES                 (default)
 *              -DTIME
 *                      The "times" function of UNIX (returning process times)
 *                      or the "time" function (returning wallclock time)
 *                      is used for measurement.
 *                      For single user machines, "time ()" is adequate. For
 *                      multi-user machines where you cannot get single-user
 *                      access, use the "times ()" function. If you have
 *                      neither, use a stopwatch in the dead of night.
 *                      "printf"s are provided marking the points "Start Timer"
 *                      and "Stop Timer". DO NOT use the UNIX "time(1)"
 *                      command, as this will measure the total time to
 *                      run this program, which will (erroneously) include
 *                      the time to allocate storage (malloc) and to perform
 *                      the initialization.
 *              -DHZ=nnn
 *                      In Berkeley UNIX, the function "times" returns process
 *                      time in 1/HZ seconds, with HZ = 60 for most systems.
 *                      CHECK YOUR SYSTEM DESCRIPTION BEFORE YOU JUST APPLY
 *                      A VALUE.
 *
 ***************************************************************************
 *
 *  Compilation model and measurement (IMPORTANT):
 *
 *  This C version of Dhrystone consists of three files:
 *  - dhry.h (this file, containing global definitions and comments)
 *  - dhry_1.c (containing the code corresponding to Ada package Pack_1)
 *  - dhry_2.c (containing the code corresponding to Ada package Pack_2)
 *
 *  The following "ground rules" apply for measurements:
 *  - Separate compilation
 *  - No procedure merging
 *  - Otherwise, compiler optimizations are allowed but should be indicated
 *  - Default results are those without register declarations
 *  See the companion paper "Rationale for Dhrystone Version 2" for a more
 *  detailed discussion of these ground rules.
 *
 *  For 16-Bit processors (e.g. 80186, 80286), times for all compilation
 *  models ("small", "medium", "large" etc.) should be given if possible,
 *  together with a definition of these models for the compiler system used.
 *
 **************************************************************************
 *
 *  Dhrystone (C version) statistics:
 *
 *  [Comment from the first distribution, updated for version 2.
 *   Note that because of language differences, the numbers are slightly
 *   different from the Ada version.]
 *
 *  The following program contains statements of a high level programming
 *  language (here: C) in a distribution considered representative:
 *
 *    assignments                  52 (51.0 %)
 *    control statements           33 (32.4 %)
 *    procedure, function calls    17 (16.7 %)
 *
 *  103 statements are dynamically executed. The program is balanced with
 *  respect to the three aspects:
 *
 *    - statement type
 *    - operand type
 *    - operand locality
 *         operand global, local, parameter, or constant.
 *
 *  The combination of these three aspects is balanced only approximately.
 *
 *  1. Statement Type:
 *  -----------------             number
 *
 *     V1 = V2                     9
 *       (incl. V1 = F(..)
 *     V = Constant               12
 *     Assignment,                 7
 *       with array element
 *     Assignment,                 6
 *       with record component
 *                                --
 *                                34       34
 *
 *     X = Y +|-|"&&"|"|" Z        5
 *     X = Y +|-|"==" Constant     6
 *     X = X +|- 1                 3
 *     X = Y *|/ Z                 2
 *     X = Expression,             1
 *           two operators
 *     X = Expression,             1
 *           three operators
 *                                --
 *                                18       18
 *
 *     if ....                    14
 *       with "else"      7
 *       without "else"   7
 *           executed        3
 *           not executed    4
 *     for ...                     7  |  counted every time
 *     while ...                   4  |  the loop condition
 *     do ... while                1  |  is evaluated
 *     switch ...                  1
 *     break                       1
 *     declaration with            1
 *       initialization
 *                                --
 *                                34       34
 *
 *     P (...)  procedure call    11
 *       user procedure      10
 *       library procedure    1
 *     X = F (...)
 *             function  call      6
 *       user function        5
 *       library function     1
 *                                --
 *                                17       17
 *                                        ---
 *                                        103
 *
 *    The average number of parameters in procedure or function calls
 *    is 1.82 (not counting the function values as implicit parameters).
 *
 *
 *  2. Operators
 *  ------------
 *                          number    approximate
 *                                    percentage
 *
 *    Arithmetic             32          50.8
 *
 *       +                     21          33.3
 *       -                      7          11.1
 *       *                      3           4.8
 *       / (int div)            1           1.6
 *
 *    Comparison             27           42.8
 *
 *       ==                     9           14.3
 *       /=                     4            6.3
 *       >                      1            1.6
 *       <                      3            4.8
 *       >=                     1            1.6
 *       <=                     9           14.3
 *
 *    Logic                   4            6.3
 *
 *       && (AND-THEN)          1            1.6
 *       |  (OR)                1            1.6
 *       !  (NOT)               2            3.2
 *
 *                           --          -----
 *                           63          100.1
 *
 *
 *  3. Operand Type (counted once per operand reference):
 *  ---------------
 *                          number    approximate
 *                                    percentage
 *
 *     Integer               175        72.3 %
 *     Character              45        18.6 %
 *     Pointer                12         5.0 %
 *     String30                6         2.5 %
 *     Array                   2         0.8 %
 *     Record                  2         0.8 %
 *                           ---       -------
 *                           242       100.0 %
 *
 *  When there is an access path leading to the final operand (e.g. a record
 *  component), only the final data type on the access path is counted.
 *
 *
 *  4. Operand Locality:
 *  -------------------
 *                                number    approximate
 *                                          percentage
 *
 *     local variable              114        47.1 %
 *     global variable              22         9.1 %
 *     parameter                    45        18.6 %
 *        value                        23         9.5 %
 *        reference                    22         9.1 %
 *     function result               6         2.5 %
 *     constant                     55        22.7 %
 *                                 ---       -------
 *                                 242       100.0 %
 *
 *
 *  The program does not compute anything meaningful, but it is syntactically
 *  and semantically correct. All variables have a value assigned to them
 *  before they are used as a source operand.
 *
 *  There has been no explicit effort to account for the effects of a
 *  cache, or to balance the use of long or short displacements for code or
 *  data.
 *
 ***************************************************************************
 |%

IMPORT math

TYPE Enumeration := ENUM
    Ident_1
    Ident_2
    Ident_3
    Ident_4
    Ident_5
END ENUM

% General definitions:

TYPE One_Thirty     := Number
TYPE One_Fifty      := Number
TYPE Capital_Letter := String
TYPE Str_30         := String
TYPE Arr_1_Dim      := Array<Number>
TYPE Arr_2_Dim      := Array<Array<Number>>

TYPE Record := RECORD
    Ptr_Comp: POINTER TO Record
    Discr: Enumeration

    Enum_Comp: Enumeration
    Int_Comp: Number
    Str_Comp: String

    E_Comp_2: Enumeration
    Str_2_Comp: String

    Ch_1_Comp: String
    Ch_2_Comp: String
END RECORD

% Global Variables:

VAR Ptr_Glob, Next_Ptr_Glob: POINTER TO Record
VAR Int_Glob: Number
VAR Bool_Glob: Boolean
VAR Ch_1_Glob, Ch_2_Glob: String
VAR Arr_1_Glob: Array<Number>
VAR Arr_2_Glob: Array<Array<Number>>

% variables for time measurement:

IMPORT time

CONST Mic_secs_Per_Second: Number := 1000000.0

CONST Too_Small_Time: Number := 2

VAR Begin_Time, End_Time, User_Time: Number
VAR Microseconds, Dhrystones_Per_Second: Number

% end of variables for time measurement

FUNCTION Proc_1 (Ptr_Val_Par: POINTER TO Record)
    % executed once

  VAR Next_Record: POINTER TO Record
  IF VALID Ptr_Val_Par AS pvp THEN
      Next_Record := pvp->Ptr_Comp
      IF VALID Next_Record AS nr THEN
                                        % == Ptr_Glob_Next
          % Local variable, initialized with Ptr_Val_Par->Ptr_Comp,
          % corresponds to "rename" in Ada, "with" in Pascal

          IF VALID Ptr_Glob AS pg THEN
            value_copy(nr, pg)
          END IF
          pvp->Int_Comp := 5
          nr->Int_Comp := pvp->Int_Comp
          nr->Ptr_Comp := pvp->Ptr_Comp
          Proc_3 (nr->Ptr_Comp)
            % Ptr_Val_Par->Ptr_Comp->Ptr_Comp == Ptr_Glob->Ptr_Comp
          IF nr->Discr = Enumeration.Ident_1 THEN
            % then, executed
            nr->Int_Comp := 6
            Proc_6 (pvp->Enum_Comp,
                    nr->Enum_Comp)
            IF VALID Ptr_Glob AS pg THEN
                nr->Ptr_Comp := pg->Ptr_Comp
            END IF
            Proc_7 (nr->Int_Comp, 10,
                    nr->Int_Comp)
          ELSE
            value_copy(pvp, nr)
          END IF
      END IF
  END IF
END FUNCTION % Proc_1


FUNCTION Proc_2 (INOUT Int_Par_Ref: Number)
    % executed once
    % *Int_Par_Ref == 1, becomes 4

  VAR Int_Loc: One_Fifty
  VAR Enum_Loc: Enumeration

  Int_Loc := Int_Par_Ref + 10
  REPEAT % executed once
    IF Ch_1_Glob = "A" THEN
      % then, executed
      Int_Loc := Int_Loc - 1
      Int_Par_Ref := Int_Loc - Int_Glob
      Enum_Loc := Enumeration.Ident_1
    END IF
  UNTIL Enum_Loc = Enumeration.Ident_1 % true
END FUNCTION % Proc_2


FUNCTION Proc_3 (INOUT Ptr_Ref_Par: POINTER TO Record)
    % executed once
    % Ptr_Ref_Par becomes Ptr_Glob

  IF VALID Ptr_Glob AS pg THEN
    % then, executed
    Ptr_Ref_Par := pg->Ptr_Comp
    Proc_7 (10, Int_Glob, pg->Int_Comp)
  END IF
END FUNCTION % Proc_3


FUNCTION Proc_4 () % without parameters
    % executed once

  VAR Bool_Loc: Boolean

  Bool_Loc := Ch_1_Glob = "A"
  Bool_Glob := Bool_Loc OR Bool_Glob
  Ch_2_Glob := "B"
END FUNCTION % Proc_4


FUNCTION Proc_5 () % without parameters
    % executed once

  Ch_1_Glob := "A"
  Bool_Glob := FALSE
END FUNCTION % Proc_5


FUNCTION Func_3 (IN Enum_Par_Val: Enumeration): Boolean
    % executed once
    % Enum_Par_Val == Ident_3

  VAR Enum_Loc: Enumeration

  Enum_Loc := Enum_Par_Val
  IF Enum_Loc = Enumeration.Ident_3 THEN
    % then, executed
    RETURN TRUE
  ELSE % not executed
    RETURN FALSE
  END IF
END FUNCTION % Func_3


FUNCTION Proc_6 (IN Enum_Val_Par: Enumeration, OUT Enum_Ref_Par: Enumeration)
    % executed once
    % Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2

  Enum_Ref_Par := Enum_Val_Par
  IF NOT Func_3 (Enum_Val_Par) THEN
    % then, not executed
    Enum_Ref_Par := Enumeration.Ident_4
  END IF
  CASE Enum_Val_Par
    WHEN Enumeration.Ident_1 DO
      Enum_Ref_Par := Enumeration.Ident_1
    WHEN Enumeration.Ident_2 DO
      IF Int_Glob > 100 THEN
        % then
        Enum_Ref_Par := Enumeration.Ident_1
      ELSE
        Enum_Ref_Par := Enumeration.Ident_4
      END IF
    WHEN Enumeration.Ident_3 DO % executed
      Enum_Ref_Par := Enumeration.Ident_2
    WHEN Enumeration.Ident_4 DO
    WHEN Enumeration.Ident_5 DO
      Enum_Ref_Par := Enumeration.Ident_3
  END CASE
END FUNCTION % Proc_6


FUNCTION Proc_7 (IN Int_1_Par_Val: One_Fifty, IN Int_2_Par_Val: One_Fifty, OUT Int_Par_Ref: One_Fifty)
    % executed three times
    % first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,
    %                  Int_Par_Ref becomes 7
    % second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5,
    %                  Int_Par_Ref becomes 17
    % third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10,
    %                  Int_Par_Ref becomes 18

  VAR Int_Loc: One_Fifty

  Int_Loc := Int_1_Par_Val + 2
  Int_Par_Ref := Int_2_Par_Val + Int_Loc
END FUNCTION % Proc_7


FUNCTION Proc_8 (INOUT Arr_1_Par_Ref: Arr_1_Dim, INOUT Arr_2_Par_Ref: Arr_2_Dim, IN Int_1_Par_Val: Number, IN Int_2_Par_Val: Number)
    % executed once
    % Int_Par_Val_1 == 3
    % Int_Par_Val_2 == 7

  VAR Int_Index: One_Fifty
  VAR Int_Loc: One_Fifty

  Int_Loc := Int_1_Par_Val + 5
  Arr_1_Par_Ref [Int_Loc] := Int_2_Par_Val
  Arr_1_Par_Ref [Int_Loc+1] := Arr_1_Par_Ref [Int_Loc]
  Arr_1_Par_Ref [Int_Loc+30] := Int_Loc
  Int_Index := Int_Loc
  WHILE Int_Index <= Int_Loc+1 DO
    Arr_2_Par_Ref [Int_Loc] [Int_Index] := Int_Loc
    Int_Index := Int_Index + 1
  END WHILE
  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] := Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] + 1
  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] := Arr_1_Par_Ref [Int_Loc]
  Int_Glob := 5
END FUNCTION % Proc_8


FUNCTION Func_1 (IN Ch_1_Par_Val: String, IN Ch_2_Par_Val: String): Enumeration
    % executed three times
    % first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'
    % second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'
    % third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'

  VAR Ch_1_Loc: Capital_Letter
  VAR Ch_2_Loc: Capital_Letter

  Ch_1_Loc := Ch_1_Par_Val
  Ch_2_Loc := Ch_1_Loc
  IF Ch_2_Loc # Ch_2_Par_Val THEN
    % then, executed
    RETURN Enumeration.Ident_1
  ELSE  % not executed
    Ch_1_Glob := Ch_1_Loc
    RETURN Enumeration.Ident_2
  END IF
END FUNCTION % Func_1


FUNCTION Func_2 (IN Str_1_Par_Ref: String, IN Str_2_Par_Ref: String): Boolean
    % executed once
    % Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING"
    % Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING"

  VAR Int_Loc: One_Thirty
  VAR Ch_Loc: Capital_Letter

  Int_Loc := 2
  WHILE Int_Loc <= 2 DO % loop body executed once
    IF Func_1 (Str_1_Par_Ref[Int_Loc],
               Str_2_Par_Ref[Int_Loc+1]) = Enumeration.Ident_1 THEN
      % then, executed
      Ch_Loc := "A"
      Int_Loc := Int_Loc + 1
    END IF
  END WHILE
  IF Ch_Loc >= "W" AND Ch_Loc < "Z" THEN
    % then, not executed
    Int_Loc := 7
  END IF
  IF Ch_Loc = "R" THEN
    % then, not executed
    RETURN TRUE
  ELSE % executed
    IF Str_1_Par_Ref > Str_2_Par_Ref THEN
      % then, not executed
      Int_Loc := Int_Loc + 7
      Int_Glob := Int_Loc
      RETURN TRUE
    ELSE % executed
      RETURN FALSE
    END IF
  END IF
END FUNCTION % Func_2


FUNCTION main()

  % main program, corresponds to procedures
  % Main and Proc_0 in the Ada version

  VAR Int_1_Loc: One_Fifty
  VAR Int_2_Loc: One_Fifty
  VAR Int_3_Loc: One_Fifty
  VAR Ch_Index: String
  VAR Enum_Loc: Enumeration
  VAR Str_1_Loc: Str_30
  VAR Str_2_Loc: Str_30
  VAR Run_Index: Number
  VAR Number_Of_Runs: Number

  % Initializations

  Next_Ptr_Glob := NEW Record
  Ptr_Glob := NEW Record

  IF VALID Ptr_Glob AS pg THEN
      pg->Ptr_Comp                    := Next_Ptr_Glob
      pg->Discr                       := Enumeration.Ident_1
      pg->Enum_Comp                   := Enumeration.Ident_3
      pg->Int_Comp                    := 40
      pg->Str_Comp                    := "DHRYSTONE PROGRAM, SOME STRING"
  END IF
  Str_1_Loc := "DHRYSTONE PROGRAM, 1'ST STRING"

  Arr_2_Glob [28] := []     % Make sure the array is big enough.
  Arr_2_Glob [8][7] := 10

  print ("")
  print ("Dhrystone Benchmark, Version 2.1 (Language: Neon)")
  print ("")
  print ("Please give the number of runs through the benchmark: ")
  Number_Of_Runs := 10000 % TODO to_number(input())
  print ("")

  print ("Execution starts, " & str(Number_Of_Runs) & " runs through Dhrystone")

  %%%%%%%%%%%%%%%%%
  %% Start timer %%
  %%%%%%%%%%%%%%%%%

  Begin_Time := time.now ()

  Run_Index := 1
  WHILE Run_Index <= Number_Of_Runs DO

    Proc_5()
    Proc_4()
      % Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true
    Int_1_Loc := 2
    Int_2_Loc := 3
    Str_2_Loc := "DHRYSTONE PROGRAM, 2'ND STRING"
    Enum_Loc := Enumeration.Ident_2
    Bool_Glob := NOT Func_2 (Str_1_Loc, Str_2_Loc)
      % Bool_Glob == 1
    WHILE Int_1_Loc < Int_2_Loc DO  % loop body executed once
      Int_3_Loc := 5 * Int_1_Loc - Int_2_Loc
        % Int_3_Loc == 7
      Proc_7 (Int_1_Loc, Int_2_Loc, Int_3_Loc)
        % Int_3_Loc == 7
      Int_1_Loc := Int_1_Loc + 1
    END WHILE
      % Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7
    Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc)
      % Int_Glob == 5
    Proc_1 (Ptr_Glob)
    Ch_Index := "A"
    WHILE Ch_Index <= Ch_2_Glob DO
                             % loop body executed twice
      IF Enum_Loc = Func_1 (Ch_Index, "C") THEN
          % then, not executed
        Proc_6 (Enumeration.Ident_1, Enum_Loc)
        Str_2_Loc := "DHRYSTONE PROGRAM, 3'RD STRING"
        Int_2_Loc := Run_Index
        Int_Glob := Run_Index
      END IF
      Ch_Index := chr(ord(Ch_Index) + 1)
    END WHILE
      % Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7
    Int_2_Loc := Int_2_Loc * Int_1_Loc
    Int_1_Loc := math.floor(Int_2_Loc / Int_3_Loc)
    Int_2_Loc := 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc
      % Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7
    Proc_2 (Int_1_Loc)
      % Int_1_Loc == 5

    Run_Index := Run_Index + 1
  END WHILE % loop "for Run_Index"

  %%%%%%%%%%%%%%%%
  %% Stop timer %%
  %%%%%%%%%%%%%%%%

  End_Time := time.now ()

  print ("Execution ends")
  print ("")
  print ("Final values of the variables used in the benchmark:")
  print ("")
  print ("Int_Glob:            " & str(Int_Glob))
  print ("        should be:   " & str(5))
  print ("Bool_Glob:           " & strb(Bool_Glob))
  print ("        should be:   " & strb(TRUE))
  print ("Ch_1_Glob:           " & Ch_1_Glob)
  print ("        should be:   " & "A")
  print ("Ch_2_Glob:           " & Ch_2_Glob)
  print ("        should be:   " & "B")
  print ("Arr_1_Glob[8]:       " & str(Arr_1_Glob[8]))
  print ("        should be:   " & str(7))
  print ("Arr_2_Glob[8][7]:    " & str(Arr_2_Glob[8][7]))
  print ("        should be:   Number_Of_Runs + 10")
  IF VALID Ptr_Glob AS pg THEN
    print ("Ptr_Glob->")
    print ("  Ptr_Comp:          ") % & pg->Ptr_Comp)
    print ("        should be:   (implementation-dependent)")
    print ("  Discr:             " & pg->Discr.to_string())
    print ("        should be:   " & "Ident_1")
    print ("  Enum_Comp:         " & pg->Enum_Comp.to_string())
    print ("        should be:   " & "Ident_3")
    print ("  Int_Comp:          " & str(pg->Int_Comp))
    print ("        should be:   " & str(17))
    print ("  Str_Comp:          " & pg->Str_Comp)
    print ("        should be:   DHRYSTONE PROGRAM, SOME STRING")
  END IF
  IF VALID Next_Ptr_Glob AS npg THEN
    print ("Next_Ptr_Glob->")
    print ("  Ptr_Comp:          ") % & npg->Ptr_Comp)
    print ("        should be:   (implementation-dependent), same as above")
    print ("  Discr:             " & npg->Discr.to_string())
    print ("        should be:   " & "Ident_1")
    print ("  Enum_Comp:         " & npg->Enum_Comp.to_string())
    print ("        should be:   " & "Ident_2")
    print ("  Int_Comp:          " & str(npg->Int_Comp))
    print ("        should be:   " & str(18))
    print ("  Str_Comp:          " & npg->Str_Comp)
    print ("        should be:   DHRYSTONE PROGRAM, SOME STRING")
  END IF
  print ("Int_1_Loc:           " & str(Int_1_Loc))
  print ("        should be:   " & str(5))
  print ("Int_2_Loc:           " & str(Int_2_Loc))
  print ("        should be:   " & str(13))
  print ("Int_3_Loc:           " & str(Int_3_Loc))
  print ("        should be:   " & str(7))
  print ("Enum_Loc:            " & Enum_Loc.to_string())
  print ("        should be:   " & "Ident_2")
  print ("Str_1_Loc:           " &  Str_1_Loc)
  print ("        should be:   DHRYSTONE PROGRAM, 1'ST STRING")
  print ("Str_2_Loc:           " & Str_2_Loc)
  print ("        should be:   DHRYSTONE PROGRAM, 2'ND STRING")
  print ("")

  User_Time := End_Time - Begin_Time

  IF User_Time < Too_Small_Time THEN
    print ("Measured time too small to obtain meaningful results")
    print ("Please increase number of runs")
    print ("")
  ELSE
    Microseconds := User_Time * Mic_secs_Per_Second / Number_Of_Runs
    Dhrystones_Per_Second := Number_Of_Runs / User_Time
    print ("Microseconds for one run through Dhrystone: " & str(Microseconds))
    print ("Dhrystones per Second:                      " & str(Dhrystones_Per_Second))
    print ("")
  END IF

END FUNCTION

main()

%|

|%
