IMPORT base
IMPORT binary
IMPORT console
IMPORT file
IMPORT io
IMPORT math
IMPORT os
IMPORT random
IMPORT string
IMPORT sys
IMPORT textio
IMPORT time

EXCEPTION SyntaxException

CONSTANT Limit_EnvironmentName := 99
CONSTANT Limit_Name := 99
CONSTANT Limit_Literal := 99
CONSTANT Limit_Digits := 99
CONSTANT Limit_ExponentDigits := 99
CONSTANT Limit_String := 99

LET ErrorText := {
    "0.1"  : "Error <value> running <source>, line <linenumber>:"
    "0.2"  : "Error <value> in interactive trace:"
    "0.3"  : "Interactive trace.  \"Trace Off\" to end debug.  ENTER to continue."
    "2"    : "Failure during finalization"
    "2.1"  : "Failure during finalization: <description>"
    "3"    : "Failure during initialization"
    "3.1"  : "Failure during initialization: <description>"
    "4"    : "Program interrupted"
    "4.1"  : "Program interrupted with HALT condition: <description>"
    "5"    : "System resources exhausted"
    "5.1"  : "System resources exhausted: <description>"
    "6"    : "Unmatched \"/*\" or quote"
    "6.1"  : "Unmatched comment delimiter (\"/*\")"
    "6.2"  : "Unmatched single quote (')"
    "6.3"  : "Unmatched double quote (\")"
    "7"    : "WHEN or OTHERWISE expected"
    "7.1"  : "SELECT on line <linenumber> requires WHEN; found \"<token>\""
    "7.2"  : "SELECT on line <linenumber> requires WHEN, OTHERWISE, or END; found \"<token>\""
    "7.3"  : "All WHEN expressions of SELECT on line <linenumber> are false; OTHERWISE expected"
    "8"    : "Unexpected THEN or ELSE"
    "8.1"  : "THEN has no corresponding IF or WHEN clause"
    "8.2"  : "ELSE has no corresponding THEN clause"
    "9"    : "Unexpected WHEN or OTHERWISE"
    "9.1"  : "WHEN has no corresponding SELECT"
    "9.2"  : "OTHERWISE has no corresponding SELECT"
    "10"   : "Unexpected or unmatched END"
    "10.1" : "END has no corresponding DO or SELECT"
    "10.2" : "END corresponding to DO on line <linenumber> must have a symbol following that matches the control variable (or no symbol); found \"<token>\""
    "10.3" : "END corresponding to DO on line <linenumber> must not have a symbol following it because there is no control variable; found \"<token>\""
    "10.4" : "END corresponding to SELECT on line <linenumber> must not have a symbol following; found \"<token>\""
    "10.5" : "END must not immediately follow THEN"
    "10.6" : "END must not immediately follow ELSE"
    "13"   : "Invalid character in program"
    "13.1" : "Invalid character in program \"<char>\" ('<hex-encoding>'X)"
    "14"   : "Incomplete DO/SELECT/IF"
    "14.1" : "DO instruction requires a matching END"
    "14.2" : "SELECT instruction requires a matching END"
    "14.3" : "THEN requires a following instruction"
    "14.4" : "ELSE requires a following instruction"
    "15"   : "Invalid hexadecimal or binary string"
    "15.1" : "Invalid location of blank in position <position> in hexadecimal string"
    "15.2" : "Invalid location of blank in position <position> in binary string"
    "15.3" : "Only 0-9, a-f, A-F, and blank are valid in a hexadecimal string; found \"<char>\""
    "15.4" : "Only 0, 1, and blank are valid in a binary string; found \"<char>\""
    "16"   : "Label not found"
    "16.1" : "Label \"<name>\" not found"
    "16.2" : "Cannot SIGNAL to label \"<name>\" because it is inside an IF, SELECT or DO group"
    "16.3" : "Cannot invoke label \"<name>\" because it is inside an IF, SELECT or DO group"
    "17"   : "Unexpected PROCEDURE"
    "17.1" : "PROCEDURE is valid only when it is the first instruction executed after an internal CALL or function invocation"
    "18"   : "THEN expected"
    "18.1" : "IF keyword on line <linenumber> requires matching THEN clause; found \"<token>\""
    "18.2" : "WHEN keyword on line <linenumber> requires matching THEN clause; found \"<token>\""
    "19"   : "String or symbol expected"
    "19.1" : "String or symbol expected after ADDRESS keyword; found \"<token>\""
    "19.2" : "String or symbol expected after CALL keyword; found \"<token>\""
    "19.3" : "String or symbol expected after NAME keyword; found \"<token>\""
    "19.4" : "String or symbol expected after SIGNAL keyword; found \"<token>\""
    "19.6" : "String or symbol expected after TRACE keyword; found \"<token>\""
    "19.7" : "Symbol expected in parsing pattern; found \"<token>\""
    "20"   : "Name expected"
    "20.1" : "Name required; found \"<token>\""
    "20.2" : "Found \"<token>\" where only a name is valid"
    "21"   : "Invalid data on end of clause"
    "21.1" : "The clause ended at an unexpected token; found \"<token>\""
    "22"   : "Invalid character string"
    "22.1" : "Invalid character string \"<hex-encoding>\"X"
    "23"   : "Invalid data string"
    "23.1" : "Invalid data string \"<hex-encoding>\"X"
    "24"   : "Invalid TRACE request"
    "24.1" : "TRACE request letter must be one of \"ACEFILNOR\"; found \"<value>\""
    "25"   : "Invalid sub-keyword found"
    "25.1" : "CALL ON must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.2" : "CALL OFF must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.3" : "SIGNAL ON must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.4" : "SIGNAL OFF must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.5" : "ADDRESS WITH must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.6" : "INPUT must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.7" : "OUTPUT must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.8" : "APPEND must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.9" : "REPLACE must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.11": "NUMERIC FORM must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.12": "PARSE must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.13": "UPPER must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.14": "ERROR must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.15": "NUMERIC must be followed by one of the keywords <keywords>; found \"<token>\""
    "25.16": "FOREVER must be followed by one of the keywords <keywords> or nothing; found \"<token>\""
    "25.17": "PROCEDURE must be followed by the keyword EXPOSE or nothing; found \"<token>\""
    "26"   : "Invalid whole number"
    "26.1" : "Whole numbers must fit within current DIGITS setting(<value>); found \"<value>\""
    "26.2" : "Value of repetition count expression in DO instruction must be zero or a positive whole number; found \"<value>\""
    "26.3" : "Value of FOR expression in DO instruction must be zero or a positive whole number; found \"<value>\""
    "26.4" : "Positional pattern of parsing template must be a whole number; found \"<value>\""
    "26.5" : "NUMERIC DIGITS value must be a positive whole number; found \"<value>\""
    "26.6" : "NUMERIC FUZZ value must be zero or a positive whole number; found \"<value>\""
    "26.7" : "Number used in TRACE setting must be a whole number; found \"<value>\""
    "26.8" : "Operand to right of the power operator (\"**\") must be a whole number; found \"<value>\""
    "26.11": "Result of <value> % <value> operation would need exponential notation at current NUMERIC DIGITS <value>"
    "26.12": "Result of % operation used for <value> // <value> operation would need exponential notation at current NUMERIC DIGITS <value>"
    "27"   : "Invalid DO syntax"
    "27.1" : "Invalid use of keyword \"<token>\" in DO clause"
    "28"   : "Invalid LEAVE or ITERATE"
    "28.1" : "LEAVE is valid only within a repetitive DO loop"
    "28.2" : "ITERATE is valid only within a repetitive DO loop"
    "28.3" : "Symbol following LEAVE (\"<token>\") must either match control variable of a current DO loop or be omitted"
    "28.4" : "Symbol following ITERATE (\"<token>\") must either match control variable of a current DO loop or be omitted"
    "29"   : "Environment name too long"
    "29.1" : "Environment name exceeds \(Limit_EnvironmentName) characters; found \"<name>\""
    "30"   : "Name or string too long"
    "30.1" : "Name exceeds \(Limit_Name) characters"
    "30.2" : "Literal string exceeds \(Limit_Literal) characters"
    "31"   : "Name starts with number or \".\""
    "31.1" : "A value cannot be assigned to a number; found \"<token>\""
    "31.2" : "Variable symbol must not start with a number; found \"<token>\""
    "31.3" : "Variable symbol must not start with a \".\"; found \"<token>\""
    "33"   : "Invalid expression result"
    "33.1" : "Value of NUMERIC DIGITS (\"<value>\") must exceed value of NUMERIC FUZZ \"(<value>)\""
    "33.2" : "Value of NUMERIC DIGITS (\"<value>\") must not exceed \(Limit_Digits)"
    "33.3" : "Result of expression following NUMERIC FORM must start with \"E\" or \"S\"; found \"<value>\""
    "34"   : "Logical value not \"0\" or \"1\""
    "34.1" : "Value of expression following IF keyword must be exactly \"0\" or \"1\"; found \"<value>\""
    "34.2" : "Value of expression following WHEN keyword must be exactly \"0\" or \"1\"; found \"<value>\""
    "34.3" : "Value of expression following WHILE keyword must be exactly \"0\" or \"1\"; found \"<value>\""
    "34.4" : "Value of expression following UNTIL keyword must be exactly \"0\" or \"1\"; found \"<value>\""
    "34.5" : "Value of expression to left of logical operator \"<operator>\" must be exactly \"0\" or \"1\"; found \"<value>\""
    "34.6" : "Value of expression to right of logical operator \"<operator>\" must be exactly \"0\" or \"1\"; found \"<value>\""
    "35"   : "Invalid expression"
    "35.1" : "Invalid expression detected at \"<token>\""
    "36"   : "Unmatched \"(\" in expression"
    "37"   : "Unexpected \",\" or \")\""
    "37.1" : "Unexpected \",\""
    "37.2" : "Unmatched \")\" in expression"
    "38"   : "Invalid template or pattern"
    "38.1" : "Invalid parsing template detected at \"<token>\""
    "38.2" : "Invalid parsing position detected at \"<token>\""
    "38.3" : "PARSE VALUE instruction requires WITH keyword"
    "40"   : "Incorrect call to routine"
    "40.1" : "External routine \"<name>\" failed"
    "40.3" : "Not enough arguments in invocation of <bif>; minimum expected is <argnumber>"
    "40.4" : "Too many arguments in invocation of <bif>; maximum expected is <argnumber>"
    "40.5" : "Missing argument in invocation of <bif>; argument <argnumber> is required"
    "40.9" : "<bif> argument <argnumber> exponent exceeds \(Limit_ExponentDigits) digits; found \"<value>\""
    "40.11": "<bif> argument <argnumber> must be a number; found \"<value>\""
    "40.12": "<bif> argument <argnumber> must be a whole number; found \"<value>\""
    "40.13": "<bif> argument <argnumber> must be zero or positive; found \"<value>\""
    "40.14": "<bif> argument <argnumber> must be positive; found \"<value>\""
    "40.15": "<bif> argument <argnumber> must fit in <value> digits; found \"<value>\""
    "40.16": "<bif> argument 1 requires a whole number fitting within DIGITS(<value>); found \"<value>\""
    "40.17": "<bif> argument 1 must have an integer part in the range 0:90 and a decimal part no larger than .9; found \"<value>\""
    "40.18": "<bif> conversion must have a year in the range 0001 to 9999"
    "40.19": "<bif> argument 2, \"<value>\", is not in the format described by argument 3, \"<value>\""
    "40.21": "<bif> argument <argnumber> must not be null"
    "40.23": "<bif> argument <argnumber> must be a single character; found \"<value>\""
    "40.24": "<bif> argument 1 must be a binary string; found \"<value>\""
    "40.25": "<bif> argument 1 must be a hexadecimal string; found \"<value>\""
    "40.26": "<bif> argument 1 must be a valid symbol; found \"<value>\""
    "40.27": "<bif> argument 1 must be a valid stream name; found \"<value>\""
    "40.28": "<bif> argument <argnumber>, option must start with one of \"<optionslist>\"; found \"<value>\""
    "40.29": "<bif> conversion to format \"<value>\" is not allowed"
    "40.31": "<bif> argument 1 (\"<value>\") must not exceed 100000"
    "40.32": "<bif> the difference between argument 1 (\"<value>\") and argument 2 (\"<value>\") must not exceed 100000"
    "40.33": "<bif> argument 1 (\"<value>\") must be less than or equal to argument 2 (\"<value>\")"
    "40.34": "<bif> argument 1 (\"<value>\") must be less than or equal to the number of lines in the program (<sourceline()>)"
    "40.35": "<bif> argument 1 cannot be expressed as a whole number; found \"<value>\""
    "40.36": "<bif> argument 1 must be the name of a variable in the pool; found \"<value>\""
    "40.37": "<bif> argument 3 must be the name of a pool; found \"<value>\""
    "40.38": "<bif> argument <argnumber> is not large enough to format \"<value>\""
    "40.39": "<bif> argument 3 is not zero or one; found \"<value>\""
    "40.41": "<bif> argument <argnumber> must be within the bounds of the stream; found \"<value>\""
    "40.42": "<bif> argument 1; cannot position on this stream; found \"<value>\""
    "41"   : "Bad arithmetic conversion"
    "41.1" : "Non-numeric value (\"<value>\") to left of arithmetic operation \"<operator>\""
    "41.2" : "Non-numeric value (\"<value>\") to right of arithmetic operation \"<operator>\""
    "41.3" : "Non-numeric value (\"<value>\") used with prefix operator \"<operator>\""
    "41.4" : "Value of TO expression in DO instruction must be numeric; found \"<value>\""
    "41.5" : "Value of BY expression in DO instruction must be numeric; found \"<value>\""
    "41.6" : "Value of control variable expression of DO instruction must be numeric; found \"<value>\""
    "41.7" : "Exponent exceeds \(Limit_ExponentDigits) digits; found \"<value>\""
    "42"   : "Arithmetic overflow/underflow"
    "42.1" : "Arithmetic overflow detected at \"<value> <operation> <value>\"; exponent of result requires more than \(Limit_ExponentDigits) digits"
    "42.2" : "Arithmetic underflow detected at \"<value> <operation> <value>\"; exponent of result requires more than \(Limit_ExponentDigits) digits"
    "42.3" : "Arithmetic overflow; divisor must not be zero"
    "43"   : "Routine not found"
    "43.1" : "Could not find routine \"<name>\""
    "44"   : "Function did not return data"
    "44.1" : "No data returned from function \"<name>\""
    "45"   : "No data specified on function RETURN"
    "45.1" : "Data expected on RETURN instruction because routine \"<name>\" was called as a function"
    "46"   : "Invalid variable reference"
    "46.1" : "Extra token (\"<token>\") found in variable reference; \")\" expected"
    "47"   : "Unexpected label"
    "47.1" : "INTERPRET data must not contain labels; found \"<name>\""
    "48"   : "Failure in system service"
    "48.1" : "Failure in system service: <description>"
    "49"   : "Interpretation Error"
    "49.1" : "Interpretation Error: <description>"
    "50"   : "Unrecognized reserved symbol"
    "50.1" : "Unrecognized reserved symbol \"<token>\""
    "51"   : "Invalid function name"
    "51.1" : "Unquoted function names must not end with a period; found \"<token>\""
    "52"   : "Result returned by \"<name>\" is longer than \(Limit_String) characters"
    "53"   : "Invalid option"
    "53.1" : "Variable reference expected after STREAM keyword; found \"<token>\""
    "53.2" : "Variable reference expected after STEM keyword; found \"<token>\""
    "53.3" : "Argument to STEM must have one period, as its last character; found \"<name>\""
    "54"   : "Invalid STEM value"
    "54.1" : "For this STEM APPEND, the value of \"<name>\" must be a count of lines; found: \"<value>\""
}

TYPE TokenType IS ENUM
    Label
    Special
    Var_symbol
    Const_symbol
    String
    Operator
    Blank
    Eos
END ENUM

TYPE Token IS RECORD
    line: Number
    type: TokenType
    abuttal: Boolean
    value: String
END RECORD

FUNCTION Token.toString(self: Token): String
    RETURN "<\(self.line):\(self.type):\(self.value)>"
END FUNCTION

TYPE ContextType IS ENUM
    call
    do_single
    do_repetitive
    if
    select
END ENUM

TYPE ContextEntry IS RECORD
    type: ContextType
    call_tokens: Array<Token>
    call_return_ip: Number
    call_args: Array<String>
    call_is_procedure: Boolean
    call_vars: Dictionary<String>
    call_arrays: Dictionary<Dictionary<String>>
    do_skip: Number
    do_top: Number
    do_var: String
    do_bounded: Boolean
    do_bounded_to: Number
    do_by: Number
    do_for: Number
    do_while_condition: Number
    if_skip: Number
    select_skip: Number
END RECORD

VAR script_filename: String
VAR sourcelines: Array<String>
VAR source_tokens: Array<Token>
VAR label_index: Dictionary<Number>
VAR vars: Dictionary<String>
VAR arrays: Dictionary<Dictionary<String>>
VAR contexts: Array<ContextEntry>
VAR signals: Dictionary<String> := {
    "NOTREADY": "NOTREADY",
    "SYNTAX": "SYNTAX",
}
VAR streams: Dictionary<textio.TextFile>
VAR current_environment: String := "SYSTEM"

FUNCTION error(number: Number, values: Dictionary<String> DEFAULT {})
    LET basenumber := str(math.trunc(number))
    textio.writeLine(textio.stderr, "Error \(basenumber) running \"\(script_filename)\": \(ErrorText[basenumber])")
    LET msg := ErrorText[str(number)]
    VAR r := ""
    VAR i := 0
    WHILE i < msg.length() DO
        LET left := i + string.find(msg[i TO LAST], "<")
        IF left < i THEN
            r.append(msg[i TO LAST])
            EXIT WHILE
        END IF
        r.append(msg[i TO left-1])
        LET right := left + string.find(msg[left TO LAST], ">")
        ASSERT right > left
        r.append(values[msg[left+1 TO right-1]])
        i := right + 1
    END WHILE
    textio.writeLine(textio.stderr, "Error \(number): \(r)")
    sys.exit(1)
END FUNCTION

FUNCTION is_digit(c: String): Boolean
    RETURN "0" <= c <= "9"
END FUNCTION

FUNCTION is_general_letter(c: String): Boolean
    RETURN "A" <= c <= "Z" OR
           "a" <= c <= "z" OR
           c IN ["_", "!", "?", "@", "#", "$"]
END FUNCTION

FUNCTION is_var_symbol_char(c: String): Boolean
    RETURN is_general_letter(c) OR is_digit(c) OR c = "."
END FUNCTION

FUNCTION convert_binary_string(s: String): String
    CONSTANT Digits: String := "01"
    VAR i: Number := s.length()
    IF i = 0 THEN
        RETURN ""
    END IF
    DEC i
    VAR r: String := ""
    VAR b: Number := 0
    VAR bit: Number := 0b1
    LOOP
        IF i < 0 OR s[i] NOT IN Digits THEN
            RAISE SyntaxException(info WITH "invalid binary string")
        END IF
        b := b + string.find(Digits, s[i]) * bit
        bit := bit * 2
        DEC i
        FOR z := 2 TO 4 DO
            IF i < 0 THEN
                -- Ignore missing leading digit.
                EXIT FOR
            ELSIF s[i] NOT IN Digits THEN
                RAISE SyntaxException(info WITH "invalid binary string")
            ELSE
                b := b + string.find(Digits, s[i]) * bit
                bit := bit * 2
                DEC i
            END IF
        END FOR
        IF i < 0 OR bit >= 0x100 THEN
            r := string.fromCodePoint(b) & r
            b := 0
            bit := 0b1
        END IF
        IF i < 0 THEN
            EXIT LOOP
        END IF
        WHILE i >= 0 AND s[i] = " " DO
            DEC i
        END WHILE
    END LOOP
    RETURN r
END FUNCTION

FUNCTION convert_hex_string(s: String): String
    CONSTANT Digits: String := "0123456789ABCDEF"
    LET t: String := string.upper(s)
    VAR i: Number := t.length()
    IF i = 0 THEN
        RETURN ""
    END IF
    DEC i
    VAR r: String := ""
    LOOP
        IF i < 0 OR t[i] NOT IN Digits THEN
            error(15.3, {"char": t[i]})
            -- TODO RAISE SyntaxException(info WITH "invalid hex string")
        END IF
        VAR b: Number := string.find(Digits, t[i])
        DEC i
        IF i < 0 THEN
            -- Ignore missing leading digit.
        ELSIF t[i] NOT IN Digits THEN
            error(15.3, {"char": t[i]})
            -- TODO RAISE SyntaxException(info WITH "invalid hex string")
        ELSE
            b := b + string.find(Digits, t[i]) * 0x10
            DEC i
        END IF
        r := string.fromCodePoint(b) & r
        IF i < 0 THEN
            EXIT LOOP
        END IF
        WHILE i >= 0 AND t[i] = " " DO
            DEC i
        END WHILE
    END LOOP
    RETURN r
END FUNCTION

FUNCTION tokenise(source: String): Array<Token>
    VAR tokens: Array<Token> := []
    VAR line: Number := 1
    VAR i: Number := 0
    VAR last_was_space: Boolean := FALSE
    WHILE i < source.length() DO
        VAR t: Token := Token()
        t.line := line
        t.abuttal := NOT last_was_space
        last_was_space := FALSE
        IF source[i] IN [",", ":", ";", ")", "("] THEN
            t.type := TokenType.Special
            t.value := source[i]
            tokens.append(t)
            INC i
        ELSIF source[i] = "\n" THEN
            IF tokens.size() > 0 AND tokens[LAST].type = TokenType.Special AND tokens[LAST].value = "," THEN
                -- Comma continuation, delete last token.
                tokens.resize(tokens.size() - 1)
                last_was_space := TRUE
            ELSE
                t.type := TokenType.Special
                t.value := ";"
                tokens.append(t)
            END IF
            INC i
            INC line
        ELSIF is_general_letter(source[i]) THEN
            t.type := TokenType.Var_symbol
            WHILE i < source.length() AND is_var_symbol_char(source[i]) DO
                t.value.append(source[i])
                INC i
            END WHILE
            t.value := string.upper(t.value)
            IF i < source.length() AND source[i] = ":" THEN
                t.type := TokenType.Label
                INC i
            END IF
            tokens.append(t)
        ELSIF is_digit(source[i]) OR source[i] = "." THEN
            t.type := TokenType.Const_symbol
            WHILE i < source.length() DO
                IF is_var_symbol_char(source[i]) THEN
                    t.value.append(source[i])
                    INC i
                ELSIF source[i] IN ["E","e"] AND source[i+1] IN ["+","-"] THEN
                    t.value.append(source[i TO i+1])
                    i := i + 2
                ELSE
                    EXIT WHILE
                END IF
            END WHILE
            IF i < source.length() AND source[i] = ":" THEN
                t.type := TokenType.Label
                INC i
            END IF
            tokens.append(t)
        ELSIF source[i] IN ["'", "\""] THEN
            LET delim: String := source[i]
            INC i
            t.type := TokenType.String
            LOOP
                IF i >= source.length() THEN
                    error((IF delim = "'" THEN 6.2 ELSE 6.3))
                END IF
                IF source[i] = delim THEN
                    IF i+1 < source.length() AND source[i+1] = delim THEN
                        t.value.append(delim)
                        i := i + 2
                    ELSE
                        EXIT LOOP
                    END IF
                ELSE
                    t.value.append(source[i])
                    INC i
                END IF
            END LOOP
            INC i
            IF i < source.length() AND source[i] IN ["B", "b"] AND NOT is_var_symbol_char(source[i+1]) THEN
                t.type := TokenType.String
                t.value := convert_binary_string(t.value)
                INC i
            ELSIF i < source.length() AND source[i] IN ["X", "x"] AND NOT is_var_symbol_char(source[i+1]) THEN
                t.type := TokenType.String
                t.value := convert_hex_string(t.value)
                INC i
            END IF
            tokens.append(t)
        ELSIF source[i] IN ["+", "-", "%", "|", "&", "=", "\\", "^", ">", "<", "/", "*"] THEN
            IF source[i] = "/" AND source[i+1] = "*" THEN
                VAR level: Number := 0
                REPEAT
                    IF i+1 >= source.length() THEN
                        error(6.1)
                    END IF
                    IF source[i] = "/" AND source[i+1] = "*" THEN
                        INC level
                        i := i + 2
                    ELSIF source[i] = "*" AND source[i+1] = "/" THEN
                        DEC level
                        i := i + 2
                    ELSIF source[i] = "\n" THEN
                        INC line
                        INC i
                    ELSE
                        INC i
                    END IF
                UNTIL level = 0
            ELSE
                t.type := TokenType.Operator
                CASE source[i]
                    WHEN "|" DO
                        CASE source[i+1]
                            WHEN "|" DO
                                t.value := "||"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "|"
                        END CASE
                    WHEN "/" DO
                        CASE source[i+1]
                            WHEN "/" DO
                                t.value := "//"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "/"
                        END CASE
                    WHEN "*" DO
                        CASE source[i+1]
                            WHEN "*" DO
                                t.value := "**"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "*"
                        END CASE
                    WHEN "\\", "^" DO
                        CASE source[i+1]
                            WHEN "=" DO
                                CASE source[i+2]
                                    WHEN "=" DO
                                        t.value := "\\=="
                                        i := i + 2
                                    WHEN OTHERS DO
                                        t.value := "\\="
                                        i := i + 1
                                END CASE
                            WHEN "<" DO
                                ASSERT FALSE, "unimplemented <"
                            WHEN ">" DO
                                ASSERT FALSE, "unimplemented >"
                            WHEN OTHERS DO
                                t.value := "\\"
                        END CASE
                    WHEN ">" DO
                        CASE source[i+1]
                            WHEN "<" DO
                                t.value := "><"
                                i := i + 1
                            WHEN ">" DO
                                CASE source[i+2]
                                    WHEN "=" DO
                                        t.value := ">>="
                                        i := i + 2
                                    WHEN OTHERS DO
                                        t.value := ">>"
                                        i := i + 1
                                END CASE
                            WHEN "=" DO
                                t.value := ">="
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := ">"
                        END CASE
                    WHEN "<" DO
                        CASE source[i+1]
                            WHEN ">" DO
                                t.value := "<>"
                                i := i + 1
                            WHEN "<" DO
                                CASE source[i+2]
                                    WHEN "=" DO
                                        t.value := "<<="
                                        i := i + 2
                                    WHEN OTHERS DO
                                        t.value := "<<"
                                        i := i + 1
                                END CASE
                            WHEN "=" DO
                                t.value := "<="
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "<"
                        END CASE
                    WHEN "=" DO
                        CASE source[i+1]
                            WHEN "=" DO
                                t.value := "=="
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "="
                        END CASE
                    WHEN "&" DO
                        CASE source[i+1]
                            WHEN "&" DO
                                t.value := "&&"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "&"
                        END CASE
                    WHEN OTHERS DO
                        t.value := source[i]
                END CASE
                tokens.append(t)
                INC i
            END IF
        ELSIF source[i] IN [" "] THEN
            INC i
            last_was_space := TRUE
        ELSE
            error(13.1, {"char": source[i], "hex-encoding": base.toHex(string.toCodePoint(source[i]))})
        END IF
    END WHILE
    RETURN tokens
END FUNCTION

FUNCTION make_label_index(tokens: Array<Token>): Dictionary<Number>
    VAR r: Dictionary<Number> := {}
    FOREACH t IN tokens INDEX i DO
        IF t.type = TokenType.Label AND t.value NOT IN r THEN
            r[t.value] := i
        END IF
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION get_var(name: String): String
    LET dot: Number := string.find(name, ".")
    IF dot < 0 OR dot = name.length() - 1 THEN
        IF name NOT IN vars THEN
            RETURN name
        END IF
        RETURN vars[name]
    END IF
    LET stem: String := name[FIRST TO dot]
    VAR items: Array<String> := string.split(name[dot+1 TO LAST], ".")
    FOR i := 0 TO items.size() - 1 DO
        items[i] := get_var(items[i])
    END FOR
    LET tail: String := string.join(items, ".")
    IF stem NOT IN arrays THEN
        IF stem IN vars THEN
            RETURN vars[stem]
        END IF
        RETURN stem & tail
    END IF
    IF tail NOT IN arrays[stem] THEN
        IF stem IN vars THEN
            RETURN vars[stem]
        END IF
        RETURN stem & tail
    END IF
    RETURN arrays[stem][tail]
END FUNCTION

FUNCTION set_var(name: String, value: String)
    --print("set_var \(name) \(value)")
    LET dot: Number := string.find(name, ".")
    IF dot < 0 OR dot = name.length() - 1 THEN
        vars[name] := value
        EXIT FUNCTION
    END IF
    LET stem: String := name[FIRST TO dot]
    VAR items: Array<String> := string.split(name[dot+1 TO LAST], ".")
    FOR i := 0 TO items.size() - 1 DO
        items[i] := get_var(items[i])
    END FOR
    LET tail: String := string.join(items, ".")
    arrays[stem][tail] := value
END FUNCTION

FUNCTION is_number(s: String, OUT n: Number): Boolean
    n := 0
    TRY
        n := num(s)
        RETURN TRUE
    TRAP ValueRangeException DO
        RETURN FALSE
    END TRY
END FUNCTION

FUNCTION rxnum(s: String): Number
    TRY
        VAR t: String := s
        t := string.trim(s)
        IF string.hasPrefix(t, ".") THEN
            t := "0" & t
        END IF
        RETURN num(t)
    TRAP ValueRangeException DO
        RAISE SyntaxException(info WITH "not a number: <\(s)>")
    END TRY
END FUNCTION

FUNCTION find_label(tokens: Array<Token>, label: String, OUT index: Number): Boolean
    index := -1
    IF label IN label_index THEN
        index := label_index[label]
        RETURN TRUE
    END IF
    RETURN FALSE
END FUNCTION

FUNCTION change_radix(s: String, from_radix: Number, to_radix: Number): String
    CONSTANT Digits: String := "0123456789ABCDEF"
    VAR n: Number := 0
    FOREACH c IN s DO
        IF c = " " THEN
            NEXT FOREACH
        END IF
        n := n * from_radix + string.find(Digits, c)
    END FOREACH
    VAR r: String := ""
    WHILE n > 0 DO
        r := Digits[n MOD to_radix] & r
        n := n INTDIV to_radix
    END WHILE
    RETURN r
END FUNCTION

FUNCTION builtin_abbrev(args: Array<String>): String
    LET information: String := args[0]
    LET info: String := args[1]
    LET length: Number := (IF args.size() >= 3 THEN rxnum(args[2]) ELSE 0)
    CHECK info.length() >= length ELSE
        RETURN "0"
    END CHECK
    CHECK info.length() <= information.length() ELSE
        RETURN "0"
    END CHECK
    RETURN (IF info = information[FIRST TO info.length()-1] THEN "1" ELSE "0")
END FUNCTION

FUNCTION builtin_abs(args: Array<String>): String
    RETURN str(math.abs(rxnum(args[0])))
END FUNCTION

FUNCTION builtin_address(args: Array<String>): String
    -- TODO
    RETURN ""
END FUNCTION

FUNCTION builtin_arg(args: Array<String>): String
    IF args.size() = 0 THEN
        RETURN str(contexts[LAST].call_args.size())
    END IF
    LET n: Number := rxnum(args[0]) - 1
    IF args.size() = 1 THEN
        IF n < contexts[LAST].call_args.size() THEN
            RETURN contexts[LAST].call_args[n]
        ELSE
            RETURN ""
        END IF
    ELSE
        LET option: String := args[1]
        -- TODO: make distinction between optional and empty string?
        CASE option
            WHEN "E", "e" DO
                RETURN (IF n < contexts[LAST].call_args.size() AND contexts[LAST].call_args[n] <> "" THEN "1" ELSE "0")
            WHEN "O", "o" DO
                RETURN (IF n >= contexts[LAST].call_args.size() OR contexts[LAST].call_args[n] = "" THEN "1" ELSE "0")
            WHEN OTHERS DO
                ASSERT FALSE, option
                RETURN ""
        END CASE
    END IF
END FUNCTION

FUNCTION builtin_b2x(args: Array<String>): String
    RETURN change_radix(args[0], 2, 16)
END FUNCTION

FUNCTION builtin_bitand(args: Array<String>): String
    LET string1: String := args[0]
    LET string2: String := (IF args.size() >= 2 THEN args[1] ELSE "")
    LET pad: String := (IF args.size() >= 3 THEN args[2] ELSE "")
    VAR a1: Array<Number> := []
    FOREACH c IN string1 DO
        a1.append(string.toCodePoint(c))
    END FOREACH
    VAR a2: Array<Number> := []
    FOREACH c IN string2 DO
        a2.append(string.toCodePoint(c))
    END FOREACH
    VAR r: Array<Number> := []
    FOR i := 0 TO math.max(a1.size(), a2.size())-1 DO
        LET b1: Number := (IF i < a1.size() THEN a1[i] ELSE (IF pad <> "" THEN string.toCodePoint(pad) ELSE a2[i]))
        LET b2: Number := (IF i < a2.size() THEN a2[i] ELSE (IF pad <> "" THEN string.toCodePoint(pad) ELSE a1[i]))
        r.append(binary.and32(b1, b2))
    END FOR
    VAR s: String := ""
    FOREACH b IN r DO
        s.append(string.fromCodePoint(b))
    END FOREACH
    RETURN s
END FUNCTION

FUNCTION builtin_bitor(args: Array<String>): String
    LET string1: String := args[0]
    LET string2: String := (IF args.size() >= 2 THEN args[1] ELSE "")
    LET pad: String := (IF args.size() >= 3 THEN args[2] ELSE "")
    VAR a1: Array<Number> := []
    FOREACH c IN string1 DO
        a1.append(string.toCodePoint(c))
    END FOREACH
    VAR a2: Array<Number> := []
    FOREACH c IN string2 DO
        a2.append(string.toCodePoint(c))
    END FOREACH
    VAR r: Array<Number> := []
    FOR i := 0 TO math.max(a1.size(), a2.size())-1 DO
        LET b1: Number := (IF i < a1.size() THEN a1[i] ELSE (IF pad <> "" THEN string.toCodePoint(pad) ELSE a2[i]))
        LET b2: Number := (IF i < a2.size() THEN a2[i] ELSE (IF pad <> "" THEN string.toCodePoint(pad) ELSE a1[i]))
        r.append(binary.or32(b1, b2))
    END FOR
    VAR s: String := ""
    FOREACH b IN r DO
        s.append(string.fromCodePoint(b))
    END FOREACH
    RETURN s
END FUNCTION

FUNCTION builtin_bitxor(args: Array<String>): String
    LET string1: String := args[0]
    LET string2: String := (IF args.size() >= 2 THEN args[1] ELSE "")
    LET pad: String := (IF args.size() >= 3 THEN args[2] ELSE "")
    VAR a1: Array<Number> := []
    FOREACH c IN string1 DO
        a1.append(string.toCodePoint(c))
    END FOREACH
    VAR a2: Array<Number> := []
    FOREACH c IN string2 DO
        a2.append(string.toCodePoint(c))
    END FOREACH
    VAR r: Array<Number> := []
    FOR i := 0 TO math.max(a1.size(), a2.size())-1 DO
        LET b1: Number := (IF i < a1.size() THEN a1[i] ELSE (IF pad <> "" THEN string.toCodePoint(pad) ELSE a2[i]))
        LET b2: Number := (IF i < a2.size() THEN a2[i] ELSE (IF pad <> "" THEN string.toCodePoint(pad) ELSE a1[i]))
        r.append(binary.xor32(b1, b2))
    END FOR
    VAR s: String := ""
    FOREACH b IN r DO
        s.append(string.fromCodePoint(b))
    END FOREACH
    RETURN s
END FUNCTION

FUNCTION builtin_c2d(args: Array<String>): String
    LET s: String := args[0]
    LET length: Number := (IF args.size() >= 2 THEN rxnum(args[1]) ELSE s.length())
    LET start: Number := math.max(0, s.length()-length)
    LET sign: Boolean := (IF start < s.length() THEN string.toCodePoint(s[start]) >= 0x80 ELSE FALSE)
    VAR n: Number := 0
    FOR i := start TO s.length()-1 DO
        LET b: Number := string.toCodePoint(s[i])
        n := n * 0x100 + b
    END FOR
    IF args.size() >= 2 AND length <= s.length() AND sign THEN
        n := n - 2^(8*length)
    END IF
    RETURN str(n)
END FUNCTION

FUNCTION builtin_c2x(args: Array<String>): String
    LET s: String := args[0]
    LET length: Number := (IF args.size() >= 2 THEN rxnum(args[1]) ELSE s.length())
    IF s = "" THEN
        RETURN ""
    END IF
    LET start: Number := math.max(0, s.length()-length)
    VAR n: Number := 0
    FOR i := start TO s.length()-1 DO
        LET b: Number := string.toCodePoint(s[i])
        n := n * 0x100 + b
    END FOR
    VAR r: String := string.upper(base.toHex(n))
    IF math.odd(r.length()) THEN
        r := "0" & r
    END IF
    RETURN r
END FUNCTION

FUNCTION builtin_center(args: Array<String>): String
    LET s: String := args[0]
    LET length: Number := rxnum(args[1])
    LET pad: String := (IF args.size() >= 3 AND args[2] <> "" THEN args[2] ELSE " ")
    IF s.length() < length THEN
        LET half: Number := (length - s.length()) INTDIV 2
        RETURN string.repeat(pad, half) & s & string.repeat(pad, length - s.length() - half)
    ELSE
        LET start: Number := (s.length() - length) INTDIV 2
        RETURN s[start TO start+length-1]
    END IF
END FUNCTION

FUNCTION builtin_charout(args: Array<String>): String
    IF args[0] = "" THEN
        io.write(io.stdout, args[1])
        io.flush(io.stdout)
        RETURN str(args[1].length())
    ELSE
        ASSERT FALSE, "charout only to stdout", args
        RETURN ""
    END IF
END FUNCTION

FUNCTION builtin_changestr(args: Array<String>): String
    RETURN string.replaceAll(args[1], args[0], args[2])
END FUNCTION

FUNCTION builtin_compare(args: Array<String>): String
    VAR s1 := args[0]
    VAR s2 := args[1]
    LET pad := (IF args.size() >= 3 THEN args[2] ELSE " ")
    IF s1.length() < s2.length() THEN
        s1.append(string.repeat(pad, s2.length() - s1.length()))
    ELSIF s2.length() < s1.length() THEN
        s2.append(string.repeat(pad, s1.length() - s2.length()))
    END IF
    ASSERT s1.length() = s2.length()
    FOR i := 0 TO s1.length() - 1 DO
        IF s1[i] <> s2[i] THEN
            RETURN str(i + 1)
        END IF
    END FOR
    RETURN "0"
END FUNCTION

FUNCTION builtin_copies(args: Array<String>): String
    RETURN string.repeat(args[0], rxnum(args[1]))
END FUNCTION

FUNCTION builtin_countstr(args: Array<String>): String
    LET needle := args[0]
    LET haystack := args[1]
    CHECK needle <> "" ELSE
        RETURN "0"
    END CHECK
    VAR r := 0
    VAR i := 0
    WHILE i <= haystack.length() - needle.length() DO
        IF haystack[i TO i + needle.length() - 1] = needle THEN
            INC r
            i := i + needle.length()
        ELSE
            INC i
        END IF
    END WHILE
    RETURN str(r)
END FUNCTION

FUNCTION builtin_d2c(args: Array<String>): String
    VAR n := rxnum(args[0])
    LET length := (IF args.size() >= 2 THEN rxnum(args[1]) ELSE -1)
    VAR r := ""
    IF n < 0 THEN
        ASSERT length > 0
        n := 2^(8*length) + n
    END IF
    WHILE n > 0 DO
        r := string.fromCodePoint(n MOD 0x100) & r
        n := n INTDIV 0x100
    END WHILE
    RETURN r
END FUNCTION

FUNCTION builtin_d2x(args: Array<String>): String
    VAR n := rxnum(args[0])
    LET length := (IF args.size() >= 2 THEN rxnum(args[1]) ELSE -1)
    VAR r := ""
    IF n < 0 THEN
        ASSERT length > 0
        n := 2^(8*length) + n
    END IF
    WHILE n > 0 DO
        r := string.upper(base.toHex(n MOD 0x100)) & r
        n := n INTDIV 0x100
    END WHILE
    --IF length >= 0 THEN
    --    RETURN r[LAST-length TO LAST]
    --ELSE
        RETURN r
    --END IF
END FUNCTION

FUNCTION builtin_datatype(args: Array<String>): String
    LET s := args[0]
    LET type := (IF args.size() >= 2 THEN args[1] ELSE "")
    IF type = "" THEN
        TRY
            _ := rxnum(s)
            RETURN "NUM"
        TRAP SyntaxException DO
            RETURN "CHAR"
        END TRY
    END IF
    FUNCTION all(t: String, chars: String): String
        IF t = "" THEN
            RETURN "0"
        END IF
        FOREACH c IN t DO
            IF c NOT IN chars THEN
                RETURN "0"
            END IF
        END FOREACH
        RETURN "1"
    END FUNCTION
    CASE string.upper(type)
        WHEN "A" DO -- Alphanumeric
            RETURN all(s, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
        WHEN "B" DO -- Binary
            TRY
                _ := convert_binary_string(s)
                RETURN "1"
            TRAP SyntaxException DO
                RETURN "0"
            END TRY
        WHEN "L" DO -- Lowercase
            RETURN all(s, "abcdefghijklmnopqrstuvwxyz")
        WHEN "M" DO -- Mixed case
            RETURN all(s, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
        WHEN "N" DO -- Number
            TRY
                _ := rxnum(s)
                RETURN "1"
            TRAP SyntaxException DO
                RETURN "0"
            END TRY
        WHEN "S" DO -- Symbol
            IF tokenise(s).size() = 1 THEN
                RETURN "1"
            ELSE
                RETURN "0"
            END IF
        WHEN "U" DO -- Uppercase
            RETURN all(s, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
        WHEN "W" DO -- Whole number
            TRY
                LET n := rxnum(s)
                RETURN all(str(n), "-0123456789")
            TRAP SyntaxException DO
                RETURN "0"
            END TRY
        WHEN "X" DO -- Hexadecimal
            TRY
                _ := convert_hex_string(s)
                RETURN "1"
            TRAP SyntaxException DO
                RETURN "0"
            END TRY
    END CASE
    RETURN "0"
END FUNCTION

FUNCTION builtin_delstr(args: Array<String>): String
    LET s := args[0]
    LET start := rxnum(args[1]) - 1
    LET length := (IF args.size() >= 3 THEN rxnum(args[2]) ELSE -1)
    IF start >= s.length() THEN
        RETURN s
    END IF
    IF length < 0 OR start + length >= s.length() THEN
        RETURN s[FIRST TO start-1]
    END IF
    RETURN s[FIRST TO start-1] & s[start+length TO LAST]
END FUNCTION

FUNCTION builtin_delword(args: Array<String>): String
    LET s := args[0]
    LET start := rxnum(args[1])
    LET length := (IF args.size() >= 3 THEN rxnum(args[2]) ELSE -1)
    VAR wordstarts: Array<Number> := [0]
    VAR inword := FALSE
    FOREACH c IN s INDEX i DO
        IF inword AND c = " " THEN
            inword := FALSE
        ELSIF NOT inword AND c <> " " THEN
            wordstarts.append(i)
            inword := TRUE
        END IF
    END FOREACH
    IF start >= wordstarts.size() THEN
        RETURN s
    END IF
    IF length < 0 OR start + length >= wordstarts.size() THEN
        RETURN s[FIRST TO wordstarts[start]-1]
    END IF
    RETURN s[FIRST TO wordstarts[start]-1] & s[wordstarts[start+length] TO LAST]
END FUNCTION

FUNCTION builtin_digits(args: Array<String>): String
    RETURN "9" -- TODO
END FUNCTION

FUNCTION builtin_errortext(args: Array<String>): String
    RETURN ErrorText[args[0]]
END FUNCTION

FUNCTION builtin_form(args: Array<String>): String
    RETURN "SCIENTIFIC" -- TODO
END FUNCTION

FUNCTION builtin_format(args: Array<String>): String
    -- TODO: actually format
    RETURN args[0]
END FUNCTION

FUNCTION builtin_fuzz(args: Array<String>): String
    RETURN "0"
END FUNCTION

FUNCTION builtin_left(args: Array<String>): String
    LET s := args[0]
    LET length := rxnum(args[1])
    IF length <= s.length() THEN
        RETURN s[FIRST TO length-1]
    ELSE
        RETURN s & string.repeat(" ", length - s.length())
    END IF
END FUNCTION

FUNCTION builtin_length(args: Array<String>): String
    RETURN str(args[0].length())
END FUNCTION

FUNCTION builtin_lineout(args: Array<String>): String
    LET name := args[0]
    LET s := (IF args.size() >= 2 THEN args[1] ELSE "")
    --LET line := (IF args.size() >= 3 THEN rxnum(args[2]) ELSE 0)
    IF args.size() >= 2 THEN
        IF name NOT IN streams THEN
            streams[name] := textio.open(name, textio.Mode.write)
        END IF
        textio.writeLine(streams[name], s)
    ELSE
        textio.close(streams[name])
    END IF
    RETURN "0"
END FUNCTION

FUNCTION builtin_pos(args: Array<String>): String
    RETURN str(string.find(args[1], args[0]) + 1)
END FUNCTION

VAR using_lfsr: Boolean := FALSE
VAR random_seed: Number := 0

FUNCTION random_lfsr(): Number
    random_seed := (random_seed * 22695477 + 1) MOD 2^32
    RETURN random_seed INTDIV 2^16
END FUNCTION

FUNCTION builtin_random(args: Array<String>): String
    LET min: Number := (IF args.size() >= 1 AND args[0] <> "" THEN rxnum(args[0]) ELSE 0)
    LET max: Number := (IF args.size() >= 2 AND args[1] <> "" THEN rxnum(args[1]) ELSE 999)
    LET seed: Number := (IF args.size() >= 3 AND args[2] <> "" THEN rxnum(args[2]) ELSE 0)
    IF seed <> 0 THEN
        random_seed := seed
        using_lfsr := TRUE
    END IF
    IF using_lfsr THEN
        RETURN str(random_lfsr() MOD (max - min + 1) + min)
    ELSE
        RETURN str(random.uint32() MOD (max - min + 1) + min)
    END IF
END FUNCTION

FUNCTION builtin_sourceline(args: Array<String>): String
    RETURN sourcelines[rxnum(args[0])]
END FUNCTION

FUNCTION builtin_stream(args: Array<String>): String
    LET name := args[0]
    LET option := string.upper(args[1])
    LET command := string.upper(args[2])
    CASE option
        WHEN "C" DO
            LET a := string.split(command, " ")
            IF command = "OPEN WRITE REPLACE" THEN
                streams[name] := textio.open(name, textio.Mode.write)
            ELSIF command = "CLOSE" THEN
                textio.close(streams[name])
            ELSE
                ASSERT FALSE, "unknown command", command
            END IF
        WHEN "D" DO
            ASSERT FALSE, "description goes here"
        WHEN "S" DO
            IF name IN streams THEN
                RETURN "READY"
            ELSE
                RETURN "UNKNOWN"
            END IF
        WHEN OTHERS DO
            ASSERT FALSE, "unknown option", option
    END CASE
    RETURN ""
END FUNCTION

FUNCTION builtin_substr(args: Array<String>): String
    LET start: Number := rxnum(args[1]) - 1
    LET length: Number := rxnum(args[2])
    IF start + length < args[0].length() THEN
        RETURN args[0][start TO start+length-1]
    ELSE
        RETURN args[0][start TO LAST] & string.repeat(" ", start + length - args[0].length())
    END IF
END FUNCTION

VAR time_reset: Number := 0

FUNCTION builtin_time(args: Array<String>): String
    IF args[0] = "R" THEN
        LET now: Number := time.now()
        LET r: Number := now - time_reset
        time_reset := now
        RETURN str(r)
    ELSE
        ASSERT FALSE, args
        RETURN ""
    END IF
END FUNCTION

FUNCTION builtin_trace(args: Array<String>): String
    -- TODO
    RETURN ""
END FUNCTION

FUNCTION builtin_translate(args: Array<String>): String
    LET s := args[0]
    VAR tableout := args[1]
    LET tablein := args[2]
    LET pad := (IF args.size() >= 4 THEN args[3] ELSE " ")
    IF tableout.length() < tablein.length() THEN
        tableout.append(string.repeat(pad[0], tablein.length() - tableout.length()))
    END IF
    VAR r := ""
    FOREACH c IN s DO
        LET i := string.find(tablein, c)
        IF i >= 0 THEN
            r.append(tableout[i])
        ELSE
            r.append(c)
        END IF
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION builtin_value(args: Array<String>): String
    RETURN get_var(args[0])
END FUNCTION

FUNCTION builtin_word(args: Array<String>): String
    RETURN string.split(args[0], " ")[rxnum(args[1]) - 1]
END FUNCTION

FUNCTION builtin_words(args: Array<String>): String
    RETURN str(string.split(args[0], " ").size())
END FUNCTION

VAR BuiltinFunctions: Dictionary<FUNCTION(args: Array<String>): String> := {
    "ABBREV": builtin_abbrev,
    "ABS": builtin_abs,
    "ADDRESS": builtin_address,
    "ARG": builtin_arg,
    "B2X": builtin_b2x,
    "BITAND": builtin_bitand,
    "BITOR": builtin_bitor,
    "BITXOR": builtin_bitxor,
    "C2D": builtin_c2d,
    "C2X": builtin_c2x,
    "CENTER": builtin_center,
    "CENTRE": builtin_center,
    "CHAROUT": builtin_charout,
    "CHANGESTR": builtin_changestr,
    "COMPARE": builtin_compare,
    "COPIES": builtin_copies,
    "COUNTSTR": builtin_countstr,
    "D2C": builtin_d2c,
    "D2X": builtin_d2x,
    "DATATYPE": builtin_datatype,
    "DELSTR": builtin_delstr,
    "DELWORD": builtin_delword,
    "DIGITS": builtin_digits,
    "ERRORTEXT": builtin_errortext,
    "FORM": builtin_form,
    "FORMAT": builtin_format,
    "FUZZ": builtin_fuzz,
    "LEFT": builtin_left,
    "LENGTH": builtin_length,
    "LINEOUT": builtin_lineout,
    "POS": builtin_pos,
    "RANDOM": builtin_random,
    "SOURCELINE": builtin_sourceline,
    "STREAM": builtin_stream,
    "SUBSTR": builtin_substr,
    "TIME": builtin_time,
    "TRACE": builtin_trace,
    "TRANSLATE": builtin_translate,
    "VALUE": builtin_value,
    "WORD": builtin_word,
    "WORDS": builtin_words,
}

FUNCTION builtin_function(name: String, args: Array<String>): String
    IF name IN BuiltinFunctions THEN
        LET f: FUNCTION(args: Array<String>): String := BuiltinFunctions[name]
        RETURN f(args)
    END IF
    ASSERT FALSE, "unknown builtin function", name
    RETURN ""
END FUNCTION

FUNCTION get_function_arguments(tokens: Array<Token>, INOUT i: Number): Array<String>
    VAR r: Array<String> := []
    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value IN [")", ";"]) DO
        LET s: String := evaluate(tokens, INOUT i, [])
        r.append(s)
        IF tokens[i].type = TokenType.Special AND tokens[i].value = "," THEN
            INC i
        END IF
    END WHILE
    RETURN r
END FUNCTION

FUNCTION evaluate_term(tokens: Array<Token>, INOUT i: Number): String
    VAR r: String := ""
    CASE tokens[i].type
        WHEN TokenType.Var_symbol DO
            LET name: String := tokens[i].value
            INC i
            IF tokens[i].type = TokenType.Special AND tokens[i].value = "(" AND tokens[i].abuttal THEN
                INC i
                LET args: Array<String> := get_function_arguments(tokens, INOUT i)
                ASSERT tokens[i].type = TokenType.Special AND tokens[i].value = ")"
                INC i
                VAR lindex: Number
                IF find_label(source_tokens, name, OUT lindex) THEN
                    vars["SIGL"] := str(tokens[i].line)
                    contexts.append(ContextEntry(type WITH ContextType.call, call_tokens WITH tokens, call_return_ip WITH i, call_args WITH args))
                    r := interpret_function(source_tokens, lindex + 1)
                ELSE
                    r := builtin_function(name, args)
                END IF
            ELSE
                r := get_var(name)
            END IF
        WHEN TokenType.Const_symbol, TokenType.String DO
            r := tokens[i].value
            INC i
            IF tokens[i].type = TokenType.Special AND tokens[i].value = "(" AND tokens[i].abuttal THEN
                INC i
                LET args: Array<String> := get_function_arguments(tokens, INOUT i)
                ASSERT tokens[i].type = TokenType.Special AND tokens[i].value = ")"
                INC i
                r := builtin_function(r, args)
            END IF
        WHEN OTHERS DO
            -- Must be empty argument, as in: call charout , 'a'
    END CASE
    RETURN r
END FUNCTION

CONSTANT OperatorPrecedence: Dictionary<Number> := {
    "": -1,
    ")": -1,
    "(": 0,
    "&&": 1,
    "|": 2,
    "&": 3,
    "=": 4,
    "\\=": 4,
    "==": 4,
    "\\==": 4,
    "<": 4,
    "<=": 4,
    ">": 4,
    ">=": 4,
    "<>": 4,
    " ": 5,
    "||": 5,
    "+": 6,
    "-": 6,
    "*": 7,
    "/": 7,
    "%": 7,
    "//": 7,
    "**": 8,
    "negate": 9,
    "\\": 9,
}

FUNCTION evaluate(tokens: Array<Token>, INOUT i: Number, terminating_tokens: Array<String>): String
    --print("evaluate \(tokens[i].type) \(tokens[i].value)")
    VAR operand_stack: Array<String> := []
    VAR operator_stack: Array<String> := []
    VAR paren_depth: Number := 0

    FUNCTION pop_operand(): String
        VAR r: String := operand_stack[LAST]
        operand_stack.resize(operand_stack.size() - 1)
        RETURN r
    END FUNCTION

    FUNCTION push_operand(x: String)
        operand_stack.append(x)
    END FUNCTION

    FUNCTION pop_operator(): String
        VAR r: String := operator_stack[LAST]
        operator_stack.resize(operator_stack.size() - 1)
        RETURN r
    END FUNCTION

    FUNCTION resolve_stack(next_op: String)
        LET level: Number := OperatorPrecedence[next_op]
        WHILE operator_stack.size() > 0 AND level <= OperatorPrecedence[operator_stack[LAST]] DO
            LET op: String := pop_operator()
            CASE op
                WHEN " " DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(x & " " & y)
                WHEN "&&" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF (num(x) <> 0) <> (num(y) <> 0) THEN "1" ELSE "0"))
                WHEN "|" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF num(x) <> 0 OR num(y) <> 0 THEN "1" ELSE "0"))
                WHEN "&" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF num(x) <> 0 AND num(y) <> 0 THEN "1" ELSE "0"))
                WHEN "||" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(x & y)
                WHEN "=" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF string.trim(x) = string.trim(y) THEN "1" ELSE "0"))
                WHEN "\\=", "<>" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF string.trim(x) <> string.trim(y) THEN "1" ELSE "0"))
                WHEN "==" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF x = y THEN "1" ELSE "0"))
                WHEN "\\==" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF x <> y THEN "1" ELSE "0"))
                WHEN "<" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    VAR a: Number
                    VAR b: Number
                    IF is_number(x, OUT a) AND is_number(y, OUT b) THEN
                        push_operand((IF a < b THEN "1" ELSE "0"))
                    ELSE
                        push_operand((IF x < y THEN "1" ELSE "0"))
                    END IF
                WHEN "<=" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    VAR a: Number
                    VAR b: Number
                    IF is_number(x, OUT a) AND is_number(y, OUT b) THEN
                        push_operand((IF a <= b THEN "1" ELSE "0"))
                    ELSE
                        push_operand((IF x <= y THEN "1" ELSE "0"))
                    END IF
                WHEN ">" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF rxnum(x) > rxnum(y) THEN "1" ELSE "0"))
                WHEN ">=" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    VAR a: Number
                    VAR b: Number
                    IF is_number(x, OUT a) AND is_number(y, OUT b) THEN
                        push_operand((IF a >= b THEN "1" ELSE "0"))
                    ELSE
                        push_operand((IF x >= y THEN "1" ELSE "0"))
                    END IF
                WHEN "+" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) + rxnum(y)))
                WHEN "-" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) - rxnum(y)))
                WHEN "*" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) * rxnum(y)))
                WHEN "/" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) / rxnum(y)))
                WHEN "%" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) INTDIV rxnum(y)))
                WHEN "//" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) MOD rxnum(y)))
                WHEN "**" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) ^ rxnum(y)))
                WHEN "negate" DO
                    LET x: String := pop_operand()
                    push_operand(str(-rxnum(x)))
                WHEN "\\" DO
                    LET x: String := pop_operand()
                    CASE x
                        WHEN "0" DO
                            push_operand("1")
                        WHEN "1" DO
                            push_operand("0")
                        WHEN OTHERS DO
                            RAISE SyntaxException(info WITH "argument to \\ is not boolean")
                    END CASE
                WHEN "(" DO
                    -- no operation
                WHEN OTHERS DO
                    ASSERT FALSE, "unimplemented operator", op
            END CASE
        END WHILE
    END FUNCTION

    VAR last_was_term: Boolean := FALSE
    LOOP
        --print("  eval \(tokens[i])")
        --print("    last_was_term \(last_was_term)")
        VAR this_is_term: Boolean := FALSE
        -- First check for binary operators.
        IF tokens[i].type = TokenType.Operator AND
           NOT (tokens[i].value = "\\") AND
           NOT (tokens[i].value IN ["+","-"] AND NOT last_was_term) THEN
            resolve_stack(tokens[i].value)
            operator_stack.append(tokens[i].value)
            INC i
        -- Check for closing parenthesis.
        ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = ")" AND paren_depth > 0 THEN
            DEC paren_depth
            resolve_stack(")")
            this_is_term := TRUE
            INC i
        -- Check for end of expression.
        ELSIF (tokens[i].type = TokenType.Special AND tokens[i].value <> "(") OR
              (paren_depth = 0 AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value IN terminating_tokens) THEN
            ASSERT paren_depth = 0
            resolve_stack("") -- end of expression
            EXIT LOOP
        ELSE
            IF last_was_term THEN
                -- Must be another term, add concatenation operator.
                IF tokens[i].abuttal THEN
                    resolve_stack("||")
                    operator_stack.append("||")
                ELSE
                    resolve_stack(" ")
                    operator_stack.append(" ")
                END IF
            END IF
            IF tokens[i].type = TokenType.Special AND tokens[i].value = "(" THEN
                INC paren_depth
                operator_stack.append("(")
                INC i
            ELSIF tokens[i].type = TokenType.Operator THEN
                IF tokens[i].value = "\\" THEN
                    operator_stack.append(tokens[i].value)
                ELSIF tokens[i].value = "-" AND NOT last_was_term THEN
                    operator_stack.append("negate")
                ELSIF tokens[i].value = "+" AND NOT last_was_term THEN
                    -- Unary + is no operation.
                ELSE
                    ASSERT FALSE, "binary operator should have been handled above"
                END IF
                INC i
            ELSE
                LET term: String := evaluate_term(tokens, INOUT i)
                operand_stack.append(term)
                this_is_term := TRUE
            END IF
        END IF
        --print("    operators \(operator_stack)")
        --print("    operands \(operand_stack)")
        last_was_term := this_is_term
    END LOOP
    IF operand_stack.size() = 0 THEN
        RETURN ""
    END IF
    RETURN operand_stack[FIRST]
END FUNCTION

FUNCTION skip_if_ncl(tokens: Array<Token>, INOUT i: Number)
    IF i < tokens.size() AND tokens[i].type = TokenType.Special AND tokens[i].value = ";" THEN
        INC i
    END IF
END FUNCTION

TYPE TemplateType IS ENUM
    placeholder
    target
    pattern
    positional
END ENUM

TYPE Template IS RECORD
    type: TemplateType
    target: String
    pattern: String
    position: Number
    position_relative: Boolean
END RECORD

FUNCTION Template.toString(self: Template): String
    CASE self.type
        WHEN TemplateType.placeholder DO
            RETURN "<\(self.type)>"
        WHEN TemplateType.target DO
            RETURN "<\(self.type):\(self.target)>"
        WHEN TemplateType.pattern DO
            RETURN "<\(self.type):\(self.pattern)>"
        WHEN TemplateType.positional DO
            RETURN "<\(self.type):\(self.position),\(self.position_relative)>"
    END CASE
END FUNCTION

FUNCTION do_parse(tokens: Array<Token>, INOUT i: Number, upper: Boolean)
    ASSERT tokens[i].type = TokenType.Var_symbol
    LET source: String := tokens[i].value
    INC i
    VAR input: Array<String> := []
    CASE source
        WHEN "ARG" DO
            input := contexts[LAST].call_args
        WHEN "PULL" DO
            input := [console.input("")]
        WHEN "SOURCE" DO
            input := ["LINUX", "COMMAND", script_filename]
        WHEN "VALUE" DO
            input := [evaluate(tokens, INOUT i, ["WITH"])]
            IF NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WITH") THEN
                ASSERT FALSE, "WITH expected"
            END IF
            INC i
        WHEN "VAR" DO
            IF tokens[i].type = TokenType.Var_symbol THEN
                input := [get_var(tokens[i].value)]
                INC i
            ELSE
                ASSERT FALSE, "var not found"
            END IF
        WHEN "VERSION" DO
            input := ["neon 5 2020 Sep 22"]
        WHEN OTHERS DO
            ASSERT FALSE, "unknown parse source", source
    END CASE
    VAR template_list: Array<Array<Template>> := []
    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
        VAR template: Array<Template> := []
        WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
            IF tokens[i].type = TokenType.Var_symbol THEN
                template.append(Template(type WITH TemplateType.target, target WITH tokens[i].value))
                INC i
            ELSIF tokens[i].type = TokenType.String THEN
                template.append(Template(type WITH TemplateType.pattern, pattern WITH tokens[i].value))
                INC i
            ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = "(" THEN
                INC i
                LET sep: String := evaluate(tokens, INOUT i, [])
                ASSERT tokens[i].value = ")"
                INC i
                template.append(Template(type WITH TemplateType.pattern, pattern WITH sep))
            ELSIF tokens[i].type = TokenType.Const_symbol THEN
                IF tokens[i].value = "." THEN
                    template.append(Template(type WITH TemplateType.placeholder))
                ELSE
                    LET pos: Number := num(tokens[i].value)
                    template.append(Template(type WITH TemplateType.positional, position WITH pos, position_relative WITH pos < 0))
                END IF
                INC i
            ELSIF tokens[i].type = TokenType.Operator AND tokens[i].value = "+" THEN
                INC i
                ASSERT tokens[i].type = TokenType.Const_symbol
                template.append(Template(type WITH TemplateType.positional, position WITH num(tokens[i].value), position_relative WITH TRUE))
                INC i
            ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = "," THEN
                INC i
                EXIT WHILE
            ELSE
                ASSERT FALSE, "unexpected template token", tokens[i]
            END IF
        END WHILE
        --FOREACH t IN template DO print("\(t)") END FOREACH
        template_list.append(template)
    END WHILE
    FOREACH s IN input INDEX tli DO
        IF tli >= template_list.size() THEN
            EXIT FOREACH
        END IF
        LET ss: String := (IF upper THEN string.upper(s) ELSE s)
        LET template: Array<Template> := template_list[tli]
        VAR si: Number := 0
        VAR ti: Number := 0
        WHILE si < s.length() AND ti < template.size() DO
            LET t: Template := template[ti]
            --print("si=\(si) ti=\(ti) t=\(t)")
            WHILE si < s.length() AND s[si] = " " DO
                INC si
            END WHILE
            IF ti >= template.size()-1 THEN
                IF t.type = TemplateType.target THEN
                    set_var(t.target, (IF si < s.length() THEN s[si TO LAST] ELSE ""))
                END IF
                INC ti
                EXIT WHILE
            END IF
            CASE t.type
                WHEN TemplateType.placeholder, TemplateType.target DO
                    VAR next: Number := si
                    CASE template[ti+1].type
                        WHEN TemplateType.placeholder, TemplateType.target DO
                            IF t.type = TemplateType.target THEN
                                WHILE next < s.length() AND s[next] <> " " DO
                                    INC next
                                END WHILE
                            END IF
                        WHEN TemplateType.pattern DO
                            LET j: Number := string.find(s[next TO LAST], template[ti+1].pattern)
                            IF j >= 0 THEN
                                next := next + j
                            ELSE
                                next := s.length()
                            END IF
                        WHEN TemplateType.positional DO
                            IF template[ti+1].position_relative THEN
                                next := next + template[ti+1].position
                            ELSE
                                next := template[ti+1].position - 1
                            END IF
                            INC ti
                    END CASE
                    IF t.type = TemplateType.target THEN
                        IF next > si THEN
                            set_var(t.target, s[si TO next-1])
                        ELSE
                            set_var(t.target, s[si TO LAST])
                        END IF
                    END IF
                    si := next
                WHEN TemplateType.pattern DO
                    ASSERT s[si TO si+t.pattern.length()-1] = t.pattern
                    si := si + t.pattern.length()
                WHEN TemplateType.positional DO
                    IF t.position_relative THEN
                        si := si + t.position
                    ELSE
                        si := t.position - 1
                    END IF
            END CASE
            INC ti
        END WHILE
        WHILE ti < template.size() DO
            IF template[ti].type = TemplateType.target THEN
                set_var(template[ti].target, "")
            END IF
            INC ti
        END WHILE
    END FOREACH
END FUNCTION

FUNCTION send_command(environment: String, command: String): String
    CASE environment
        WHEN "COMMAND" DO
            IF string.hasPrefix(command, "rexx ") THEN
                RETURN str(os.system("bin/neon samples/rexx/rexx.neon \(command[5 TO LAST])"))
            ELSE
                ASSERT FALSE, "unknown command", command
            END IF
        WHEN "SYSTEM" DO
            RETURN str(os.system(command))
    END CASE
    ASSERT FALSE, "unknown environment", environment
    RETURN ""
END FUNCTION

FUNCTION skip_instruction(tokens: Array<Token>, INOUT i: Number): Boolean
    CHECK i < tokens.size() ELSE
        RETURN FALSE
    END CHECK
    IF tokens[i].type = TokenType.Var_symbol THEN
        IF tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
            INC i
            WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
                INC i
            END WHILE
        ELSE
            CASE tokens[i].value
                WHEN "DO" DO
                    INC i
                    VAR do_var: String := ""
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
                        do_var := tokens[i].value
                    END IF
                    WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "END") DO
                        IF NOT skip_instruction(tokens, INOUT i) THEN
                            RETURN FALSE
                        END IF
                    END WHILE
                    INC i
                    IF do_var <> "" AND tokens[i].type = TokenType.Var_symbol THEN
                        IF tokens[i].value = do_var THEN
                            INC i
                        ELSE
                            ASSERT FALSE, "mismatch loop var", tokens[i]
                        END IF
                    END IF
                WHEN "IF" DO
                    WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN") DO
                        INC i
                    END WHILE
                    INC i
                    skip_if_ncl(tokens, INOUT i)
                    IF NOT skip_instruction(tokens, INOUT i) THEN
                        RETURN FALSE
                    END IF
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "ELSE" THEN
                        INC i
                        skip_if_ncl(tokens, INOUT i)
                        IF NOT skip_instruction(tokens, INOUT i) THEN
                            RETURN FALSE
                        END IF
                    END IF
                WHEN "SELECT" DO
                    INC i
                    WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "END") DO
                        IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WHEN" THEN
                            WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN") DO
                                INC i
                            END WHILE
                            INC i
                        ELSE
                            IF NOT skip_instruction(tokens, INOUT i) THEN
                                RETURN FALSE
                            END IF
                        END IF
                    END WHILE
                    INC i
                WHEN OTHERS DO
                    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
                        INC i
                    END WHILE
            END CASE
        END IF
    ELSE
        WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
            INC i
        END WHILE
    END IF
    skip_if_ncl(tokens, INOUT i)
    RETURN TRUE
END FUNCTION

FUNCTION do_check_terminate(tokens: Array<Token>, INOUT i: Number, context: ContextEntry): Boolean
    LET var: String := context.do_var
    IF var <> "" THEN
        LET value := num(get_var(var))
        IF context.do_bounded AND value > context.do_bounded_to THEN
            RETURN TRUE
        END IF
    END IF
    LET while: Number := context.do_while_condition
    IF while > 0 THEN
        i := context.do_while_condition
        LET cond: String := evaluate(tokens, INOUT i, [])
        IF cond = "0" THEN
            RETURN TRUE
        ELSIF cond <> "1" THEN
            ASSERT FALSE, "unexpected cond", cond
        END IF
    END IF
    RETURN FALSE
END FUNCTION

FUNCTION do_iterate(context: ContextEntry)
    LET var: String := context.do_var
    IF var <> "" THEN
        LET newvalue: Number := num(get_var(var)) + context.do_by
        set_var(var, str(newvalue))
    END IF
END FUNCTION

FUNCTION interpret_step(INOUT tokens: Array<Token>, INOUT i: Number): Boolean
    --VAR o: Object := vars print(o.toString())
    --print("interpret \(contexts.size()) \(tokens[i])")
    LET orig_i: Number := i
    CASE tokens[i].type
        WHEN TokenType.Label DO
            INC i
        WHEN TokenType.Special DO
            CASE tokens[i].value
                WHEN ";" DO
                    INC i
                WHEN OTHERS DO
                    ASSERT FALSE, "unexpected special token", tokens[i]
            END CASE
        WHEN TokenType.Var_symbol DO
            IF tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
                LET var: String := tokens[i].value
                i := i + 2
                LET s: String := evaluate(tokens, INOUT i, [])
                set_var(var, s)
                RETURN TRUE
            END IF
            CASE tokens[i].value
                WHEN "ADDRESS" DO
                    INC i
                    IF tokens[i].type = TokenType.Var_symbol THEN
                        IF tokens[i].value = "VALUE" THEN
                            INC i
                            current_environment := evaluate(tokens, INOUT i, ["WITH"])
                        ELSE
                            LET environment := tokens[i].value
                            INC i
                            IF NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") THEN
                                LET command := evaluate(tokens, INOUT i, ["WITH"])
                                vars["RC"] := send_command(environment, command)
                            END IF
                        END IF
                    ELSE
                        ASSERT FALSE, "unexpected token", tokens[i]
                    END IF
                WHEN "ARG" DO
                    do_parse(tokens, INOUT i, upper WITH TRUE)
                WHEN "CALL" DO
                    INC i
                    IF tokens[i].type IN [TokenType.Const_symbol, TokenType.Var_symbol] THEN
                        LET name: String := tokens[i].value
                        INC i
                        LET args: Array<String> := get_function_arguments(tokens, INOUT i)
                        VAR lindex: Number
                        IF find_label(source_tokens, name, OUT lindex) THEN
                            vars["SIGL"] := str(tokens[i].line)
                            contexts.append(ContextEntry(type WITH ContextType.call, call_tokens WITH tokens, call_return_ip WITH i, call_args WITH args))
                            tokens := source_tokens
                            i := lindex + 1
                        ELSE
                            vars["RESULT"] := builtin_function(name, args)
                        END IF
                    ELSE
                        ASSERT FALSE, "unexpected thing to call", tokens[i]
                    END IF
                WHEN "DO" DO
                    VAR out_of_loop: Number := i
                    IF NOT skip_instruction(tokens, INOUT out_of_loop) THEN
                        error(999)
                    END IF
                    INC i
                    IF tokens[i].type = TokenType.Special AND tokens[i].value = ";" THEN
                        contexts.append(ContextEntry(type WITH ContextType.do_single, do_skip WITH out_of_loop))
                    ELSE
                        VAR context: ContextEntry := ContextEntry(type WITH ContextType.do_repetitive, do_skip WITH out_of_loop, do_by WITH 1)
                        context.call_args := contexts[LAST].call_args -- TODO handle this better
                        IF tokens[i].type = TokenType.Var_symbol AND tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
                            context.do_var := tokens[i].value
                            i := i + 2
                            set_var(context.do_var, evaluate(tokens, INOUT i, ["TO", "BY", "FOR", "WHILE", "UNTIL"]))
                            LOOP
                                IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "TO" THEN
                                    INC i
                                    context.do_bounded := TRUE
                                    context.do_bounded_to := num(evaluate(tokens, INOUT i, ["TO", "BY", "FOR", "WHILE", "UNTIL"]))
                                ELSIF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "BY" THEN
                                    INC i
                                    context.do_by := num(evaluate(tokens, INOUT i, ["TO", "BY", "FOR", "WHILE", "UNTIL"]))
                                ELSIF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "FOR" THEN
                                    INC i
                                    context.do_for := num(evaluate(tokens, INOUT i, ["TO", "BY", "FOR", "WHILE", "UNTIL"]))
                                ELSE
                                    EXIT LOOP
                                END IF
                            END LOOP
                        ELSIF NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") THEN
                            IF NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value IN ["WHILE", "UNTIL"]) THEN
                                LET rep := num(evaluate(tokens, INOUT i, ["WHILE", "UNTIL"]))
                                context.do_var := ".INDEX.\(i)"
                                set_var(context.do_var, "1")
                                context.do_bounded := TRUE
                                context.do_bounded_to := rep
                                IF rep <= 0 THEN
                                    i := out_of_loop
                                END IF
                            END IF
                        END IF
                        IF i < tokens.size() AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WHILE" THEN
                            INC i
                            context.do_while_condition := i
                            WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
                                INC i
                            END WHILE
                        END IF
                        IF do_check_terminate(tokens, INOUT i, context) THEN
                            i := out_of_loop
                        END IF
                        IF i < out_of_loop THEN
                            context.do_top := i
                            contexts.append(context)
                        END IF
                    END IF
                WHEN "DROP" DO
                    INC i
                    LOOP
                        IF tokens[i].type = TokenType.Var_symbol THEN
                            -- TODO: need dictionary remove
                            -- vars.remove(tokens[i].value)
                            INC i
                        ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = "(" THEN
                            ASSERT FALSE, "indirect drop"
                        ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = ";" THEN
                            EXIT LOOP
                        ELSE
                            ASSERT FALSE, "unexpected thing to drop"
                        END IF
                    END LOOP
                WHEN "ELSE" DO
                    CASE contexts[LAST].type
                        WHEN ContextType.if DO
                            i := contexts[LAST].if_skip
                            contexts.resize(contexts.size() - 1)
                        WHEN OTHERS DO
                            error(8.2)
                    END CASE
                WHEN "END" DO
                    --print("END context \(contexts[LAST].type)")
                    CASE contexts[LAST].type
                        WHEN ContextType.do_single DO
                            INC i
                            contexts.resize(contexts.size() - 1)
                        WHEN ContextType.do_repetitive DO
                            do_iterate(contexts[LAST])
                            IF do_check_terminate(tokens, INOUT i, contexts[LAST]) THEN
                                i := contexts[LAST].do_skip
                                contexts.resize(contexts.size() - 1)
                            ELSE
                                i := contexts[LAST].do_top
                            END IF
                        WHEN ContextType.select DO
                            INC i
                            contexts.resize(contexts.size() - 1)
                        WHEN OTHERS DO
                            error(10.1)
                    END CASE
                WHEN "EXIT" DO
                    INC i
                    VAR r: String := "0"
                    IF NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") THEN
                        r := evaluate(tokens, INOUT i, [])
                    END IF
                    sys.exit(rxnum(r))
                WHEN "IF" DO
                    INC i
                    LET cond: String := evaluate(tokens, INOUT i, ["THEN"])
                    ASSERT tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN"
                    INC i
                    skip_if_ncl(tokens, INOUT i)
                    CASE cond
                        WHEN "1" DO
                            VAR else: Number := i
                            IF NOT skip_instruction(tokens, INOUT else) THEN
                                error(14.3)
                            END IF
                            IF else < tokens.size() AND tokens[else].type = TokenType.Var_symbol AND tokens[else].value = "ELSE" THEN
                                INC else
                                skip_if_ncl(tokens, INOUT else)
                                VAR skip: Number := else
                                IF NOT skip_instruction(tokens, INOUT skip) THEN
                                    error(999)
                                END IF
                                contexts.append(ContextEntry(type WITH ContextType.if, if_skip WITH skip, call_args WITH contexts[LAST].call_args))
                            END IF
                        WHEN "0" DO
                            IF NOT skip_instruction(tokens, INOUT i) THEN
                                error(14.3)
                            END IF
                            IF i < tokens.size() AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "ELSE" THEN
                                INC i
                            END IF
                        WHEN OTHERS DO
                            ASSERT FALSE, "unexpected cond", cond
                    END CASE
                WHEN "INTERPRET" DO
                    INC i
                    LET expr: String := evaluate(tokens, INOUT i, [])
                    LET itokens: Array<Token> := tokenise(expr) & [Token(type WITH TokenType.Special, value WITH ";"), Token(type WITH TokenType.Eos)]
                    contexts.append(ContextEntry(type WITH ContextType.call, call_tokens WITH tokens, call_return_ip WITH i))
                    tokens := itokens
                    i := 0
                WHEN "ITERATE" DO
                    WHILE contexts.size() > 0 AND contexts[LAST].type <> ContextType.do_repetitive DO
                        contexts.resize(contexts.size() - 1)
                    END WHILE
                    do_iterate(contexts[LAST])
                    IF do_check_terminate(tokens, INOUT i, contexts[LAST]) THEN
                        i := contexts[LAST].do_skip
                        contexts.resize(contexts.size() - 1)
                    ELSE
                        i := contexts[LAST].do_top
                    END IF
                WHEN "LEAVE" DO
                    WHILE contexts.size() > 0 AND contexts[LAST].type <> ContextType.do_repetitive DO
                        contexts.resize(contexts.size() - 1)
                    END WHILE
                    i := contexts[LAST].do_skip
                    contexts.resize(contexts.size() - 1)
                WHEN "NOP" DO
                    INC i
                    -- No operation.
                WHEN "OPTIONS" DO
                    INC i
                    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
                        INC i
                    END WHILE
                WHEN "OTHERWISE" DO
                    CASE contexts[LAST].type
                        WHEN ContextType.select DO
                            i := contexts[LAST].select_skip
                            contexts.resize(contexts.size() - 1)
                        WHEN OTHERS DO
                            error(9.0)
                    END CASE
                WHEN "PARSE" DO
                    INC i
                    LET upper: Boolean := tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "UPPER"
                    IF upper THEN
                        INC i
                    END IF
                    do_parse(tokens, INOUT i, upper)
                WHEN "PROCEDURE" DO
                    IF i = 0 OR tokens[i-1].type <> TokenType.Label THEN
                        error(17.0)
                    END IF
                    INC i
                    VAR exposed: Array<String> := []
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "EXPOSE" THEN
                        INC i
                        WHILE tokens[i].type = TokenType.Var_symbol DO
                            exposed.append(tokens[i].value)
                            INC i
                        END WHILE
                    END IF
                    contexts[LAST].call_is_procedure := TRUE
                    contexts[LAST].call_vars := vars
                    contexts[LAST].call_arrays := arrays
                    -- TODO: save exposed vars so they can be put back to caller later
                    vars := {}
                    arrays := {}
                    FOREACH var IN exposed DO
                        IF string.hasSuffix(var, ".") THEN
                            arrays[var] := contexts[LAST].call_arrays[var]
                        ELSE
                            vars[var] := contexts[LAST].call_vars[var]
                        END IF
                    END FOREACH
                    -- TODO: expose arrays
                WHEN "PULL" DO
                    do_parse(tokens, INOUT i, upper WITH TRUE)
                WHEN "RETURN" DO
                    INC i
                    WHILE contexts.size() > 0 AND contexts[LAST].type <> ContextType.call DO
                        contexts.resize(contexts.size() - 1)
                    END WHILE
                    ASSERT contexts.size() > 0, "unexpected return"
                    -- TODO: expression is optional
                    LET r: String := evaluate(tokens, INOUT i, [])
                    tokens := contexts[LAST].call_tokens
                    i := contexts[LAST].call_return_ip
                    IF contexts[LAST].call_is_procedure THEN
                        vars := contexts[LAST].call_vars
                        arrays := contexts[LAST].call_arrays
                    END IF
                    vars["RESULT"] := r
                    contexts.resize(contexts.size() - 1)
                WHEN "SAY" DO
                    INC i
                    IF NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") THEN
                        LET s: String := evaluate(tokens, INOUT i, [])
                        print(s)
                    ELSE
                        INC i
                        print("")
                    END IF
                WHEN "SELECT" DO
                    VAR end_of_select: Number := i
                    IF NOT skip_instruction(tokens, INOUT end_of_select) THEN
                        error(999)
                    END IF
                    INC i
                    skip_if_ncl(tokens, INOUT i)
                    VAR found: Boolean := FALSE
                    WHILE tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WHEN" DO
                        INC i
                        LET cond: String := evaluate(tokens, INOUT i, ["THEN"])
                        ASSERT tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN"
                        INC i
                        skip_if_ncl(tokens, INOUT i)
                        IF cond = "1" THEN
                            contexts.append(ContextEntry(type WITH ContextType.select, select_skip WITH end_of_select))
                            found := TRUE
                            EXIT WHILE
                        ELSIF cond = "0" THEN
                            IF NOT skip_instruction(tokens, INOUT i) THEN
                                error(999)
                            END IF
                        ELSE
                            ASSERT FALSE, "unexpected cond", cond
                        END IF
                    END WHILE
                    IF NOT found AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "OTHERWISE" THEN
                        INC i
                        contexts.append(ContextEntry(type WITH ContextType.select, select_skip WITH end_of_select))
                    END IF
                WHEN "SIGNAL" DO
                    INC i
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "ON" THEN
                        INC i
                        IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value IN signals.keys() THEN
                            LET signal: String := tokens[i].value
                            VAR label: String := signal
                            INC i
                            IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "NAME" THEN
                                INC i
                                IF tokens[i].type = TokenType.Var_symbol THEN
                                    label := tokens[i].value
                                    INC i
                                ELSE
                                    ASSERT FALSE, "label expected", tokens[i]
                                END IF
                            END IF
                            signals[signal] := label
                        ELSE
                            ASSERT FALSE, "unknown signal type", tokens[i]
                        END IF
                    ELSE
                        LET name: String := tokens[i].value
                        INC i
                        VAR lindex: Number
                        IF find_label(source_tokens, name, OUT lindex) THEN
                            vars["SIGL"] := str(tokens[i].line)
                            tokens := source_tokens
                            i := lindex + 1
                        ELSE
                            error(16.1, {"name": name})
                        END IF
                    END IF
                WHEN "THEN" DO
                    error(8.1)
                WHEN "TRACE" DO
                    INC i
                    VAR setting: String := tokens[i].value
                    INC i
                    CASE setting
                        WHEN "OFF" DO
                            -- No action
                        WHEN "VALUE" DO
                            setting := evaluate(tokens, INOUT i, [])
                    END CASE
                    -- TODO: trace setting
                WHEN "WHEN" DO
                    CASE contexts[LAST].type
                        WHEN ContextType.select DO
                            i := contexts[LAST].select_skip
                            contexts.resize(contexts.size() - 1)
                        WHEN OTHERS DO
                            error(9.0)
                    END CASE
                WHEN OTHERS DO
                    LET r: String := evaluate(tokens, INOUT i, [])
                    vars["RC"] := send_command(current_environment, r)
            END CASE
        WHEN TokenType.Eos DO
            CASE contexts[LAST].type
                WHEN ContextType.call DO
                    tokens := contexts[LAST].call_tokens
                    i := contexts[LAST].call_return_ip
                    contexts.resize(contexts.size() - 1)
                WHEN OTHERS DO
                    RETURN FALSE
            END CASE
        WHEN OTHERS DO
            IF tokens[i].type = TokenType.Const_symbol AND tokens[i+1].type = TokenType.Operator AND tokens[i+1].value IN ["=","=="] THEN
                RAISE SyntaxException(info WITH "assignment to constant")
            END IF
            LET r: String := evaluate(tokens, INOUT i, [])
            vars["RC"] := send_command(current_environment, r)
    END CASE
    IF i = orig_i THEN
        ASSERT FALSE, "we are stuck", tokens[i]
    END IF
    skip_if_ncl(tokens, INOUT i)
    RETURN TRUE
END FUNCTION

FUNCTION interpret_function(start_tokens: Array<Token>, start_i: Number): String
    VAR tokens: Array<Token> := start_tokens
    VAR i: Number := start_i
    LET context_depth: Number := contexts.size()
    WHILE contexts.size() >= context_depth DO
        IF NOT interpret_step(INOUT tokens, INOUT i) THEN
            EXIT WHILE
        END IF
    END WHILE
    RETURN vars["RESULT"]
END FUNCTION

FUNCTION interpret()
    VAR tokens: Array<Token> := source_tokens
    VAR i: Number := 0
    WHILE i < tokens.size() DO
        TRY
            IF NOT interpret_step(INOUT tokens, INOUT i) THEN
                EXIT WHILE
            END IF
        TRAP SyntaxException AS e DO
            VAR lindex: Number
            IF find_label(source_tokens, signals["SYNTAX"], OUT lindex) THEN
                vars["SIGL"] := str(tokens[i].line)
                contexts := []
                tokens := source_tokens
                i := lindex + 1
                -- TODO: pop contexts and restore vars/arrays
            ELSE
                print("syntax error: \(e.info)")
                sys.exit(1)
            END IF
        END TRY
    END WHILE
END FUNCTION

BEGIN MAIN
    script_filename := sys.args[1]
    TRY
        LET bytes: Bytes := file.readBytes(script_filename)
        LET source: String := bytes.decodeToString()
        sourcelines := [""] & string.splitLines(source)
        source_tokens := tokenise(source)
    TRAP file.FileException DO
        error(3.1, {"description": "Program was not found"})
    END TRY
    label_index := make_label_index(source_tokens)
    --FOREACH t IN source_tokens INDEX i DO
    --    print("\(i) \(t.type) \(t.value)")
    --END FOREACH
    contexts.append(ContextEntry(call_return_ip WITH -1, call_args WITH [string.join(sys.args[2 TO LAST], " ")]))
    interpret()
    ASSERT contexts.size() = 1
END MAIN
