IMPORT console
IMPORT file
IMPORT io
IMPORT os
IMPORT random
IMPORT string
IMPORT sys
IMPORT time

EXCEPTION SyntaxException

TYPE TokenType IS ENUM
    Label
    Special
    Var_symbol
    Const_symbol
    String
    Operator
    Blank
    Eos
END ENUM

TYPE Token IS RECORD
    line: Number
    type: TokenType
    abuttal: Boolean
    value: String
END RECORD

FUNCTION Token.toString(self: Token): String
    RETURN "<\(self.line):\(self.type):\(self.value)>"
END FUNCTION

TYPE ContextType IS ENUM
    call
    do_single
    do_repetitive
    if
    select
END ENUM

TYPE ContextEntry IS RECORD
    type: ContextType
    call_tokens: Array<Token>
    call_return_ip: Number
    call_args: Array<String>
    call_is_procedure: Boolean
    call_vars: Dictionary<String>
    call_arrays: Dictionary<Dictionary<String>>
    do_skip: Number
    do_top: Number
    do_var: String
    do_bounded: Boolean
    do_bounded_to: Number
    do_by: Number
    do_for: Number
    do_rep: Number
    do_while_condition: Number
    if_skip: Number
    select_skip: Number
END RECORD

VAR script_filename: String
VAR sourcelines: Array<String>
VAR source_tokens: Array<Token>
VAR vars: Dictionary<String>
VAR arrays: Dictionary<Dictionary<String>>
VAR contexts: Array<ContextEntry>
VAR signals: Dictionary<String> := {
    "SYNTAX": "SYNTAX",
}

FUNCTION is_digit(c: String): Boolean
    RETURN "0" <= c <= "9"
END FUNCTION

FUNCTION is_general_letter(c: String): Boolean
    RETURN "A" <= c <= "Z" OR
           "a" <= c <= "z" OR
           c IN ["_", "!", "?"]
END FUNCTION

FUNCTION is_var_symbol_char(c: String): Boolean
    RETURN is_general_letter(c) OR is_digit(c) OR c = "."
END FUNCTION

FUNCTION convert_binary_string(s: String): String
    CONSTANT Digits: String := "01"
    VAR i: Number := s.length()
    IF i = 0 THEN
        RETURN ""
    END IF
    DEC i
    VAR r: String := ""
    VAR b: Number := 0
    VAR bit: Number := 0b1
    LOOP
        IF i < 0 OR s[i] NOT IN Digits THEN
            RAISE SyntaxException
        END IF
        b := b + string.find(Digits, s[i]) * bit
        bit := bit * 2
        DEC i
        FOR z := 2 TO 4 DO
            IF i < 0 THEN
                -- Ignore missing leading digit.
                EXIT FOR
            ELSIF s[i] NOT IN Digits THEN
                RAISE SyntaxException
            ELSE
                b := b + string.find(Digits, s[i]) * bit
                bit := bit * 2
                DEC i
            END IF
        END FOR
        IF i < 0 OR bit >= 0x100 THEN
            r := string.fromCodePoint(b) & r
            b := 0
            bit := 0b1
        END IF
        IF i < 0 THEN
            EXIT LOOP
        END IF
        WHILE i >= 0 AND s[i] = " " DO
            DEC i
        END WHILE
    END LOOP
    RETURN r
END FUNCTION

FUNCTION convert_hex_string(s: String): String
    CONSTANT Digits: String := "0123456789ABCDEF"
    LET t: String := string.upper(s)
    VAR i: Number := t.length()
    IF i = 0 THEN
        RETURN ""
    END IF
    DEC i
    VAR r: String := ""
    LOOP
        IF i < 0 OR t[i] NOT IN Digits THEN
            RAISE SyntaxException
        END IF
        VAR b: Number := string.find(Digits, t[i])
        DEC i
        IF i < 0 THEN
            -- Ignore missing leading digit.
        ELSIF t[i] NOT IN Digits THEN
            RAISE SyntaxException
        ELSE
            b := b + string.find(Digits, t[i]) * 0x10
            DEC i
        END IF
        r := string.fromCodePoint(b) & r
        IF i < 0 THEN
            EXIT LOOP
        END IF
        WHILE i >= 0 AND t[i] = " " DO
            DEC i
        END WHILE
    END LOOP
    RETURN r
END FUNCTION

FUNCTION tokenise(source: String): Array<Token>
    VAR tokens: Array<Token> := []
    VAR line: Number := 1
    VAR i: Number := 0
    VAR last_was_space: Boolean := FALSE
    WHILE i < source.length() DO
        VAR t: Token := Token()
        t.line := line
        t.abuttal := NOT last_was_space
        last_was_space := FALSE
        IF source[i] IN [",", ":", ";", ")", "("] THEN
            t.type := TokenType.Special
            t.value := source[i]
            tokens.append(t)
            INC i
        ELSIF source[i] = "\n" THEN
            IF tokens.size() > 0 AND tokens[LAST].type = TokenType.Special AND tokens[LAST].value = "," THEN
                -- Comma continuation, delete last token.
                tokens.resize(tokens.size() - 1)
                last_was_space := TRUE
            ELSE
                t.type := TokenType.Special
                t.value := ";"
                tokens.append(t)
            END IF
            INC i
            INC line
        ELSIF is_general_letter(source[i]) THEN
            t.type := TokenType.Var_symbol
            WHILE i < source.length() AND is_var_symbol_char(source[i]) DO
                t.value.append(source[i])
                INC i
            END WHILE
            t.value := string.upper(t.value)
            IF i < source.length() AND source[i] = ":" THEN
                t.type := TokenType.Label
                INC i
            END IF
            tokens.append(t)
        ELSIF is_digit(source[i]) OR source[i] = "." THEN
            t.type := TokenType.Const_symbol
            WHILE i < source.length() DO
                IF is_var_symbol_char(source[i]) THEN
                    t.value.append(source[i])
                    INC i
                ELSIF source[i] IN ["E","e"] AND source[i+1] IN ["+","-"] THEN
                    t.value.append(source[i TO i+1])
                    i := i + 2
                ELSE
                    EXIT WHILE
                END IF
            END WHILE
            tokens.append(t)
        ELSIF source[i] IN ["'", "\""] THEN
            LET delim: String := source[i]
            INC i
            t.type := TokenType.String
            LOOP
                IF source[i] = delim THEN
                    IF i+1 < source.length() AND source[i+1] = delim THEN
                        t.value.append(delim)
                        i := i + 2
                    ELSE
                        EXIT LOOP
                    END IF
                ELSE
                    t.value.append(source[i])
                    INC i
                END IF
            END LOOP
            INC i
            IF i < source.length() AND source[i] IN ["B", "b"] AND NOT is_var_symbol_char(source[i+1]) THEN
                t.type := TokenType.String
                t.value := convert_binary_string(t.value)
                INC i
            ELSIF i < source.length() AND source[i] IN ["X", "x"] AND NOT is_var_symbol_char(source[i+1]) THEN
                t.type := TokenType.String
                t.value := convert_hex_string(t.value)
                INC i
            END IF
            tokens.append(t)
        ELSIF source[i] IN ["+", "-", "%", "|", "&", "=", "\\", "^", ">", "<", "/", "*"] THEN
            IF source[i] = "/" AND source[i+1] = "*" THEN
                VAR level: Number := 0
                REPEAT
                    IF source[i] = "/" AND source[i+1] = "*" THEN
                        INC level
                        i := i + 2
                    ELSIF source[i] = "*" AND source[i+1] = "/" THEN
                        DEC level
                        i := i + 2
                    ELSIF source[i] = "\n" THEN
                        INC line
                        INC i
                    ELSE
                        INC i
                    END IF
                UNTIL level = 0
            ELSE
                t.type := TokenType.Operator
                CASE source[i]
                    WHEN "|" DO
                        CASE source[i+1]
                            WHEN "|" DO
                                t.value := "||"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "|"
                        END CASE
                    WHEN "/" DO
                        CASE source[i+1]
                            WHEN "/" DO
                                t.value := "//"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "/"
                        END CASE
                    WHEN "*" DO
                        CASE source[i+1]
                            WHEN "*" DO
                                t.value := "**"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "*"
                        END CASE
                    WHEN "\\", "^" DO
                        CASE source[i+1]
                            WHEN "=" DO
                                CASE source[i+2]
                                    WHEN "=" DO
                                        t.value := "\\=="
                                        i := i + 2
                                    WHEN OTHERS DO
                                        t.value := "\\="
                                        i := i + 1
                                END CASE
                            WHEN "<" DO
                                ASSERT FALSE, "unimplemented <"
                            WHEN ">" DO
                                ASSERT FALSE, "unimplemented >"
                            WHEN OTHERS DO
                                t.value := "\\"
                        END CASE
                    WHEN ">" DO
                        CASE source[i+1]
                            WHEN "<" DO
                                t.value := "><"
                                i := i + 1
                            WHEN ">" DO
                                CASE source[i+2]
                                    WHEN "=" DO
                                        t.value := ">>="
                                        i := i + 2
                                    WHEN OTHERS DO
                                        t.value := ">>"
                                        i := i + 1
                                END CASE
                            WHEN "=" DO
                                t.value := ">="
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := ">"
                        END CASE
                    WHEN "<" DO
                        CASE source[i+1]
                            WHEN ">" DO
                                t.value := "<>"
                                i := i + 1
                            WHEN "<" DO
                                CASE source[i+2]
                                    WHEN "=" DO
                                        t.value := "<<="
                                        i := i + 2
                                    WHEN OTHERS DO
                                        t.value := "<<"
                                        i := i + 1
                                END CASE
                            WHEN "=" DO
                                t.value := "<="
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "<"
                        END CASE
                    WHEN "=" DO
                        CASE source[i+1]
                            WHEN "=" DO
                                t.value := "=="
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "="
                        END CASE
                    WHEN "&" DO
                        CASE source[i+1]
                            WHEN "&" DO
                                t.value := "&&"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "&"
                        END CASE
                    WHEN OTHERS DO
                        t.value := source[i]
                END CASE
                tokens.append(t)
                INC i
            END IF
        ELSIF source[i] IN [" "] THEN
            INC i
            last_was_space := TRUE
        ELSE
            ASSERT FALSE, "unexpected character", source[i]
        END IF
    END WHILE
    RETURN tokens
END FUNCTION

FUNCTION get_var(name: String): String
    LET dot: Number := string.find(name, ".")
    IF dot < 0 OR dot = name.length() - 1 THEN
        IF name NOT IN vars THEN
            RETURN name
        END IF
        RETURN vars[name]
    END IF
    LET stem: String := name[FIRST TO dot]
    VAR items: Array<String> := string.split(name[dot+1 TO LAST], ".")
    FOR i := 0 TO items.size() - 1 DO
        items[i] := get_var(items[i])
    END FOR
    LET tail: String := string.join(items, ".")
    IF stem NOT IN arrays THEN
        IF stem IN vars THEN
            RETURN vars[stem]
        END IF
        RETURN stem & tail
    END IF
    IF tail NOT IN arrays[stem] THEN
        IF stem IN vars THEN
            RETURN vars[stem]
        END IF
        RETURN stem & tail
    END IF
    RETURN arrays[stem][tail]
END FUNCTION

FUNCTION set_var(name: String, value: String)
    --print("set_var \(name) \(value)")
    LET dot: Number := string.find(name, ".")
    IF dot < 0 OR dot = name.length() - 1 THEN
        vars[name] := value
        EXIT FUNCTION
    END IF
    LET stem: String := name[FIRST TO dot]
    VAR items: Array<String> := string.split(name[dot+1 TO LAST], ".")
    FOR i := 0 TO items.size() - 1 DO
        items[i] := get_var(items[i])
    END FOR
    LET tail: String := string.join(items, ".")
    arrays[stem][tail] := value
END FUNCTION

FUNCTION is_number(s: String, OUT n: Number): Boolean
    n := 0
    TRY
        n := num(s)
        RETURN TRUE
    TRAP ValueRangeException DO
        RETURN FALSE
    END TRY
END FUNCTION

FUNCTION rxnum(s: String): Number
    TRY
        VAR t: String := s
        t := string.trim(s)
        IF string.hasPrefix(t, ".") THEN
            t := "0" & t
        END IF
        RETURN num(t)
    TRAP ValueRangeException DO
        --print("not a number: <\(s)>")
        RAISE SyntaxException
    END TRY
END FUNCTION

FUNCTION find_label(tokens: Array<Token>, label: String, OUT index: Number): Boolean
    index := -1
    FOREACH t IN tokens INDEX ti DO
        IF t.type = TokenType.Label AND t.value = label THEN
            index := ti
            RETURN TRUE
        END IF
    END FOREACH
    RETURN FALSE
END FUNCTION

FUNCTION builtin_address(args: Array<String>): String
    -- TODO
    RETURN ""
END FUNCTION

FUNCTION builtin_arg(args: Array<String>): String
    RETURN contexts[LAST].call_args[num(args[0]) - 1]
END FUNCTION

FUNCTION builtin_center(args: Array<String>): String
    LET s: String := args[0]
    LET length: Number := rxnum(args[1])
    LET pad: String := (IF args.size() >= 3 AND args[2] <> "" THEN args[2] ELSE " ")
    IF s.length() < length THEN
        LET half: Number := (length - s.length()) INTDIV 2
        RETURN string.repeat(pad, half) & s & string.repeat(pad, length - s.length() - half)
    ELSE
        RETURN s
    END IF
END FUNCTION

FUNCTION builtin_charout(args: Array<String>): String
    IF args[0] = "" THEN
        io.write(io.stdout, args[1])
        io.flush(io.stdout)
        RETURN str(args[1].length())
    ELSE
        ASSERT FALSE, "charout only to stdout", args
        RETURN ""
    END IF
END FUNCTION

FUNCTION builtin_format(args: Array<String>): String
    -- TODO: actually format
    RETURN args[0]
END FUNCTION

FUNCTION builtin_left(args: Array<String>): String
    RETURN args[0][FIRST TO rxnum(args[1])-1]
END FUNCTION

FUNCTION builtin_length(args: Array<String>): String
    RETURN str(args[0].length())
END FUNCTION

FUNCTION builtin_pos(args: Array<String>): String
    RETURN str(string.find(args[1], args[0]) + 1)
END FUNCTION

VAR using_lfsr: Boolean := FALSE
VAR random_seed: Number := 0

FUNCTION random_lfsr(): Number
    random_seed := (random_seed * 22695477 + 1) MOD 2^32
    RETURN random_seed INTDIV 2^16
END FUNCTION

FUNCTION builtin_random(args: Array<String>): String
    LET min: Number := (IF args.size() >= 1 AND args[0] <> "" THEN rxnum(args[0]) ELSE 0)
    LET max: Number := (IF args.size() >= 2 AND args[1] <> "" THEN rxnum(args[1]) ELSE 999)
    LET seed: Number := (IF args.size() >= 3 AND args[2] <> "" THEN rxnum(args[2]) ELSE 0)
    IF seed <> 0 THEN
        random_seed := seed
        using_lfsr := TRUE
    END IF
    IF using_lfsr THEN
        RETURN str(random_lfsr() MOD (max - min + 1) + min)
    ELSE
        RETURN str(random.uint32() MOD (max - min + 1) + min)
    END IF
END FUNCTION

FUNCTION builtin_sourceline(args: Array<String>): String
    RETURN sourcelines[rxnum(args[0])]
END FUNCTION

FUNCTION builtin_substr(args: Array<String>): String
    LET start: Number := rxnum(args[1])
    LET length: Number := rxnum(args[2])
    RETURN args[0][start-1 TO start-1+length-1]
END FUNCTION

VAR time_reset: Number := 0

FUNCTION builtin_time(args: Array<String>): String
    IF args[0] = "R" THEN
        LET now: Number := time.now()
        LET r: Number := now - time_reset
        time_reset := now
        RETURN str(r)
    ELSE
        ASSERT FALSE, args
        RETURN ""
    END IF
END FUNCTION

FUNCTION builtin_trace(args: Array<String>): String
    -- TODO
    RETURN ""
END FUNCTION

FUNCTION builtin_word(args: Array<String>): String
    RETURN string.split(args[0], " ")[rxnum(args[1])]
END FUNCTION

FUNCTION builtin_words(args: Array<String>): String
    RETURN str(string.split(args[0], " ").size())
END FUNCTION

VAR BuiltinFunctions: Dictionary<FUNCTION(args: Array<String>): String> := {
    "ADDRESS": builtin_address,
    "ARG": builtin_arg,
    "CENTER": builtin_center,
    "CENTRE": builtin_center,
    "CHAROUT": builtin_charout,
    "FORMAT": builtin_format,
    "LEFT": builtin_left,
    "LENGTH": builtin_length,
    "POS": builtin_pos,
    "RANDOM": builtin_random,
    "SOURCELINE": builtin_sourceline,
    "SUBSTR": builtin_substr,
    "TIME": builtin_time,
    "TRACE": builtin_trace,
    "WORD": builtin_word,
    "WORDS": builtin_words,
}

FUNCTION builtin_function(name: String, args: Array<String>): String
    IF name IN BuiltinFunctions THEN
        LET f: FUNCTION(args: Array<String>): String := BuiltinFunctions[name]
        RETURN f(args)
    END IF
    ASSERT FALSE, "unknown builtin function", name
    RETURN ""
END FUNCTION

FUNCTION get_function_arguments(tokens: Array<Token>, INOUT i: Number): Array<String>
    VAR r: Array<String> := []
    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value IN [")", ";"]) DO
        LET s: String := evaluate(tokens, INOUT i, [])
        r.append(s)
        IF tokens[i].type = TokenType.Special AND tokens[i].value = "," THEN
            INC i
        END IF
    END WHILE
    RETURN r
END FUNCTION

FUNCTION evaluate_term(tokens: Array<Token>, INOUT i: Number): String
    VAR r: String := ""
    CASE tokens[i].type
        WHEN TokenType.Var_symbol DO
            LET name: String := tokens[i].value
            INC i
            IF tokens[i].type = TokenType.Special AND tokens[i].value = "(" AND tokens[i].abuttal THEN
                INC i
                LET args: Array<String> := get_function_arguments(tokens, INOUT i)
                ASSERT tokens[i].type = TokenType.Special AND tokens[i].value = ")"
                INC i
                VAR lindex: Number
                IF find_label(source_tokens, name, OUT lindex) THEN
                    vars["SIGL"] := str(tokens[i].line)
                    contexts.append(ContextEntry(type WITH ContextType.call, call_tokens WITH tokens, call_return_ip WITH i, call_args WITH args))
                    r := interpret_function(source_tokens, lindex + 1)
                ELSE
                    r := builtin_function(name, args)
                END IF
            ELSE
                r := get_var(name)
            END IF
        WHEN TokenType.Const_symbol, TokenType.String DO
            r := tokens[i].value
            INC i
            IF tokens[i].type = TokenType.Special AND tokens[i].value = "(" AND tokens[i].abuttal THEN
                INC i
                LET args: Array<String> := get_function_arguments(tokens, INOUT i)
                ASSERT tokens[i].type = TokenType.Special AND tokens[i].value = ")"
                INC i
                r := builtin_function(r, args)
            END IF
        WHEN OTHERS DO
            -- Must be empty argument, as in: call charout , 'a'
    END CASE
    RETURN r
END FUNCTION

CONSTANT OperatorPrecedence: Dictionary<Number> := {
    "": -1,
    ")": -1,
    "(": 0,
    "&&": 1,
    "|": 2,
    "&": 3,
    "=": 4,
    "\\=": 4,
    "==": 4,
    "\\==": 4,
    "<": 4,
    "<=": 4,
    ">": 4,
    ">=": 4,
    "<>": 4,
    " ": 5,
    "||": 5,
    "+": 6,
    "-": 6,
    "*": 7,
    "/": 7,
    "%": 7,
    "//": 7,
    "**": 8,
    "negate": 9,
    "\\": 9,
}

FUNCTION evaluate(tokens: Array<Token>, INOUT i: Number, terminating_tokens: Array<String>): String
    --print("evaluate \(tokens[i].type) \(tokens[i].value)")
    VAR operand_stack: Array<String> := []
    VAR operator_stack: Array<String> := []
    VAR paren_depth: Number := 0

    FUNCTION pop_operand(): String
        VAR r: String := operand_stack[LAST]
        operand_stack.resize(operand_stack.size() - 1)
        RETURN r
    END FUNCTION

    FUNCTION push_operand(x: String)
        operand_stack.append(x)
    END FUNCTION

    FUNCTION pop_operator(): String
        VAR r: String := operator_stack[LAST]
        operator_stack.resize(operator_stack.size() - 1)
        RETURN r
    END FUNCTION

    FUNCTION resolve_stack(next_op: String)
        LET level: Number := OperatorPrecedence[next_op]
        WHILE operator_stack.size() > 0 AND level < OperatorPrecedence[operator_stack[LAST]] DO
            LET op: String := pop_operator()
            CASE op
                WHEN " " DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(x & " " & y)
                WHEN "&&" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF (num(x) <> 0) <> (num(y) <> 0) THEN "1" ELSE "0"))
                WHEN "|" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF num(x) <> 0 OR num(y) <> 0 THEN "1" ELSE "0"))
                WHEN "&" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF num(x) <> 0 AND num(y) <> 0 THEN "1" ELSE "0"))
                WHEN "||" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(x & y)
                WHEN "=" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF string.trim(x) = string.trim(y) THEN "1" ELSE "0"))
                WHEN "\\=", "<>" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF string.trim(x) <> string.trim(y) THEN "1" ELSE "0"))
                WHEN "==" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF x = y THEN "1" ELSE "0"))
                WHEN "\\==" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF x <> y THEN "1" ELSE "0"))
                WHEN "<" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    VAR a: Number
                    VAR b: Number
                    IF is_number(x, OUT a) AND is_number(y, OUT b) THEN
                        push_operand((IF a < b THEN "1" ELSE "0"))
                    ELSE
                        push_operand((IF x < y THEN "1" ELSE "0"))
                    END IF
                WHEN "<=" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    VAR a: Number
                    VAR b: Number
                    IF is_number(x, OUT a) AND is_number(y, OUT b) THEN
                        push_operand((IF a <= b THEN "1" ELSE "0"))
                    ELSE
                        push_operand((IF x <= y THEN "1" ELSE "0"))
                    END IF
                WHEN ">" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF rxnum(x) > rxnum(y) THEN "1" ELSE "0"))
                WHEN ">=" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    VAR a: Number
                    VAR b: Number
                    IF is_number(x, OUT a) AND is_number(y, OUT b) THEN
                        push_operand((IF a >= b THEN "1" ELSE "0"))
                    ELSE
                        push_operand((IF x >= y THEN "1" ELSE "0"))
                    END IF
                WHEN "+" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) + rxnum(y)))
                WHEN "-" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) - rxnum(y)))
                WHEN "*" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) * rxnum(y)))
                WHEN "/" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) / rxnum(y)))
                WHEN "%" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) INTDIV rxnum(y)))
                WHEN "//" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) MOD rxnum(y)))
                WHEN "**" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) ^ rxnum(y)))
                WHEN "negate" DO
                    LET x: String := pop_operand()
                    push_operand(str(-rxnum(x)))
                WHEN "\\" DO
                    LET x: String := pop_operand()
                    CASE x
                        WHEN "0" DO
                            push_operand("1")
                        WHEN "1" DO
                            push_operand("0")
                        WHEN OTHERS DO
                            RAISE SyntaxException
                    END CASE
                WHEN "(" DO
                    -- no operation
                WHEN OTHERS DO
                    ASSERT FALSE, "unimplemented operator", op
            END CASE
        END WHILE
    END FUNCTION

    VAR last_was_term: Boolean := FALSE
    LOOP
        --print("  eval \(tokens[i])")
        --print("    last_was_term \(last_was_term)")
        VAR this_is_term: Boolean := FALSE
        -- First check for binary operators.
        IF tokens[i].type = TokenType.Operator AND
           NOT (tokens[i].value = "\\") AND
           NOT (tokens[i].value IN ["+","-"] AND NOT last_was_term) THEN
            resolve_stack(tokens[i].value)
            operator_stack.append(tokens[i].value)
            INC i
        -- Check for closing parenthesis.
        ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = ")" AND paren_depth > 0 THEN
            DEC paren_depth
            resolve_stack(")")
            this_is_term := TRUE
            INC i
        -- Check for end of expression.
        ELSIF (tokens[i].type = TokenType.Special AND tokens[i].value <> "(") OR
              (paren_depth = 0 AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value IN terminating_tokens) THEN
            ASSERT paren_depth = 0
            resolve_stack("") -- end of expression
            EXIT LOOP
        ELSE
            IF last_was_term THEN
                -- Must be another term, add concatenation operator.
                IF tokens[i].abuttal THEN
                    resolve_stack("||")
                    operator_stack.append("||")
                ELSE
                    resolve_stack(" ")
                    operator_stack.append(" ")
                END IF
            END IF
            IF tokens[i].type = TokenType.Special AND tokens[i].value = "(" THEN
                INC paren_depth
                operator_stack.append("(")
                INC i
            ELSIF tokens[i].type = TokenType.Operator THEN
                IF tokens[i].value = "\\" THEN
                    operator_stack.append(tokens[i].value)
                ELSIF tokens[i].value = "-" AND NOT last_was_term THEN
                    operator_stack.append("negate")
                ELSIF tokens[i].value = "+" AND NOT last_was_term THEN
                    -- Unary + is no operation.
                ELSE
                    ASSERT FALSE, "binary operator should have been handled above"
                END IF
                INC i
            ELSE
                LET term: String := evaluate_term(tokens, INOUT i)
                operand_stack.append(term)
                this_is_term := TRUE
            END IF
        END IF
        --print("    operators \(operator_stack)")
        --print("    operands \(operand_stack)")
        last_was_term := this_is_term
    END LOOP
    IF operand_stack.size() = 0 THEN
        RETURN ""
    END IF
    RETURN operand_stack[FIRST]
END FUNCTION

FUNCTION skip_if_ncl(tokens: Array<Token>, INOUT i: Number)
    IF i < tokens.size() AND tokens[i].type = TokenType.Special AND tokens[i].value = ";" THEN
        INC i
    END IF
END FUNCTION

TYPE TemplateType IS ENUM
    placeholder
    target
    pattern
    positional
END ENUM

TYPE Template IS RECORD
    type: TemplateType
    target: String
    pattern: String
    position: Number
    position_relative: Boolean
END RECORD

FUNCTION Template.toString(self: Template): String
    CASE self.type
        WHEN TemplateType.placeholder DO
            RETURN "<\(self.type)>"
        WHEN TemplateType.target DO
            RETURN "<\(self.type):\(self.target)>"
        WHEN TemplateType.pattern DO
            RETURN "<\(self.type):\(self.pattern)>"
        WHEN TemplateType.positional DO
            RETURN "<\(self.type):\(self.position),\(self.position_relative)>"
    END CASE
END FUNCTION

FUNCTION do_parse(tokens: Array<Token>, INOUT i: Number, upper: Boolean)
    ASSERT tokens[i].type = TokenType.Var_symbol
    LET source: String := tokens[i].value
    INC i
    VAR input: Array<String> := []
    CASE source
        WHEN "ARG" DO
            input := contexts[LAST].call_args
        WHEN "PULL" DO
            input := [console.input("")]
        WHEN "SOURCE" DO
            input := ["Neon", "COMMAND", script_filename]
        WHEN "VALUE" DO
            input := [evaluate(tokens, INOUT i, ["WITH"])]
            IF NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WITH") THEN
                ASSERT FALSE, "WITH expected"
            END IF
            INC i
        WHEN "VAR" DO
            IF tokens[i].type = TokenType.Var_symbol THEN
                input := [get_var(tokens[i].value)]
                INC i
            ELSE
                ASSERT FALSE, "var not found"
            END IF
        WHEN "VERSION" DO
            input := ["neon", "1", "2020", "Sep", "22"]
        WHEN OTHERS DO
            ASSERT FALSE, "unknown parse source", source
    END CASE
    VAR template_list: Array<Array<Template>> := []
    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
        VAR template: Array<Template> := []
        WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
            IF tokens[i].type = TokenType.Var_symbol THEN
                template.append(Template(type WITH TemplateType.target, target WITH tokens[i].value))
                INC i
            ELSIF tokens[i].type = TokenType.String THEN
                template.append(Template(type WITH TemplateType.pattern, pattern WITH tokens[i].value))
                INC i
            ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = "(" THEN
                INC i
                LET sep: String := evaluate(tokens, INOUT i, [])
                ASSERT tokens[i].value = ")"
                INC i
                template.append(Template(type WITH TemplateType.pattern, pattern WITH sep))
            ELSIF tokens[i].type = TokenType.Const_symbol THEN
                IF tokens[i].value = "." THEN
                    template.append(Template(type WITH TemplateType.placeholder))
                ELSE
                    LET pos: Number := num(tokens[i].value)
                    template.append(Template(type WITH TemplateType.positional, position WITH pos, position_relative WITH pos < 0))
                END IF
                INC i
            ELSIF tokens[i].type = TokenType.Operator AND tokens[i].value = "+" THEN
                INC i
                ASSERT tokens[i].type = TokenType.Const_symbol
                template.append(Template(type WITH TemplateType.positional, position WITH num(tokens[i].value), position_relative WITH TRUE))
                INC i
            ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = "," THEN
                INC i
                EXIT WHILE
            ELSE
                ASSERT FALSE, "unexpected template token", tokens[i]
            END IF
        END WHILE
        --FOREACH t IN template DO print("\(t)") END FOREACH
        template_list.append(template)
    END WHILE
    FOREACH s IN input INDEX tli DO
        IF tli >= template_list.size() THEN
            EXIT FOREACH
        END IF
        LET ss: String := (IF upper THEN string.upper(s) ELSE s)
        LET template: Array<Template> := template_list[tli]
        VAR si: Number := 0
        VAR ti: Number := 0
        WHILE si < s.length() AND ti < template.size() DO
            LET t: Template := template[ti]
            --print("si=\(si) ti=\(ti) t=\(t)")
            WHILE si < s.length() AND s[si] = " " DO
                INC si
            END WHILE
            IF ti >= template.size()-1 THEN
                IF t.type = TemplateType.target THEN
                    set_var(t.target, (IF si < s.length() THEN s[si TO LAST] ELSE ""))
                END IF
                INC ti
                EXIT WHILE
            END IF
            CASE t.type
                WHEN TemplateType.placeholder, TemplateType.target DO
                    VAR next: Number := si
                    CASE template[ti+1].type
                        WHEN TemplateType.placeholder, TemplateType.target DO
                            IF t.type = TemplateType.target THEN
                                WHILE next < s.length() AND s[next] <> " " DO
                                    INC next
                                END WHILE
                            END IF
                        WHEN TemplateType.pattern DO
                            LET j: Number := string.find(s[next TO LAST], template[ti+1].pattern)
                            IF j >= 0 THEN
                                next := next + j
                            ELSE
                                next := s.length()
                            END IF
                        WHEN TemplateType.positional DO
                            IF template[ti+1].position_relative THEN
                                next := next + template[ti+1].position
                            ELSE
                                next := template[ti+1].position - 1
                            END IF
                            INC ti
                    END CASE
                    IF t.type = TemplateType.target THEN
                        IF next > si THEN
                            set_var(t.target, s[si TO next-1])
                        ELSE
                            set_var(t.target, s[si TO LAST])
                        END IF
                    END IF
                    si := next
                WHEN TemplateType.pattern DO
                    ASSERT s[si TO si+t.pattern.length()-1] = t.pattern
                    si := si + t.pattern.length()
                WHEN TemplateType.positional DO
                    IF t.position_relative THEN
                        si := si + t.position
                    ELSE
                        si := t.position - 1
                    END IF
            END CASE
            INC ti
        END WHILE
        WHILE ti < template.size() DO
            IF template[ti].type = TemplateType.target THEN
                set_var(template[ti].target, "")
            END IF
            INC ti
        END WHILE
    END FOREACH
END FUNCTION

FUNCTION skip_instruction(tokens: Array<Token>, INOUT i: Number)
    IF tokens[i].type = TokenType.Var_symbol THEN
        IF tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
            INC i
            WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
                INC i
            END WHILE
        ELSE
            CASE tokens[i].value
                WHEN "DO" DO
                    INC i
                    VAR do_var: String := ""
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
                        do_var := tokens[i].value
                    END IF
                    WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "END") DO
                        skip_instruction(tokens, INOUT i)
                    END WHILE
                    INC i
                    IF do_var <> "" AND tokens[i].type = TokenType.Var_symbol THEN
                        IF tokens[i].value = do_var THEN
                            INC i
                        ELSE
                            ASSERT FALSE, "mismatch loop var", tokens[i]
                        END IF
                    END IF
                WHEN "IF" DO
                    WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN") DO
                        INC i
                    END WHILE
                    INC i
                    skip_if_ncl(tokens, INOUT i)
                    skip_instruction(tokens, INOUT i)
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "ELSE" THEN
                        INC i
                        skip_if_ncl(tokens, INOUT i)
                        skip_instruction(tokens, INOUT i)
                    END IF
                WHEN "SELECT" DO
                    INC i
                    WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "END") DO
                        IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WHEN" THEN
                            WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN") DO
                                INC i
                            END WHILE
                            INC i
                        ELSE
                            skip_instruction(tokens, INOUT i)
                        END IF
                    END WHILE
                    INC i
                WHEN OTHERS DO
                    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
                        INC i
                    END WHILE
            END CASE
        END IF
    ELSE
        WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
            INC i
        END WHILE
    END IF
    skip_if_ncl(tokens, INOUT i)
END FUNCTION

FUNCTION do_check_terminate(tokens: Array<Token>, INOUT i: Number, INOUT context: ContextEntry): Boolean
    VAR rep: Number := context.do_rep
    IF rep > 0 THEN
        DEC rep
        IF rep <= 0 THEN
            RETURN TRUE
        END IF
        context.do_rep := rep
    END IF
    LET var: String := context.do_var
    IF var <> "" THEN
        LET newvar: Number := num(get_var(var)) + context.do_by
        IF context.do_bounded AND newvar > context.do_bounded_to THEN
            RETURN TRUE
        END IF
        set_var(var, str(newvar))
    END IF
    LET while: Number := context.do_while_condition
    IF while > 0 THEN
        i := context.do_while_condition
        LET cond: String := evaluate(tokens, INOUT i, [])
        IF cond = "0" THEN
            RETURN TRUE
        ELSIF cond <> "1" THEN
            ASSERT FALSE, "unexpected cond", cond
        END IF
    END IF
    RETURN FALSE
END FUNCTION

FUNCTION interpret_step(INOUT tokens: Array<Token>, INOUT i: Number): Boolean
    --VAR o: Object := vars print(o.toString())
    --print("interpret \(contexts.size()) \(tokens[i])")
    LET orig_i: Number := i
    CASE tokens[i].type
        WHEN TokenType.Label DO
            INC i
        WHEN TokenType.Special DO
            CASE tokens[i].value
                WHEN ";" DO
                    INC i
                WHEN OTHERS DO
                    ASSERT FALSE, "unexpected special token", tokens[i]
            END CASE
        WHEN TokenType.Var_symbol DO
            IF tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
                LET var: String := tokens[i].value
                i := i + 2
                LET s: String := evaluate(tokens, INOUT i, [])
                set_var(var, s)
                RETURN TRUE
            END IF
            CASE tokens[i].value
                WHEN "ADDRESS" DO
                    INC i
                    VAR target: String := tokens[i].value
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "VALUE" THEN
                        INC i
                        target := evaluate(tokens, INOUT i, ["WITH"])
                    END IF
                    -- TODO
                WHEN "ARG" DO
                    do_parse(tokens, INOUT i, upper WITH TRUE)
                WHEN "CALL" DO
                    INC i
                    IF tokens[i].type = TokenType.Var_symbol THEN
                        LET name: String := tokens[i].value
                        INC i
                        LET args: Array<String> := get_function_arguments(tokens, INOUT i)
                        VAR lindex: Number
                        IF find_label(source_tokens, name, OUT lindex) THEN
                            vars["SIGL"] := str(tokens[i].line)
                            contexts.append(ContextEntry(type WITH ContextType.call, call_tokens WITH tokens, call_return_ip WITH i, call_args WITH args))
                            tokens := source_tokens
                            i := lindex + 1
                        ELSE
                            vars["RESULT"] := builtin_function(name, args)
                        END IF
                    ELSE
                        ASSERT FALSE, "unexpected thing to call", tokens[i].type
                    END IF
                WHEN "DO" DO
                    VAR out_of_loop: Number := i
                    skip_instruction(tokens, INOUT out_of_loop)
                    INC i
                    IF tokens[i].type = TokenType.Special AND tokens[i].value = ";" THEN
                        contexts.append(ContextEntry(type WITH ContextType.do_single, do_skip WITH out_of_loop))
                    ELSE
                        VAR context: ContextEntry := ContextEntry(type WITH ContextType.do_repetitive, do_skip WITH out_of_loop, do_by WITH 1)
                        IF tokens[i].type = TokenType.Var_symbol AND tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
                            context.do_var := tokens[i].value
                            i := i + 2
                            set_var(context.do_var, evaluate(tokens, INOUT i, ["TO", "BY", "FOR", "WHILE", "UNTIL"]))
                            LOOP
                                IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "TO" THEN
                                    INC i
                                    context.do_bounded := TRUE
                                    context.do_bounded_to := num(evaluate(tokens, INOUT i, ["TO", "BY", "FOR", "WHILE", "UNTIL"]))
                                ELSIF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "BY" THEN
                                    INC i
                                    context.do_by := num(evaluate(tokens, INOUT i, ["TO", "BY", "FOR", "WHILE", "UNTIL"]))
                                ELSIF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "FOR" THEN
                                    INC i
                                    context.do_for := num(evaluate(tokens, INOUT i, ["TO", "BY", "FOR", "WHILE", "UNTIL"]))
                                ELSE
                                    EXIT LOOP
                                END IF
                            END LOOP
                        END IF
                        IF NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") THEN
                            IF NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value IN ["WHILE", "UNTIL"]) THEN
                                context.do_rep := num(evaluate(tokens, INOUT i, ["WHILE"]))
                                IF context.do_rep <= 0 THEN
                                    i := out_of_loop
                                END IF
                            END IF
                        END IF
                        IF i < tokens.size() AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WHILE" THEN
                            INC i
                            LET expr: Number := i
                            LET cond: String := evaluate(tokens, INOUT i, [])
                            CASE cond
                                WHEN "0" DO
                                    i := out_of_loop
                                WHEN "1" DO
                                    context.do_while_condition := expr
                                WHEN OTHERS DO
                                    ASSERT FALSE, "unexpected cond", cond
                            END CASE
                        END IF
                        IF i < out_of_loop THEN
                            context.do_top := i
                            contexts.append(context)
                        END IF
                    END IF
                WHEN "DROP" DO
                    INC i
                    LOOP
                        IF tokens[i].type = TokenType.Var_symbol THEN
                            -- TODO: need dictionary remove
                            -- vars.remove(tokens[i].value)
                            INC i
                        ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = "(" THEN
                            ASSERT FALSE, "indirect drop"
                        ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = ";" THEN
                            EXIT LOOP
                        ELSE
                            ASSERT FALSE, "unexpected thing to drop"
                        END IF
                    END LOOP
                WHEN "ELSE" DO
                    CASE contexts[LAST].type
                        WHEN ContextType.if DO
                            i := contexts[LAST].if_skip
                            contexts.resize(contexts.size() - 1)
                        WHEN OTHERS DO
                            ASSERT FALSE, "else found when not in if", contexts[LAST].type
                    END CASE
                WHEN "END" DO
                    --print("END context \(contexts[LAST].type)")
                    CASE contexts[LAST].type
                        WHEN ContextType.do_single DO
                            INC i
                            contexts.resize(contexts.size() - 1)
                        WHEN ContextType.do_repetitive DO
                            IF do_check_terminate(tokens, INOUT i, INOUT contexts[LAST]) THEN
                                i := contexts[LAST].do_skip
                                contexts.resize(contexts.size() - 1)
                            ELSE
                                i := contexts[LAST].do_top
                            END IF
                        WHEN ContextType.select DO
                            INC i
                            contexts.resize(contexts.size() - 1)
                        WHEN OTHERS DO
                            ASSERT FALSE, "end found for no reason", contexts[LAST].type
                    END CASE
                WHEN "EXIT" DO
                    INC i
                    VAR r: String := "0"
                    IF NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") THEN
                        r := evaluate(tokens, INOUT i, [])
                    END IF
                    sys.exit(rxnum(r))
                WHEN "IF" DO
                    INC i
                    LET cond: String := evaluate(tokens, INOUT i, ["THEN"])
                    ASSERT tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN"
                    INC i
                    skip_if_ncl(tokens, INOUT i)
                    CASE cond
                        WHEN "1" DO
                            VAR else: Number := i
                            skip_instruction(tokens, INOUT else)
                            IF else < tokens.size() AND tokens[else].type = TokenType.Var_symbol AND tokens[else].value = "ELSE" THEN
                                VAR skip: Number := else + 1
                                skip_instruction(tokens, INOUT skip)
                                contexts.append(ContextEntry(type WITH ContextType.if, if_skip WITH skip))
                            END IF
                        WHEN "0" DO
                            skip_instruction(tokens, INOUT i)
                            IF i < tokens.size() AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "ELSE" THEN
                                INC i
                            END IF
                        WHEN OTHERS DO
                            ASSERT FALSE, "unexpected cond", cond
                    END CASE
                WHEN "INTERPRET" DO
                    INC i
                    LET expr: String := evaluate(tokens, INOUT i, [])
                    LET itokens: Array<Token> := tokenise(expr) & [Token(type WITH TokenType.Special, value WITH ";"), Token(type WITH TokenType.Eos)]
                    contexts.append(ContextEntry(type WITH ContextType.call, call_tokens WITH tokens, call_return_ip WITH i))
                    tokens := itokens
                    i := 0
                WHEN "ITERATE" DO
                    WHILE contexts.size() > 0 AND contexts[LAST].type <> ContextType.do_repetitive DO
                        contexts.resize(contexts.size() - 1)
                    END WHILE
                    IF do_check_terminate(tokens, INOUT i, INOUT contexts[LAST]) THEN
                        i := contexts[LAST].do_skip
                        contexts.resize(contexts.size() - 1)
                    ELSE
                        i := contexts[LAST].do_top
                    END IF
                WHEN "LEAVE" DO
                    WHILE contexts.size() > 0 AND contexts[LAST].type <> ContextType.do_repetitive DO
                        contexts.resize(contexts.size() - 1)
                    END WHILE
                    i := contexts[LAST].do_skip
                    contexts.resize(contexts.size() - 1)
                WHEN "NOP" DO
                    INC i
                    -- No operation.
                WHEN "OPTIONS" DO
                    INC i
                    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
                        INC i
                    END WHILE
                WHEN "OTHERWISE" DO
                    CASE contexts[LAST].type
                        WHEN ContextType.select DO
                            i := contexts[LAST].select_skip
                            contexts.resize(contexts.size() - 1)
                        WHEN OTHERS DO
                            ASSERT FALSE, "unexpected otherwise", contexts[LAST].type
                    END CASE
                WHEN "PARSE" DO
                    INC i
                    LET upper: Boolean := tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "UPPER"
                    IF upper THEN
                        INC i
                    END IF
                    do_parse(tokens, INOUT i, upper)
                WHEN "PROCEDURE" DO
                    INC i
                    VAR expose: Array<String> := []
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "EXPOSE" THEN
                        INC i
                        WHILE tokens[i].type = TokenType.Var_symbol DO
                            expose.append(tokens[i].value)
                            INC i
                        END WHILE
                    END IF
                    contexts[LAST].call_is_procedure := TRUE
                    contexts[LAST].call_vars := vars
                    contexts[LAST].call_arrays := arrays
                    vars := {}
                    arrays := {}
                WHEN "PULL" DO
                    do_parse(tokens, INOUT i, upper WITH TRUE)
                WHEN "RETURN" DO
                    INC i
                    WHILE contexts.size() > 0 AND contexts[LAST].type <> ContextType.call DO
                        contexts.resize(contexts.size() - 1)
                    END WHILE
                    ASSERT contexts.size() > 0, "unexpected return"
                    -- TODO: expression is optional
                    LET r: String := evaluate(tokens, INOUT i, [])
                    tokens := contexts[LAST].call_tokens
                    i := contexts[LAST].call_return_ip
                    IF contexts[LAST].call_is_procedure THEN
                        vars := contexts[LAST].call_vars
                        arrays := contexts[LAST].call_arrays
                    END IF
                    vars["RESULT"] := r
                    contexts.resize(contexts.size() - 1)
                WHEN "SAY" DO
                    INC i
                    IF NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") THEN
                        LET s: String := evaluate(tokens, INOUT i, [])
                        print(s)
                    ELSE
                        INC i
                        print("")
                    END IF
                WHEN "SELECT" DO
                    VAR end_of_select: Number := i
                    skip_instruction(tokens, INOUT end_of_select)
                    INC i
                    skip_if_ncl(tokens, INOUT i)
                    VAR found: Boolean := FALSE
                    WHILE tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WHEN" DO
                        INC i
                        LET cond: String := evaluate(tokens, INOUT i, ["THEN"])
                        ASSERT tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN"
                        INC i
                        skip_if_ncl(tokens, INOUT i)
                        IF cond = "1" THEN
                            contexts.append(ContextEntry(type WITH ContextType.select, select_skip WITH end_of_select))
                            found := TRUE
                            EXIT WHILE
                        ELSIF cond = "0" THEN
                            skip_instruction(tokens, INOUT i)
                        ELSE
                            ASSERT FALSE, "unexpected cond", cond
                        END IF
                    END WHILE
                    IF NOT found AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "OTHERWISE" THEN
                        INC i
                    END IF
                WHEN "SIGNAL" DO
                    INC i
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "ON" THEN
                        INC i
                        IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value IN ["NOVALUE","SYNTAX"] THEN
                            LET signal: String := tokens[i].value
                            VAR label: String := signal
                            INC i
                            IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "NAME" THEN
                                INC i
                                IF tokens[i].type = TokenType.Var_symbol THEN
                                    label := tokens[i].value
                                    INC i
                                ELSE
                                    ASSERT FALSE, "label expected", tokens[i]
                                END IF
                            END IF
                            signals[signal] := label
                        ELSE
                            ASSERT FALSE, "unknown signal type", tokens[i]
                        END IF
                    ELSE
                        LET name: String := tokens[i].value
                        INC i
                        VAR lindex: Number
                        IF find_label(source_tokens, name, OUT lindex) THEN
                            vars["SIGL"] := str(tokens[i].line)
                            tokens := source_tokens
                            i := lindex + 1
                        ELSE
                            ASSERT FALSE, "signal label not found"
                        END IF
                    END IF
                WHEN "TRACE" DO
                    INC i
                    VAR setting: String := tokens[i].value
                    INC i
                    CASE setting
                        WHEN "OFF" DO
                            -- No action
                        WHEN "VALUE" DO
                            setting := evaluate(tokens, INOUT i, [])
                    END CASE
                    -- TODO: trace setting
                WHEN "WHEN" DO
                    CASE contexts[LAST].type
                        WHEN ContextType.select DO
                            i := contexts[LAST].select_skip
                            contexts.resize(contexts.size() - 1)
                        WHEN OTHERS DO
                            ASSERT FALSE, "unexpected when", contexts[LAST].type
                    END CASE
                WHEN OTHERS DO
                    LET r: String := evaluate(tokens, INOUT i, [])
                    vars["RC"] := str(os.system(r))
            END CASE
        WHEN TokenType.Eos DO
            CASE contexts[LAST].type
                WHEN ContextType.call DO
                    tokens := contexts[LAST].call_tokens
                    i := contexts[LAST].call_return_ip
                    contexts.resize(contexts.size() - 1)
                WHEN OTHERS DO
                    RETURN FALSE
            END CASE
        WHEN OTHERS DO
            IF tokens[i].type = TokenType.Const_symbol AND tokens[i+1].type = TokenType.Operator AND tokens[i+1].value IN ["=","=="] THEN
                RAISE SyntaxException
            END IF
            LET r: String := evaluate(tokens, INOUT i, [])
            vars["RC"] := str(os.system(r))
    END CASE
    IF i = orig_i THEN
        ASSERT FALSE, "we are stuck", tokens[i]
    END IF
    skip_if_ncl(tokens, INOUT i)
    RETURN TRUE
END FUNCTION

FUNCTION interpret_function(start_tokens: Array<Token>, start_i: Number): String
    VAR tokens: Array<Token> := start_tokens
    VAR i: Number := start_i
    LET context_depth: Number := contexts.size()
    WHILE contexts.size() >= context_depth DO
        IF NOT interpret_step(INOUT tokens, INOUT i) THEN
            EXIT WHILE
        END IF
    END WHILE
    RETURN vars["RESULT"]
END FUNCTION

FUNCTION interpret()
    VAR tokens: Array<Token> := source_tokens
    VAR i: Number := 0
    WHILE i < tokens.size() DO
        TRY
            IF NOT interpret_step(INOUT tokens, INOUT i) THEN
                EXIT WHILE
            END IF
        TRAP SyntaxException DO
            VAR lindex: Number
            IF find_label(source_tokens, signals["SYNTAX"], OUT lindex) THEN
                vars["SIGL"] := str(tokens[i].line)
                contexts := []
                tokens := source_tokens
                i := lindex + 1
                -- TODO: pop contexts and restore vars/arrays
            ELSE
                ASSERT FALSE, "syntax label not found", tokens[i]
            END IF
        END TRY
    END WHILE
END FUNCTION

BEGIN MAIN
    script_filename := sys.args[1]
    LET bytes: Bytes := file.readBytes(script_filename)
    LET source: String := bytes.decodeToString()
    sourcelines := [""] & string.splitLines(source)
    source_tokens := tokenise(source)
    --FOREACH t IN source_tokens INDEX i DO
    --    print("\(i) \(t.type) \(t.value)")
    --END FOREACH
    contexts.append(ContextEntry(call_return_ip WITH -1, call_args WITH [string.join(sys.args[2 TO LAST], " ")]))
    interpret()
    ASSERT contexts.size() = 1
END MAIN
