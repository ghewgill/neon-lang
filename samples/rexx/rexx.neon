IMPORT console
IMPORT file
IMPORT io
IMPORT os
IMPORT random
IMPORT string
IMPORT sys

EXCEPTION SyntaxException

TYPE TokenType IS ENUM
    Label
    Special
    Var_symbol
    Const_symbol
    String
    Operator
    Blank
    Eos
END ENUM

TYPE Token IS RECORD
    line: Number
    type: TokenType
    abuttal: Boolean
    value: String
END RECORD

FUNCTION Token.toString(self: Token): String
    RETURN "<\(self.line):\(self.type):\(self.value)>"
END FUNCTION

TYPE ContextType IS ENUM
    call
    do_single
    do_repetitive
    if
    select
END ENUM

TYPE ContextEntry IS RECORD
    type: ContextType
    call_tokens: Array<Token>
    call_return_ip: Number
    call_args: Array<String>
    do_skip: Number
    do_top: Number
    do_var: String
    do_bounded: Boolean
    do_bounded_to: Number
    do_by: Number
    do_for: Number
    do_rep: Number
    do_while_condition: Number
    if_skip: Number
    select_skip: Number
END RECORD

VAR script_filename: String
VAR sourcelines: Array<String>
VAR source_tokens: Array<Token>
VAR vars: Dictionary<String>
VAR arrays: Dictionary<Dictionary<String>>
VAR contexts: Array<ContextEntry>
VAR signals: Dictionary<String> := {
    "SYNTAX": "SYNTAX",
}

FUNCTION is_digit(c: String): Boolean
    RETURN "0" <= c <= "9"
END FUNCTION

FUNCTION is_general_letter(c: String): Boolean
    RETURN "A" <= c <= "Z" OR
           "a" <= c <= "z" OR
           c IN ["_", "!", "?"]
END FUNCTION

FUNCTION is_var_symbol_char(c: String): Boolean
    RETURN is_general_letter(c) OR is_digit(c) OR c = "."
END FUNCTION

FUNCTION convert_binary_string(s: String): String
    CONSTANT Digits: String := "01"
    VAR i: Number := s.length()
    IF i = 0 THEN
        RETURN ""
    END IF
    DEC i
    VAR r: String := ""
    VAR b: Number := 0
    VAR bit: Number := 0b1
    LOOP
        IF i < 0 OR s[i] NOT IN Digits THEN
            RAISE SyntaxException
        END IF
        b := b + string.find(Digits, s[i]) * bit
        bit := bit * 2
        DEC i
        FOR z := 2 TO 4 DO
            IF i < 0 THEN
                -- Ignore missing leading digit.
                EXIT FOR
            ELSIF s[i] NOT IN Digits THEN
                RAISE SyntaxException
            ELSE
                b := b + string.find(Digits, s[i]) * bit
                bit := bit * 2
                DEC i
            END IF
        END FOR
        IF i < 0 OR bit >= 0x100 THEN
            r := string.fromCodePoint(b) & r
            b := 0
            bit := 0b1
        END IF
        IF i < 0 THEN
            EXIT LOOP
        END IF
        WHILE i >= 0 AND s[i] = " " DO
            DEC i
        END WHILE
    END LOOP
    RETURN r
END FUNCTION

FUNCTION convert_hex_string(s: String): String
    CONSTANT Digits: String := "0123456789ABCDEF"
    LET t: String := string.upper(s)
    VAR i: Number := t.length()
    IF i = 0 THEN
        RETURN ""
    END IF
    DEC i
    VAR r: String := ""
    LOOP
        IF i < 0 OR t[i] NOT IN Digits THEN
            RAISE SyntaxException
        END IF
        VAR b: Number := string.find(Digits, t[i])
        DEC i
        IF i < 0 THEN
            -- Ignore missing leading digit.
        ELSIF t[i] NOT IN Digits THEN
            RAISE SyntaxException
        ELSE
            b := b + string.find(Digits, t[i]) * 0x10
            DEC i
        END IF
        r := string.fromCodePoint(b) & r
        IF i < 0 THEN
            EXIT LOOP
        END IF
        WHILE i >= 0 AND t[i] = " " DO
            DEC i
        END WHILE
    END LOOP
    RETURN r
END FUNCTION

FUNCTION tokenise(source: String): Array<Token>
    VAR tokens: Array<Token> := []
    VAR line: Number := 1
    VAR i: Number := 0
    VAR last_was_space: Boolean := FALSE
    WHILE i < source.length() DO
        VAR t: Token := Token()
        t.line := line
        t.abuttal := NOT last_was_space
        last_was_space := FALSE
        IF source[i] IN [",", ":", ";", ")", "("] THEN
            t.type := TokenType.Special
            t.value := source[i]
            tokens.append(t)
            INC i
        ELSIF source[i] = "\n" THEN
            IF tokens.size() > 0 AND tokens[LAST].type = TokenType.Special AND tokens[LAST].value = "," THEN
                -- Comma continuation, delete last token.
                tokens.resize(tokens.size() - 1)
                last_was_space := TRUE
            ELSE
                t.type := TokenType.Special
                t.value := ";"
                tokens.append(t)
            END IF
            INC i
            INC line
        ELSIF is_general_letter(source[i]) THEN
            t.type := TokenType.Var_symbol
            WHILE i < source.length() AND is_var_symbol_char(source[i]) DO
                t.value.append(source[i])
                INC i
            END WHILE
            t.value := string.upper(t.value)
            IF i < source.length() AND source[i] = ":" THEN
                t.type := TokenType.Label
                INC i
            END IF
            tokens.append(t)
        ELSIF is_digit(source[i]) OR source[i] = "." THEN
            t.type := TokenType.Const_symbol
            WHILE i < source.length() DO
                IF is_var_symbol_char(source[i]) THEN
                    t.value.append(source[i])
                    INC i
                ELSIF source[i] IN ["E","e"] AND source[i+1] IN ["+","-"] THEN
                    t.value.append(source[i TO i+1])
                    i := i + 2
                ELSE
                    EXIT WHILE
                END IF
            END WHILE
            tokens.append(t)
        ELSIF source[i] IN ["'", "\""] THEN
            LET delim: String := source[i]
            INC i
            t.type := TokenType.String
            LOOP
                IF source[i] = delim THEN
                    IF i+1 < source.length() AND source[i+1] = delim THEN
                        t.value.append(delim)
                        i := i + 2
                    ELSE
                        EXIT LOOP
                    END IF
                ELSE
                    t.value.append(source[i])
                    INC i
                END IF
            END LOOP
            INC i
            IF i < source.length() AND source[i] IN ["B", "b"] AND NOT is_var_symbol_char(source[i+1]) THEN
                t.type := TokenType.String
                t.value := convert_binary_string(t.value)
                INC i
            ELSIF i < source.length() AND source[i] IN ["X", "x"] AND NOT is_var_symbol_char(source[i+1]) THEN
                t.type := TokenType.String
                t.value := convert_hex_string(t.value)
                INC i
            END IF
            tokens.append(t)
        ELSIF source[i] IN ["+", "-", "%", "|", "&", "=", "\\", "^", ">", "<", "/", "*"] THEN
            IF source[i] = "/" AND source[i+1] = "*" THEN
                VAR level: Number := 0
                REPEAT
                    IF source[i] = "/" AND source[i+1] = "*" THEN
                        INC level
                        i := i + 2
                    ELSIF source[i] = "*" AND source[i+1] = "/" THEN
                        DEC level
                        i := i + 2
                    ELSIF source[i] = "\n" THEN
                        INC line
                        INC i
                    ELSE
                        INC i
                    END IF
                UNTIL level = 0
            ELSE
                t.type := TokenType.Operator
                CASE source[i]
                    WHEN "|" DO
                        CASE source[i+1]
                            WHEN "|" DO
                                t.value := "||"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "|"
                        END CASE
                    WHEN "/" DO
                        CASE source[i+1]
                            WHEN "/" DO
                                t.value := "//"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "/"
                        END CASE
                    WHEN "*" DO
                        CASE source[i+1]
                            WHEN "*" DO
                                t.value := "**"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "*"
                        END CASE
                    WHEN "\\", "^" DO
                        CASE source[i+1]
                            WHEN "=" DO
                                CASE source[i+2]
                                    WHEN "=" DO
                                        t.value := "\\=="
                                        i := i + 2
                                    WHEN OTHERS DO
                                        t.value := "\\="
                                        i := i + 1
                                END CASE
                            WHEN "<" DO
                                ASSERT FALSE, "unimplemented <"
                            WHEN ">" DO
                                ASSERT FALSE, "unimplemented >"
                            WHEN OTHERS DO
                                t.value := "\\"
                        END CASE
                    WHEN ">" DO
                        CASE source[i+1]
                            WHEN "<" DO
                                t.value := "><"
                                i := i + 1
                            WHEN ">" DO
                                CASE source[i+2]
                                    WHEN "=" DO
                                        t.value := ">>="
                                        i := i + 2
                                    WHEN OTHERS DO
                                        t.value := ">>"
                                        i := i + 1
                                END CASE
                            WHEN "=" DO
                                t.value := ">="
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := ">"
                        END CASE
                    WHEN "<" DO
                        CASE source[i+1]
                            WHEN ">" DO
                                t.value := "<>"
                                i := i + 1
                            WHEN "<" DO
                                CASE source[i+2]
                                    WHEN "=" DO
                                        t.value := "<<="
                                        i := i + 2
                                    WHEN OTHERS DO
                                        t.value := "<<"
                                        i := i + 1
                                END CASE
                            WHEN "=" DO
                                t.value := "<="
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "<"
                        END CASE
                    WHEN "=" DO
                        CASE source[i+1]
                            WHEN "=" DO
                                t.value := "=="
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "="
                        END CASE
                    WHEN "&" DO
                        CASE source[i+1]
                            WHEN "&" DO
                                t.value := "&&"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "&"
                        END CASE
                    WHEN OTHERS DO
                        t.value := source[i]
                END CASE
                tokens.append(t)
                INC i
            END IF
        ELSIF source[i] IN [" "] THEN
            INC i
            last_was_space := TRUE
        ELSE
            ASSERT FALSE, "unexpected character", source[i]
        END IF
    END WHILE
    RETURN tokens
END FUNCTION

FUNCTION get_var(name: String): String
    LET dot: Number := string.find(name, ".")
    IF dot < 0 OR dot = name.length() - 1 THEN
        IF name NOT IN vars THEN
            RETURN name
        END IF
        RETURN vars[name]
    END IF
    LET stem: String := name[FIRST TO dot]
    VAR items: Array<String> := string.split(name[dot+1 TO LAST], ".")
    FOR i := 0 TO items.size() - 1 DO
        items[i] := get_var(items[i])
    END FOR
    LET tail: String := string.join(items, ".")
    IF stem NOT IN arrays THEN
        RETURN stem & tail
    END IF
    IF tail NOT IN arrays[stem] THEN
        IF stem IN vars THEN
            RETURN vars[stem]
        END IF
        RETURN stem & tail
    END IF
    RETURN arrays[stem][tail]
END FUNCTION

FUNCTION set_var(name: String, value: String)
    LET dot: Number := string.find(name, ".")
    IF dot < 0 OR dot = name.length() - 1 THEN
        vars[name] := value
        EXIT FUNCTION
    END IF
    LET stem: String := name[FIRST TO dot]
    VAR items: Array<String> := string.split(name[dot+1 TO LAST], ".")
    FOR i := 0 TO items.size() - 1 DO
        items[i] := get_var(items[i])
    END FOR
    LET tail: String := string.join(items, ".")
    arrays[stem][tail] := value
END FUNCTION

FUNCTION is_number(s: String, OUT n: Number): Boolean
    n := 0
    TRY
        n := num(s)
        RETURN TRUE
    TRAP ValueRangeException DO
        RETURN FALSE
    END TRY
END FUNCTION

FUNCTION rxnum(s: String): Number
    TRY
        VAR t: String := s
        t := string.trim(s)
        IF string.hasPrefix(t, ".") THEN
            t := "0" & t
        END IF
        RETURN num(t)
    TRAP ValueRangeException DO
        --print("not a number: <\(s)>")
        RAISE SyntaxException
    END TRY
END FUNCTION

FUNCTION find_label(tokens: Array<Token>, label: String, OUT index: Number): Boolean
    index := -1
    FOREACH t IN tokens INDEX ti DO
        IF t.type = TokenType.Label AND t.value = label THEN
            index := ti
            RETURN TRUE
        END IF
    END FOREACH
    RETURN FALSE
END FUNCTION

VAR using_lfsr: Boolean := FALSE
VAR random_seed: Number := 0

FUNCTION random_lfsr(): Number
    random_seed := (random_seed * 22695477 + 1) MOD 2^32
    RETURN random_seed INTDIV 2^16
END FUNCTION

FUNCTION builtin_function(name: String, args: Array<String>): String
    CASE name
        WHEN "ARG" DO
            RETURN contexts[LAST].call_args[num(args[0]) - 1]
        WHEN "CHAROUT" DO
            IF args[0] = "" THEN
                io.write(io.stdout, args[1])
                io.flush(io.stdout)
                RETURN str(args[1].length())
            ELSE
                ASSERT FALSE, "charout only to stdout", args
            END IF
        WHEN "LENGTH" DO
            RETURN str(args[0].length())
        WHEN "POS" DO
            RETURN str(string.find(args[1], args[0]) + 1)
        WHEN "RANDOM" DO
            LET min: Number := (IF args.size() >= 1 AND args[0] <> "" THEN rxnum(args[0]) ELSE 0)
            LET max: Number := (IF args.size() >= 2 AND args[1] <> "" THEN rxnum(args[1]) ELSE 999)
            LET seed: Number := (IF args.size() >= 3 AND args[2] <> "" THEN rxnum(args[2]) ELSE 0)
            IF seed <> 0 THEN
                random_seed := seed
                using_lfsr := TRUE
            END IF
            IF using_lfsr THEN
                RETURN str(random_lfsr() MOD (max - min + 1) + min)
            ELSE
                RETURN str(random.uint32() MOD (max - min + 1) + min)
            END IF
        WHEN "SOURCELINE" DO
            RETURN sourcelines[rxnum(args[0])]
        WHEN "WORDS" DO
            RETURN str(string.split(args[0], " ").size())
    END CASE
    ASSERT FALSE, "unknown builtin function", name
    RETURN ""
END FUNCTION

FUNCTION get_function_arguments(tokens: Array<Token>, INOUT i: Number): Array<String>
    VAR r: Array<String> := []
    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value IN [")", ";"]) DO
        LET s: String := evaluate(tokens, INOUT i, [])
        r.append(s)
        IF tokens[i].type = TokenType.Special AND tokens[i].value = "," THEN
            INC i
        END IF
    END WHILE
    RETURN r
END FUNCTION

FUNCTION evaluate_term(tokens: Array<Token>, INOUT i: Number): String
    VAR r: String := ""
    CASE tokens[i].type
        WHEN TokenType.Var_symbol DO
            LET name: String := tokens[i].value
            INC i
            IF tokens[i].type = TokenType.Special AND tokens[i].value = "(" AND tokens[i].abuttal THEN
                INC i
                LET args: Array<String> := get_function_arguments(tokens, INOUT i)
                ASSERT tokens[i].type = TokenType.Special AND tokens[i].value = ")"
                INC i
                VAR lindex: Number
                IF find_label(source_tokens, name, OUT lindex) THEN
                    vars["SIGL"] := str(tokens[i].line)
                    contexts.append(ContextEntry(type WITH ContextType.call, call_tokens WITH tokens, call_return_ip WITH i, call_args WITH args))
                    r := interpret_function(source_tokens, lindex + 1)
                ELSE
                    r := builtin_function(name, args)
                END IF
            ELSE
                r := get_var(name)
            END IF
        WHEN TokenType.Const_symbol, TokenType.String DO
            r := tokens[i].value
            INC i
            IF tokens[i].type = TokenType.Special AND tokens[i].value = "(" AND tokens[i].abuttal THEN
                INC i
                LET args: Array<String> := get_function_arguments(tokens, INOUT i)
                ASSERT tokens[i].type = TokenType.Special AND tokens[i].value = ")"
                INC i
                r := builtin_function(r, args)
            END IF
        WHEN OTHERS DO
            -- Must be empty argument, as in: call charout , 'a'
    END CASE
    RETURN r
END FUNCTION

CONSTANT OperatorPrecedence: Dictionary<Number> := {
    "": -1,
    ")": -1,
    "(": 0,
    "&&": 1,
    "|": 2,
    "&": 3,
    "=": 4,
    "\\=": 4,
    "==": 4,
    "\\==": 4,
    "<": 4,
    "<=": 4,
    ">": 4,
    ">=": 4,
    "<>": 4,
    " ": 5,
    "||": 5,
    "+": 6,
    "-": 6,
    "*": 7,
    "/": 7,
    "%": 7,
    "//": 7,
    "**": 8,
    "negate": 9,
    "\\": 9,
}

FUNCTION evaluate(tokens: Array<Token>, INOUT i: Number, terminating_tokens: Array<String>): String
    --print("evaluate \(tokens[i].type) \(tokens[i].value)")
    VAR operand_stack: Array<String> := []
    VAR operator_stack: Array<String> := []
    VAR paren_depth: Number := 0

    FUNCTION pop_operand(): String
        VAR r: String := operand_stack[LAST]
        operand_stack.resize(operand_stack.size() - 1)
        RETURN r
    END FUNCTION

    FUNCTION push_operand(x: String)
        operand_stack.append(x)
    END FUNCTION

    FUNCTION pop_operator(): String
        VAR r: String := operator_stack[LAST]
        operator_stack.resize(operator_stack.size() - 1)
        RETURN r
    END FUNCTION

    FUNCTION resolve_stack(next_op: String)
        LET level: Number := OperatorPrecedence[next_op]
        WHILE operator_stack.size() > 0 AND level < OperatorPrecedence[operator_stack[LAST]] DO
            LET op: String := pop_operator()
            CASE op
                WHEN " " DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(x & " " & y)
                WHEN "&&" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF (num(x) <> 0) <> (num(y) <> 0) THEN "1" ELSE "0"))
                WHEN "|" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF num(x) <> 0 OR num(y) <> 0 THEN "1" ELSE "0"))
                WHEN "&" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF num(x) <> 0 AND num(y) <> 0 THEN "1" ELSE "0"))
                WHEN "||" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(x & y)
                WHEN "=" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF string.trim(x) = string.trim(y) THEN "1" ELSE "0"))
                WHEN "\\=", "<>" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF string.trim(x) <> string.trim(y) THEN "1" ELSE "0"))
                WHEN "==" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF x = y THEN "1" ELSE "0"))
                WHEN "\\==" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF x <> y THEN "1" ELSE "0"))
                WHEN "<" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    VAR a: Number
                    VAR b: Number
                    IF is_number(x, OUT a) AND is_number(y, OUT b) THEN
                        push_operand((IF a < b THEN "1" ELSE "0"))
                    ELSE
                        push_operand((IF x < y THEN "1" ELSE "0"))
                    END IF
                WHEN "<=" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    VAR a: Number
                    VAR b: Number
                    IF is_number(x, OUT a) AND is_number(y, OUT b) THEN
                        push_operand((IF a <= b THEN "1" ELSE "0"))
                    ELSE
                        push_operand((IF x <= y THEN "1" ELSE "0"))
                    END IF
                WHEN ">" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand((IF rxnum(x) > rxnum(y) THEN "1" ELSE "0"))
                WHEN ">=" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    VAR a: Number
                    VAR b: Number
                    IF is_number(x, OUT a) AND is_number(y, OUT b) THEN
                        push_operand((IF a >= b THEN "1" ELSE "0"))
                    ELSE
                        push_operand((IF x >= y THEN "1" ELSE "0"))
                    END IF
                WHEN "+" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) + rxnum(y)))
                WHEN "-" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) - rxnum(y)))
                WHEN "*" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) * rxnum(y)))
                WHEN "/" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) / rxnum(y)))
                WHEN "%" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) INTDIV rxnum(y)))
                WHEN "//" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) MOD rxnum(y)))
                WHEN "**" DO
                    LET y: String := pop_operand()
                    LET x: String := pop_operand()
                    push_operand(str(rxnum(x) ^ rxnum(y)))
                WHEN "negate" DO
                    LET x: String := pop_operand()
                    push_operand(str(-rxnum(x)))
                WHEN "\\" DO
                    LET x: String := pop_operand()
                    CASE x
                        WHEN "0" DO
                            push_operand("1")
                        WHEN "1" DO
                            push_operand("0")
                        WHEN OTHERS DO
                            RAISE SyntaxException
                    END CASE
                WHEN "(" DO
                    -- no operation
                WHEN OTHERS DO
                    ASSERT FALSE, "unimplemented operator", op
            END CASE
        END WHILE
    END FUNCTION

    VAR last_was_term: Boolean := FALSE
    LOOP
        --print("  eval \(tokens[i])")
        --print("    last_was_term \(last_was_term)")
        VAR this_is_term: Boolean := FALSE
        -- First check for binary operators.
        IF tokens[i].type = TokenType.Operator AND
           NOT (tokens[i].value = "\\") AND
           NOT (tokens[i].value IN ["+","-"] AND NOT last_was_term) THEN
            resolve_stack(tokens[i].value)
            operator_stack.append(tokens[i].value)
            INC i
        -- Check for closing parenthesis.
        ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = ")" AND paren_depth > 0 THEN
            DEC paren_depth
            resolve_stack(")")
            this_is_term := TRUE
            INC i
        -- Check for end of expression.
        ELSIF (tokens[i].type = TokenType.Special AND tokens[i].value <> "(") OR
              (paren_depth = 0 AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value IN terminating_tokens) THEN
            ASSERT paren_depth = 0
            resolve_stack("") -- end of expression
            EXIT LOOP
        ELSE
            IF last_was_term THEN
                -- Must be another term, add concatenation operator.
                IF tokens[i].abuttal THEN
                    resolve_stack("||")
                    operator_stack.append("||")
                ELSE
                    resolve_stack(" ")
                    operator_stack.append(" ")
                END IF
            END IF
            IF tokens[i].type = TokenType.Special AND tokens[i].value = "(" THEN
                INC paren_depth
                operator_stack.append("(")
                INC i
            ELSIF tokens[i].type = TokenType.Operator THEN
                IF tokens[i].value = "\\" THEN
                    operator_stack.append(tokens[i].value)
                ELSIF tokens[i].value = "-" AND NOT last_was_term THEN
                    operator_stack.append("negate")
                ELSIF tokens[i].value = "+" AND NOT last_was_term THEN
                    -- Unary + is no operation.
                ELSE
                    ASSERT FALSE, "binary operator should have been handled above"
                END IF
                INC i
            ELSE
                LET term: String := evaluate_term(tokens, INOUT i)
                operand_stack.append(term)
                this_is_term := TRUE
            END IF
        END IF
        --print("    operators \(operator_stack)")
        --print("    operands \(operand_stack)")
        last_was_term := this_is_term
    END LOOP
    IF operand_stack.size() = 0 THEN
        RETURN ""
    END IF
    RETURN operand_stack[FIRST]
END FUNCTION

FUNCTION skip_if_ncl(tokens: Array<Token>, INOUT i: Number)
    IF i < tokens.size() AND tokens[i].type = TokenType.Special AND tokens[i].value = ";" THEN
        INC i
    END IF
END FUNCTION

TYPE TemplateType IS ENUM
    target
    pattern
    positional
END ENUM

TYPE Template IS RECORD
    type: TemplateType
    target_name: String
END RECORD

FUNCTION Template.toString(self: Template): String
    RETURN "<\(self.type):\(self.target_name)>"
END FUNCTION

FUNCTION do_parse(tokens: Array<Token>, INOUT i: Number, upper: Boolean)
    ASSERT tokens[i].type = TokenType.Var_symbol
    LET source: String := tokens[i].value
    INC i
    VAR input: Array<String> := []
    CASE source
        WHEN "ARG" DO
            input := contexts[LAST].call_args
        WHEN "PULL" DO
            input := [console.input("")]
        WHEN "SOURCE" DO
            input := ["Neon", "COMMAND", script_filename]
        WHEN "VALUE" DO
            input := [evaluate(tokens, INOUT i, ["WITH"])]
            IF NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WITH") THEN
                ASSERT FALSE, "WITH expected"
            END IF
            INC i
        WHEN "VAR" DO
            IF tokens[i].type = TokenType.Var_symbol THEN
                input := [get_var(tokens[i].value)]
                INC i
            ELSE
                ASSERT FALSE, "var not found"
            END IF
        WHEN "VERSION" DO
            input := ["neon", "1", "2020", "Sep", "22"]
        WHEN OTHERS DO
            ASSERT FALSE, "unknown parse source", source
    END CASE
    VAR template_list: Array<Array<Template>> := []
    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
        VAR template: Array<Template> := []
        WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
            IF tokens[i].type IN [TokenType.Var_symbol, TokenType.Const_symbol, TokenType.String] THEN
                template.append(Template(type WITH TemplateType.target, target_name WITH tokens[i].value))
                INC i
            ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = "," THEN
                INC i
                EXIT WHILE
            ELSE
                ASSERT FALSE, "unexpected template token", tokens[i]
            END IF
        END WHILE
        template_list.append(template)
    END WHILE
    FOREACH s IN input INDEX tli DO
        IF tli >= template_list.size() THEN
            EXIT FOREACH
        END IF
        LET ss: String := (IF upper THEN string.upper(s) ELSE s)
        LET template: Array<Template> := template_list[tli]
        LET a: Array<String> := string.split(ss, " ")
        FOREACH t IN template INDEX ti DO
            ASSERT t.type = TemplateType.target
            IF ti < template.size()-1 THEN
                set_var(t.target_name, (IF ti < a.size() THEN a[ti] ELSE ""))
            ELSE
                set_var(t.target_name, string.join(a[ti TO LAST], " "))
            END IF
        END FOREACH
    END FOREACH
END FUNCTION

FUNCTION skip_instruction(tokens: Array<Token>, INOUT i: Number)
    IF tokens[i].type = TokenType.Var_symbol THEN
        IF tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
            INC i
            WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
                INC i
            END WHILE
        ELSE
            CASE tokens[i].value
                WHEN "DO" DO
                    INC i
                    WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "END") DO
                        skip_instruction(tokens, INOUT i)
                    END WHILE
                    INC i
                WHEN "IF" DO
                    WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN") DO
                        INC i
                    END WHILE
                    skip_if_ncl(tokens, INOUT i)
                    skip_instruction(tokens, INOUT i)
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "ELSE" THEN
                        INC i
                        skip_if_ncl(tokens, INOUT i)
                        skip_instruction(tokens, INOUT i)
                    END IF
                WHEN "SELECT" DO
                    INC i
                    WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "END") DO
                        IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WHEN" THEN
                            WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN") DO
                                INC i
                            END WHILE
                            INC i
                        ELSE
                            skip_instruction(tokens, INOUT i)
                        END IF
                    END WHILE
                    INC i
                WHEN OTHERS DO
                    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
                        INC i
                    END WHILE
            END CASE
        END IF
    ELSE
        WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
            INC i
        END WHILE
    END IF
    skip_if_ncl(tokens, INOUT i)
END FUNCTION

FUNCTION do_check_terminate(tokens: Array<Token>, INOUT i: Number, INOUT context: ContextEntry): Boolean
    VAR rep: Number := context.do_rep
    IF rep > 0 THEN
        DEC rep
        IF rep <= 0 THEN
            RETURN TRUE
        END IF
        context.do_rep := rep
    END IF
    LET var: String := context.do_var
    IF var <> "" THEN
        LET newvar: Number := num(get_var(var)) + context.do_by
        IF context.do_bounded AND newvar > context.do_bounded_to THEN
            RETURN TRUE
        END IF
        set_var(var, str(newvar))
    END IF
    LET while: Number := context.do_while_condition
    IF while > 0 THEN
        i := context.do_while_condition
        LET cond: String := evaluate(tokens, INOUT i, [])
        IF cond = "0" THEN
            RETURN TRUE
        ELSIF cond <> "1" THEN
            ASSERT FALSE, "unexpected cond", cond
        END IF
    END IF
    RETURN FALSE
END FUNCTION

FUNCTION interpret_step(INOUT tokens: Array<Token>, INOUT i: Number): Boolean
    --VAR o: Object := vars print(o.toString())
    --print("interpret \(tokens[i])")
    LET orig_i: Number := i
    CASE tokens[i].type
        WHEN TokenType.Label DO
            INC i
        WHEN TokenType.Special DO
            CASE tokens[i].value
                WHEN ";" DO
                    INC i
                WHEN OTHERS DO
                    ASSERT FALSE, "unexpected special token", tokens[i]
            END CASE
        WHEN TokenType.Var_symbol DO
            IF tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
                LET var: String := tokens[i].value
                i := i + 2
                LET s: String := evaluate(tokens, INOUT i, [])
                set_var(var, s)
                RETURN TRUE
            END IF
            CASE tokens[i].value
                WHEN "ARG" DO
                    do_parse(tokens, INOUT i, upper WITH TRUE)
                WHEN "CALL" DO
                    INC i
                    IF tokens[i].type = TokenType.Var_symbol THEN
                        LET name: String := tokens[i].value
                        INC i
                        LET args: Array<String> := get_function_arguments(tokens, INOUT i)
                        VAR lindex: Number
                        IF find_label(source_tokens, name, OUT lindex) THEN
                            vars["SIGL"] := str(tokens[i].line)
                            contexts.append(ContextEntry(type WITH ContextType.call, call_tokens WITH tokens, call_return_ip WITH i, call_args WITH args))
                            tokens := source_tokens
                            i := lindex + 1
                        ELSE
                            vars["RESULT"] := builtin_function(name, args)
                        END IF
                    ELSE
                        ASSERT FALSE, "unexpected thing to call", tokens[i].type
                    END IF
                WHEN "DO" DO
                    VAR out_of_loop: Number := i
                    skip_instruction(tokens, INOUT out_of_loop)
                    INC i
                    IF tokens[i].type = TokenType.Special AND tokens[i].value = ";" THEN
                        contexts.append(ContextEntry(type WITH ContextType.do_single, do_skip WITH out_of_loop))
                    ELSE
                        VAR context: ContextEntry := ContextEntry(type WITH ContextType.do_repetitive, do_skip WITH out_of_loop, do_by WITH 1)
                        IF tokens[i].type = TokenType.Var_symbol AND tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
                            context.do_var := tokens[i].value
                            i := i + 2
                            set_var(context.do_var, evaluate(tokens, INOUT i, ["TO", "BY", "FOR", "WHILE", "UNTIL"]))
                            LOOP
                                IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "TO" THEN
                                    INC i
                                    context.do_bounded := TRUE
                                    context.do_bounded_to := num(evaluate(tokens, INOUT i, ["TO", "BY", "FOR", "WHILE", "UNTIL"]))
                                ELSIF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "BY" THEN
                                    INC i
                                    context.do_by := num(evaluate(tokens, INOUT i, ["TO", "BY", "FOR", "WHILE", "UNTIL"]))
                                ELSIF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "FOR" THEN
                                    INC i
                                    context.do_for := num(evaluate(tokens, INOUT i, ["TO", "BY", "FOR", "WHILE", "UNTIL"]))
                                ELSE
                                    EXIT LOOP
                                END IF
                            END LOOP
                        END IF
                        IF NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") THEN
                            IF NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value IN ["WHILE", "UNTIL"]) THEN
                                context.do_rep := num(evaluate(tokens, INOUT i, ["WHILE"]))
                                IF context.do_rep <= 0 THEN
                                    i := out_of_loop
                                END IF
                            END IF
                        END IF
                        IF i < tokens.size() AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WHILE" THEN
                            INC i
                            LET expr: Number := i
                            LET cond: String := evaluate(tokens, INOUT i, [])
                            CASE cond
                                WHEN "0" DO
                                    i := out_of_loop
                                WHEN "1" DO
                                    context.do_while_condition := expr
                                WHEN OTHERS DO
                                    ASSERT FALSE, "unexpected cond", cond
                            END CASE
                        END IF
                        IF i < out_of_loop THEN
                            context.do_top := i
                            contexts.append(context)
                        END IF
                    END IF
                WHEN "DROP" DO
                    INC i
                    LOOP
                        IF tokens[i].type = TokenType.Var_symbol THEN
                            -- TODO: need dictionary remove
                            -- vars.remove(tokens[i].value)
                            INC i
                        ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = "(" THEN
                            ASSERT FALSE, "indirect drop"
                        ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = ";" THEN
                            EXIT LOOP
                        ELSE
                            ASSERT FALSE, "unexpected thing to drop"
                        END IF
                    END LOOP
                WHEN "ELSE" DO
                    CASE contexts[LAST].type
                        WHEN ContextType.if DO
                            i := contexts[LAST].if_skip
                            contexts.resize(contexts.size() - 1)
                        WHEN OTHERS DO
                            ASSERT FALSE, "else found when not in if", contexts[LAST].type
                    END CASE
                WHEN "END" DO
                    --print("END context \(contexts[LAST].type)")
                    CASE contexts[LAST].type
                        WHEN ContextType.do_single DO
                            INC i
                            contexts.resize(contexts.size() - 1)
                        WHEN ContextType.do_repetitive DO
                            IF do_check_terminate(tokens, INOUT i, INOUT contexts[LAST]) THEN
                                i := contexts[LAST].do_skip
                                contexts.resize(contexts.size() - 1)
                            ELSE
                                i := contexts[LAST].do_top
                            END IF
                        WHEN ContextType.select DO
                            INC i
                            contexts.resize(contexts.size() - 1)
                        WHEN OTHERS DO
                            ASSERT FALSE, "end found for no reason", contexts[LAST].type
                    END CASE
                WHEN "EXIT" DO
                    INC i
                    LET r: String := evaluate(tokens, INOUT i, [])
                    sys.exit(rxnum(r))
                WHEN "IF" DO
                    INC i
                    LET cond: String := evaluate(tokens, INOUT i, ["THEN"])
                    ASSERT tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN"
                    INC i
                    skip_if_ncl(tokens, INOUT i)
                    CASE cond
                        WHEN "1" DO
                            VAR else: Number := i
                            skip_instruction(tokens, INOUT else)
                            IF else < tokens.size() AND tokens[else].type = TokenType.Var_symbol AND tokens[else].value = "ELSE" THEN
                                VAR skip: Number := else + 1
                                skip_instruction(tokens, INOUT skip)
                                contexts.append(ContextEntry(type WITH ContextType.if, if_skip WITH skip))
                            END IF
                        WHEN "0" DO
                            skip_instruction(tokens, INOUT i)
                            IF i < tokens.size() AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "ELSE" THEN
                                INC i
                            END IF
                        WHEN OTHERS DO
                            ASSERT FALSE, "unexpected cond", cond
                    END CASE
                WHEN "INTERPRET" DO
                    INC i
                    LET expr: String := evaluate(tokens, INOUT i, [])
                    LET itokens: Array<Token> := tokenise(expr) & [Token(type WITH TokenType.Special, value WITH ";"), Token(type WITH TokenType.Eos)]
                    contexts.append(ContextEntry(type WITH ContextType.call, call_tokens WITH tokens, call_return_ip WITH i))
                    tokens := itokens
                    i := 0
                WHEN "LEAVE" DO
                    WHILE contexts.size() > 0 AND contexts[LAST].type <> ContextType.do_repetitive DO
                        contexts.resize(contexts.size() - 1)
                    END WHILE
                    i := contexts[LAST].do_skip
                    contexts.resize(contexts.size() - 1)
                WHEN "NOP" DO
                    INC i
                    -- No operation.
                WHEN "OTHERWISE" DO
                    CASE contexts[LAST].type
                        WHEN ContextType.select DO
                            i := contexts[LAST].select_skip
                            contexts.resize(contexts.size() - 1)
                        WHEN OTHERS DO
                            ASSERT FALSE, "unexpected otherwise", contexts[LAST].type
                    END CASE
                WHEN "PARSE" DO
                    INC i
                    LET upper: Boolean := tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "UPPER"
                    IF upper THEN
                        INC i
                    END IF
                    do_parse(tokens, INOUT i, upper)
                WHEN "PROCEDURE" DO
                    INC i
                    VAR expose: Array<String> := []
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "EXPOSE" THEN
                        INC i
                        WHILE tokens[i].type = TokenType.Var_symbol DO
                            expose.append(tokens[i].value)
                            INC i
                        END WHILE
                    END IF
                    -- TODO: introduce new variable scope
                WHEN "PULL" DO
                    do_parse(tokens, INOUT i, upper WITH TRUE)
                WHEN "RETURN" DO
                    INC i
                    WHILE contexts.size() > 0 AND contexts[LAST].type <> ContextType.call DO
                        contexts.resize(contexts.size() - 1)
                    END WHILE
                    ASSERT contexts.size() > 0, "unexpected return"
                    -- TODO: expression is optional
                    LET r: String := evaluate(tokens, INOUT i, [])
                    vars["RESULT"] := r
                    tokens := contexts[LAST].call_tokens
                    i := contexts[LAST].call_return_ip
                    contexts.resize(contexts.size() - 1)
                WHEN "SAY" DO
                    INC i
                    IF NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") THEN
                        LET s: String := evaluate(tokens, INOUT i, [])
                        print(s)
                    ELSE
                        INC i
                        print("")
                    END IF
                WHEN "SELECT" DO
                    VAR end_of_select: Number := i
                    skip_instruction(tokens, INOUT end_of_select)
                    INC i
                    skip_if_ncl(tokens, INOUT i)
                    VAR found: Boolean := FALSE
                    WHILE tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WHEN" DO
                        INC i
                        LET cond: String := evaluate(tokens, INOUT i, ["THEN"])
                        ASSERT tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN"
                        INC i
                        skip_if_ncl(tokens, INOUT i)
                        IF cond = "1" THEN
                            contexts.append(ContextEntry(type WITH ContextType.select, select_skip WITH end_of_select))
                            found := TRUE
                            EXIT WHILE
                        ELSIF cond = "0" THEN
                            skip_instruction(tokens, INOUT i)
                        ELSE
                            ASSERT FALSE, "unexpected cond", cond
                        END IF
                    END WHILE
                    IF NOT found AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "OTHERWISE" THEN
                        INC i
                    END IF
                WHEN "SIGNAL" DO
                    INC i
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "ON" THEN
                        INC i
                        IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value IN ["SYNTAX"] THEN
                            LET signal: String := tokens[i].value
                            VAR label: String := signal
                            INC i
                            IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "NAME" THEN
                                INC i
                                IF tokens[i].type = TokenType.Var_symbol THEN
                                    label := tokens[i].value
                                    INC i
                                ELSE
                                    ASSERT FALSE, "label expected", tokens[i]
                                END IF
                            END IF
                            signals[signal] := label
                        ELSE
                            ASSERT FALSE, "unknown signal type", tokens[i]
                        END IF
                    ELSE
                        LET name: String := tokens[i].value
                        INC i
                        VAR lindex: Number
                        IF find_label(source_tokens, name, OUT lindex) THEN
                            vars["SIGL"] := str(tokens[i].line)
                            tokens := source_tokens
                            i := lindex + 1
                        ELSE
                            ASSERT FALSE, "signal label not found"
                        END IF
                    END IF
                WHEN "WHEN" DO
                    CASE contexts[LAST].type
                        WHEN ContextType.select DO
                            i := contexts[LAST].select_skip
                            contexts.resize(contexts.size() - 1)
                        WHEN OTHERS DO
                            ASSERT FALSE, "unexpected when", contexts[LAST].type
                    END CASE
                WHEN OTHERS DO
                    LET r: String := evaluate(tokens, INOUT i, [])
                    vars["RC"] := str(os.system(r))
            END CASE
        WHEN TokenType.Eos DO
            CASE contexts[LAST].type
                WHEN ContextType.call DO
                    tokens := contexts[LAST].call_tokens
                    i := contexts[LAST].call_return_ip
                    contexts.resize(contexts.size() - 1)
                WHEN OTHERS DO
                    RETURN FALSE
            END CASE
        WHEN OTHERS DO
            IF tokens[i].type = TokenType.Const_symbol AND tokens[i+1].type = TokenType.Operator AND tokens[i+1].value IN ["=","=="] THEN
                RAISE SyntaxException
            END IF
            LET r: String := evaluate(tokens, INOUT i, [])
            vars["RC"] := str(os.system(r))
    END CASE
    IF i = orig_i THEN
        ASSERT FALSE, "we are stuck", tokens[i]
    END IF
    skip_if_ncl(tokens, INOUT i)
    RETURN TRUE
END FUNCTION

FUNCTION interpret_function(start_tokens: Array<Token>, start_i: Number): String
    VAR tokens: Array<Token> := start_tokens
    VAR i: Number := start_i
    LET context_depth: Number := contexts.size()
    WHILE contexts.size() >= context_depth DO
        IF NOT interpret_step(INOUT tokens, INOUT i) THEN
            EXIT WHILE
        END IF
    END WHILE
    RETURN vars["RESULT"]
END FUNCTION

FUNCTION interpret()
    VAR tokens: Array<Token> := source_tokens
    VAR i: Number := 0
    WHILE i < tokens.size() DO
        TRY
            IF NOT interpret_step(INOUT tokens, INOUT i) THEN
                EXIT WHILE
            END IF
        TRAP SyntaxException DO
            VAR lindex: Number
            IF find_label(source_tokens, signals["SYNTAX"], OUT lindex) THEN
                vars["SIGL"] := str(tokens[i].line)
                contexts := []
                tokens := source_tokens
                i := lindex + 1
            ELSE
                ASSERT FALSE, "syntax label not found"
            END IF
        END TRY
    END WHILE
END FUNCTION

BEGIN MAIN
    script_filename := sys.args[1]
    LET bytes: Bytes := file.readBytes(script_filename)
    LET source: String := bytes.decodeToString()
    sourcelines := [""] & string.splitLines(source)
    source_tokens := tokenise(source)
    --FOREACH t IN source_tokens INDEX i DO
    --    print("\(i) \(t.type) \(t.value)")
    --END FOREACH
    contexts.append(ContextEntry(call_return_ip WITH -1, call_args WITH [string.join(sys.args[2 TO LAST], " ")]))
    interpret()
    ASSERT contexts.size() = 1
END MAIN
