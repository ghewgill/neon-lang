IMPORT console
IMPORT file
IMPORT io
IMPORT math
IMPORT os
IMPORT random
IMPORT string
IMPORT sys

EXCEPTION SyntaxException

TYPE TokenType IS ENUM
    Label
    Special
    Var_symbol
    Const_symbol
    String
    Operator
    Blank
    Eos
END ENUM

TYPE Token IS RECORD
    line: Number
    type: TokenType
    abuttal: Boolean
    value: String
END RECORD

FUNCTION Token.toString(self: Token): String
    RETURN "<\(self.line):\(self.type):\(self.value)>"
END FUNCTION

TYPE ContextType IS ENUM
    call
    do_single
    do_repetitive
    if
    select
END ENUM

TYPE ContextEntry IS RECORD
    type: ContextType
    call_tokens: Array<Token>
    call_return_ip: Number
    call_args: Array<String>
    do_skip: Number
    do_top: Number
    do_var: String
    do_to: Number
    do_by: Number
    do_for: Number
    do_rep: Number
    do_while_condition: Number
    if_skip: Number
    select_skip: Number
END RECORD

VAR sourcelines: Array<String>
VAR vars: Dictionary<String>
VAR contexts: Array<ContextEntry>
VAR signals: Dictionary<String> := {
    "SYNTAX": "SYNTAX",
}

FUNCTION is_digit(c: String): Boolean
    RETURN "0" <= c <= "9"
END FUNCTION

FUNCTION is_general_letter(c: String): Boolean
    RETURN "A" <= c <= "Z" OR
           "a" <= c <= "z" OR
           c IN ["_", "!", "?"]
END FUNCTION

FUNCTION is_var_symbol_char(c: String): Boolean
    RETURN is_general_letter(c) OR is_digit(c) OR c = "."
END FUNCTION

FUNCTION is_const_symbol_char(c: String): Boolean
    RETURN is_var_symbol_char(c) OR c IN ["+", "-"]
END FUNCTION

FUNCTION convert_binary_string(s: String): String
    CONSTANT Digits: String := "01"
    VAR t: String := s
    FOREACH c IN t DO
        IF c <> " " AND c NOT IN Digits THEN
            ASSERT FALSE, "invalid binary string", s
        END IF
    END FOREACH
    IF string.hasPrefix(t, " ") THEN
        RAISE SyntaxException
    END IF
    t := string.replaceAll(t, " ", "")
    WHILE t.length() MOD 8 <> 0 DO
        t := "0" & t
    END WHILE
    VAR r: String := ""
    FOR i := 0 TO t.length()-1 STEP 8 DO
        VAR b: Number := 0
        FOR j := 0 TO 7 DO
            b := b * 2 + string.find(Digits, t[i+j])
        END FOR
        r.append(string.fromCodePoint(b))
    END FOR
    RETURN r
END FUNCTION

FUNCTION convert_hex_string(s: String): String
    CONSTANT Digits: String := "0123456789ABCDEF"
    VAR t: String := string.upper(s)
    FOREACH c IN t DO
        IF c <> " " AND c NOT IN Digits THEN
            ASSERT FALSE, "invalid hex string", s
        END IF
    END FOREACH
    IF string.hasPrefix(t, " ") THEN
        RAISE SyntaxException
    END IF
    t := string.replaceAll(t, " ", "")
    IF math.odd(t.length()) THEN
        t := "0" & t
    END IF
    VAR r: String := ""
    FOR i := 0 TO t.length()-1 STEP 2 DO
        r.append(string.fromCodePoint(string.find(Digits, t[i]) * 0x10 + string.find(Digits, t[i+1])))
    END FOR
    RETURN r
END FUNCTION

FUNCTION tokenise(source: String): Array<Token>
    VAR tokens: Array<Token> := []
    VAR line: Number := 1
    VAR i: Number := 0
    VAR last_was_space: Boolean := FALSE
    WHILE i < source.length() DO
        VAR t: Token := Token()
        t.line := line
        t.abuttal := NOT last_was_space
        last_was_space := FALSE
        IF source[i] IN [",", ":", ";", ")", "("] THEN
            t.type := TokenType.Special
            t.value := source[i]
            tokens.append(t)
            INC i
        ELSIF source[i] = "\n" THEN
            IF tokens.size() > 0 AND tokens[LAST].type = TokenType.Special AND tokens[LAST].value = "," THEN
                -- Comma continuation, delete last token.
                tokens.resize(tokens.size() - 1)
                last_was_space := TRUE
            ELSE
                t.type := TokenType.Special
                t.value := ";"
                tokens.append(t)
            END IF
            INC i
            INC line
        ELSIF is_general_letter(source[i]) THEN
            t.type := TokenType.Var_symbol
            WHILE is_var_symbol_char(source[i]) DO
                t.value.append(source[i])
                INC i
            END WHILE
            t.value := string.upper(t.value)
            IF source[i] = ":" THEN
                t.type := TokenType.Label
                INC i
            END IF
            tokens.append(t)
        ELSIF is_digit(source[i]) OR source[i] = "." THEN
            t.type := TokenType.Const_symbol
            WHILE is_const_symbol_char(source[i]) DO
                t.value.append(source[i])
                INC i
            END WHILE
            tokens.append(t)
        ELSIF source[i] IN ["'", "\""] THEN
            LET delim: String := source[i]
            INC i
            t.type := TokenType.String
            LOOP
                IF source[i] = delim THEN
                    IF i+1 < source.length() AND source[i+1] = delim THEN
                        t.value.append(delim)
                        i := i + 2
                    ELSE
                        EXIT LOOP
                    END IF
                ELSE
                    t.value.append(source[i])
                    INC i
                END IF
            END LOOP
            INC i
            IF i < source.length() AND source[i] IN ["B", "b"] AND NOT is_var_symbol_char(source[i+1]) THEN
                t.type := TokenType.String
                t.value := convert_binary_string(t.value)
                INC i
            ELSIF i < source.length() AND source[i] IN ["X", "x"] AND NOT is_var_symbol_char(source[i+1]) THEN
                t.type := TokenType.String
                t.value := convert_hex_string(t.value)
                INC i
            END IF
            tokens.append(t)
        ELSIF source[i] IN ["+", "-", "%", "|", "&", "=", "\\", "^", ">", "<", "/", "*"] THEN
            IF source[i] = "/" AND source[i+1] = "*" THEN
                VAR level: Number := 0
                REPEAT
                    IF source[i] = "/" AND source[i+1] = "*" THEN
                        INC level
                        i := i + 2
                    ELSIF source[i] = "*" AND source[i+1] = "/" THEN
                        DEC level
                        i := i + 2
                    ELSIF source[i] = "\n" THEN
                        INC line
                        INC i
                    ELSE
                        INC i
                    END IF
                UNTIL level = 0
            ELSE
                t.type := TokenType.Operator
                CASE source[i]
                    WHEN "|" DO
                        CASE source[i+1]
                            WHEN "|" DO
                                t.value := "||"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "|"
                        END CASE
                    WHEN "/" DO
                        CASE source[i+1]
                            WHEN "/" DO
                                t.value := "//"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "/"
                        END CASE
                    WHEN "*" DO
                        CASE source[i+1]
                            WHEN "*" DO
                                t.value := "**"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "*"
                        END CASE
                    WHEN "\\", "^" DO
                        CASE source[i+1]
                            WHEN "=" DO
                                CASE source[i+2]
                                    WHEN "=" DO
                                        t.value := "\\=="
                                        i := i + 2
                                    WHEN OTHERS DO
                                        t.value := "\\="
                                        i := i + 1
                                END CASE
                            WHEN "<" DO
                                ASSERT FALSE, "unimplemented <"
                            WHEN ">" DO
                                ASSERT FALSE, "unimplemented >"
                            WHEN OTHERS DO
                                t.value := "\\"
                        END CASE
                    WHEN ">" DO
                        CASE source[i+1]
                            WHEN "<" DO
                                t.value := "><"
                                i := i + 1
                            WHEN ">" DO
                                CASE source[i+2]
                                    WHEN "=" DO
                                        t.value := ">>="
                                        i := i + 2
                                    WHEN OTHERS DO
                                        t.value := ">>"
                                        i := i + 1
                                END CASE
                            WHEN OTHERS DO
                                t.value := ">"
                        END CASE
                    WHEN "<" DO
                        CASE source[i+1]
                            WHEN ">" DO
                                t.value := "<>"
                                i := i + 1
                            WHEN "<" DO
                                CASE source[i+2]
                                    WHEN "=" DO
                                        t.value := "<<="
                                        i := i + 2
                                    WHEN OTHERS DO
                                        t.value := "<<"
                                        i := i + 1
                                END CASE
                            WHEN OTHERS DO
                                t.value := "<"
                        END CASE
                    WHEN "=" DO
                        CASE source[i+1]
                            WHEN "=" DO
                                t.value := "=="
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "="
                        END CASE
                    WHEN "&" DO
                        CASE source[i+1]
                            WHEN "&" DO
                                t.value := "&&"
                                i := i + 1
                            WHEN OTHERS DO
                                t.value := "&"
                        END CASE
                    WHEN OTHERS DO
                        t.value := source[i]
                END CASE
                tokens.append(t)
                INC i
            END IF
        ELSIF source[i] IN [" "] THEN
            INC i
            last_was_space := TRUE
        ELSE
            ASSERT FALSE, "unexpected character", source[i]
        END IF
    END WHILE
    RETURN tokens
END FUNCTION

FUNCTION is_number(s: String, OUT n: Number): Boolean
    n := 0
    TRY
        n := num(s)
        RETURN TRUE
    TRAP ValueRangeException DO
        RETURN FALSE
    END TRY
END FUNCTION

FUNCTION rxnum(s: String): Number
    TRY
        RETURN num(string.replaceAll(s, " ", ""))
    TRAP ValueRangeException DO
        print("not a number: <\(s)>")
        RAISE ValueRangeException
    END TRY
END FUNCTION

FUNCTION find_label(tokens: Array<Token>, label: String, OUT index: Number): Boolean
    index := -1
    FOREACH t IN tokens INDEX ti DO
        IF t.type = TokenType.Label AND t.value = label THEN
            index := ti
            RETURN TRUE
        END IF
    END FOREACH
    RETURN FALSE
END FUNCTION

FUNCTION builtin_function(name: String, args: Array<String>): String
    CASE name
        WHEN "ARG" DO
            RETURN contexts[LAST].call_args[num(args[0]) - 1]
        WHEN "CHAROUT" DO
            IF args[0] = "" THEN
                io.write(io.stdout, args[1])
                io.flush(io.stdout)
                RETURN str(args[1].length())
            ELSE
                ASSERT FALSE, "charout only to stdout", args
            END IF
        WHEN "LENGTH" DO
            RETURN str(args[0].length())
        WHEN "RANDOM" DO
            RETURN str(random.uint32() MOD (rxnum(args[1]) - rxnum(args[0]) + 1) + rxnum(args[0]))
        WHEN "SOURCELINE" DO
            RETURN sourcelines[rxnum(args[0])]
        WHEN "WORDS" DO
            RETURN str(string.split(args[0], " ").size())
    END CASE
    ASSERT FALSE, "unknown builtin function", name
    RETURN ""
END FUNCTION

FUNCTION get_function_arguments(tokens: Array<Token>, INOUT i: Number): Array<String>
    VAR r: Array<String> := []
    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value IN [")", ";"]) DO
        LET s: String := evaluate(tokens, INOUT i)
        r.append(s)
        IF tokens[i].type = TokenType.Special AND tokens[i].value = "," THEN
            INC i
        END IF
    END WHILE
    RETURN r
END FUNCTION

FUNCTION evaluate_term(tokens: Array<Token>, INOUT i: Number): String
    VAR r: String := ""
    CASE tokens[i].type
        WHEN TokenType.Var_symbol DO
            LET name: String := tokens[i].value
            INC i
            IF tokens[i].type = TokenType.Special AND tokens[i].value = "(" AND tokens[i].abuttal THEN
                INC i
                LET args: Array<String> := get_function_arguments(tokens, INOUT i)
                ASSERT tokens[i].type = TokenType.Special AND tokens[i].value = ")"
                INC i
                r := builtin_function(name, args)
            ELSE
                r := (IF name IN vars THEN vars[name] ELSE name)
            END IF
        WHEN TokenType.Const_symbol, TokenType.String DO
            r := tokens[i].value
            INC i
            IF tokens[i].type = TokenType.Special AND tokens[i].value = "(" AND tokens[i].abuttal THEN
                INC i
                LET args: Array<String> := get_function_arguments(tokens, INOUT i)
                ASSERT tokens[i].type = TokenType.Special AND tokens[i].value = ")"
                INC i
                r := builtin_function(r, args)
            END IF
        WHEN OTHERS DO
            -- Must be empty argument, as in: call charout , 'a'
    END CASE
    RETURN r
END FUNCTION

-- TODO: pass in terminating token set? Like "THEN" or "TO"
FUNCTION evaluate(tokens: Array<Token>, INOUT i: Number): String
    CONSTANT OperatorPrecedence: Dictionary<Number> := {
        "": 0,
        "(": 0,
        "&&": 1,
        "|": 2,
        "&": 3,
        "=": 4,
        "\\=": 4,
        "==": 4,
        "\\==": 4,
        "<": 4,
        ">": 4,
        "<>": 4,
        " ": 5,
        "||": 5,
        "+": 6,
        "-": 6,
        "*": 7,
        "/": 7,
        "**": 8,
    }
    --print("evaluate \(tokens[i].type) \(tokens[i].value)")
    TYPE TermOp IS RECORD
        term: String
        op: String
    END RECORD
    VAR stack: Array<TermOp> := []
    LOOP
        --print("  eval \(tokens[i].type) \(tokens[i].value)")
        WHILE tokens[i].type = TokenType.Special AND tokens[i].value = "(" DO
            stack.append(TermOp(op WITH "("))
            INC i
        END WHILE
        VAR term: String := evaluate_term(tokens, INOUT i)
        --print("  next \(tokens[i].type) \(tokens[i].value)")
        LOOP
            VAR op: String
            IF tokens[i].type = TokenType.Operator THEN
                op := tokens[i].value
                INC i
            ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = ")" THEN
                op := "("
                INC i
            ELSIF tokens[i].type = TokenType.Special OR (tokens[i].type = TokenType.Var_symbol AND tokens[i].value IN ["THEN", "TO", "BY", "FOR"]) THEN
                op := ""
            ELSE
                IF tokens[i].abuttal THEN
                    op := "||"
                ELSE
                    op := " "
                END IF
            END IF
            --print("  oper \(op)")
            LET level: Number := OperatorPrecedence[op]
            WHILE stack.size() > 0 AND level < OperatorPrecedence[stack[LAST].op] DO
                CASE stack[LAST].op
                    WHEN " " DO
                        term := stack[LAST].term & " " & term
                        stack := stack[FIRST TO LAST-1]
                    WHEN "|" DO
                        term := (IF num(stack[LAST].term) <> 0 OR num(term) <> 0 THEN "1" ELSE "0")
                        stack := stack[FIRST TO LAST-1]
                    WHEN "||" DO
                        term := stack[LAST].term & term
                        stack := stack[FIRST TO LAST-1]
                    WHEN "=" DO
                        term := (IF stack[LAST].term = term THEN "1" ELSE "0")
                        stack := stack[FIRST TO LAST-1]
                    WHEN "\\=", "<>" DO
                        term := (IF stack[LAST].term <> term THEN "1" ELSE "0")
                        stack := stack[FIRST TO LAST-1]
                    WHEN "==" DO
                        term := (IF stack[LAST].term = term THEN "1" ELSE "0")
                        stack := stack[FIRST TO LAST-1]
                    WHEN "\\==" DO
                        term := (IF stack[LAST].term <> term THEN "1" ELSE "0")
                        stack := stack[FIRST TO LAST-1]
                    WHEN "<" DO
                        VAR x: Number
                        VAR y: Number
                        IF is_number(stack[LAST].term, OUT x) AND is_number(term, OUT y) THEN
                            term := (IF x < y THEN "1" ELSE "0")
                        ELSE
                            term := (IF stack[LAST].term < term THEN "1" ELSE "0")
                        END IF
                        stack := stack[FIRST TO LAST-1]
                    WHEN ">" DO
                        term := (IF rxnum(stack[LAST].term) > rxnum(term) THEN "1" ELSE "0")
                        stack := stack[FIRST TO LAST-1]
                    WHEN "+" DO
                        term := str(rxnum(stack[LAST].term) + rxnum(term))
                        stack := stack[FIRST TO LAST-1]
                    WHEN "-" DO
                        term := str(rxnum(stack[LAST].term) - rxnum(term))
                        stack := stack[FIRST TO LAST-1]
                    WHEN "*" DO
                        term := str(rxnum(stack[LAST].term) * rxnum(term))
                        stack := stack[FIRST TO LAST-1]
                    WHEN "/" DO
                        term := str(rxnum(stack[LAST].term) / rxnum(term))
                        stack := stack[FIRST TO LAST-1]
                    WHEN OTHERS DO
                        ASSERT FALSE, "unimplemented operator", stack[LAST].op
                END CASE
            END WHILE
            IF op = "(" THEN
                IF stack.size() = 0 THEN
                    DEC i
                    RETURN term
                END IF
            ELSE
                IF level = 0 THEN
                    RETURN term
                END IF
                stack.append(TermOp(term WITH term, op WITH op))
                EXIT LOOP
            END IF
            stack := stack[FIRST TO LAST-1]
        END LOOP
    END LOOP
END FUNCTION

FUNCTION skip_if_ncl(tokens: Array<Token>, INOUT i: Number)
    IF i < tokens.size() AND tokens[i].type = TokenType.Special AND tokens[i].value = ";" THEN
        INC i
    END IF
END FUNCTION

TYPE TemplateType IS ENUM
    target
    pattern
    positional
END ENUM

TYPE Template IS RECORD
    type: TemplateType
    target_name: String
END RECORD

FUNCTION Template.toString(self: Template): String
    RETURN "<\(self.type):\(self.target_name)>"
END FUNCTION

FUNCTION do_parse(tokens: Array<Token>, INOUT i: Number, upper: Boolean)
    ASSERT tokens[i].type = TokenType.Var_symbol
    LET source: String := tokens[i].value
    INC i
    VAR template_list: Array<Array<Template>> := []
    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
        VAR template: Array<Template> := []
        WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
            IF tokens[i].type = TokenType.Var_symbol OR (tokens[i].type = TokenType.Const_symbol AND tokens[i].value = ".") THEN
                template.append(Template(type WITH TemplateType.target, target_name WITH tokens[i].value))
                INC i
            ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = "," THEN
                INC i
                EXIT WHILE
            ELSE
                ASSERT FALSE, "unexpected template token", tokens[i]
            END IF
        END WHILE
        template_list.append(template)
    END WHILE
    VAR input: Array<String> := []
    CASE source
        WHEN "ARG" DO
            input := contexts[LAST].call_args
        WHEN "PULL" DO
            input := [console.input("")]
        WHEN OTHERS DO
            ASSERT FALSE, "unknown parse source", source
    END CASE
    FOREACH s IN input INDEX tli DO
        LET ss: String := (IF upper THEN string.upper(s) ELSE s)
        LET template: Array<Template> := template_list[tli]
        LET a: Array<String> := string.split(ss, " ")
        FOREACH t IN template INDEX ti DO
            ASSERT t.type = TemplateType.target
            IF ti < template.size()-1 THEN
                vars[t.target_name] := (IF ti < a.size() THEN a[ti] ELSE "")
            ELSE
                vars[t.target_name] := string.join(a[ti TO LAST], " ")
            END IF
        END FOREACH
    END FOREACH
END FUNCTION

FUNCTION skip_instruction(tokens: Array<Token>, INOUT i: Number)
    IF tokens[i].type = TokenType.Var_symbol THEN
        IF tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
            INC i
            WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
                INC i
            END WHILE
        ELSE
            CASE tokens[i].value
                WHEN "DO" DO
                    INC i
                    WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "END") DO
                        skip_instruction(tokens, INOUT i)
                    END WHILE
                    INC i
                WHEN "IF" DO
                    WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN") DO
                        INC i
                    END WHILE
                    skip_if_ncl(tokens, INOUT i)
                    skip_instruction(tokens, INOUT i)
                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "ELSE" THEN
                        INC i
                        skip_if_ncl(tokens, INOUT i)
                        skip_instruction(tokens, INOUT i)
                    END IF
                WHEN "SELECT" DO
                    INC i
                    WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "END") DO
                        IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WHEN" THEN
                            WHILE NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN") DO
                                INC i
                            END WHILE
                            INC i
                        ELSE
                            skip_instruction(tokens, INOUT i)
                        END IF
                    END WHILE
                    INC i
                WHEN OTHERS DO
                    WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
                        INC i
                    END WHILE
            END CASE
        END IF
    ELSE
        WHILE NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") DO
            INC i
        END WHILE
    END IF
    skip_if_ncl(tokens, INOUT i)
END FUNCTION

FUNCTION do_check_terminate(tokens: Array<Token>, INOUT i: Number, INOUT context: ContextEntry): Boolean
    VAR rep: Number := context.do_rep
    IF rep > 0 THEN
        DEC rep
        IF rep <= 0 THEN
            RETURN TRUE
        END IF
        context.do_rep := rep
    END IF
    LET var: String := context.do_var
    IF var <> "" THEN
        LET newvar: Number := num(vars[var]) + context.do_by
        IF newvar > context.do_to THEN
            RETURN TRUE
        END IF
        vars[var] := str(newvar)
    END IF
    LET while: Number := context.do_while_condition
    IF while > 0 THEN
        i := context.do_while_condition
        LET cond: String := evaluate(tokens, INOUT i)
        IF cond = "0" THEN
            RETURN TRUE
        ELSIF cond <> "1" THEN
            ASSERT FALSE, "unexpected cond", cond
        END IF
    END IF
    RETURN FALSE
END FUNCTION

FUNCTION interpret(source_tokens: Array<Token>)
    VAR tokens: Array<Token> := source_tokens
    VAR i: Number := 0
    WHILE i < tokens.size() LABEL interpret_loop DO
        --VAR o: Object := vars print(o.toString())
        --print("interpret \(tokens[i])")
        LET orig_i: Number := i
        CASE tokens[i].type
            WHEN TokenType.Label DO
                INC i
            WHEN TokenType.Special DO
                CASE tokens[i].value
                    WHEN ";" DO
                        INC i
                    WHEN OTHERS DO
                        ASSERT FALSE, "unexpected special token", tokens[i]
                END CASE
            WHEN TokenType.Var_symbol DO
                IF tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
                    LET var: String := tokens[i].value
                    i := i + 2
                    LET s: String := evaluate(tokens, INOUT i)
                    vars[var] := s
                    NEXT interpret_loop
                END IF
                CASE tokens[i].value
                    WHEN "ARG" DO
                        do_parse(tokens, INOUT i, upper WITH TRUE)
                    WHEN "CALL" DO
                        INC i
                        IF tokens[i].type = TokenType.Var_symbol THEN
                            LET name: String := tokens[i].value
                            INC i
                            LET args: Array<String> := get_function_arguments(tokens, INOUT i)
                            VAR lindex: Number
                            IF find_label(source_tokens, name, OUT lindex) THEN
                                vars["SIGL"] := str(tokens[i].line)
                                contexts.append(ContextEntry(type WITH ContextType.call, call_tokens WITH tokens, call_return_ip WITH i, call_args WITH args))
                                tokens := source_tokens
                                i := lindex + 1
                            ELSE
                                vars["RESULT"] := builtin_function(name, args)
                            END IF
                        ELSE
                            ASSERT FALSE, "unexpected thing to call", tokens[i].type
                        END IF
                    WHEN "DO" DO
                        VAR out_of_loop: Number := i
                        skip_instruction(tokens, INOUT out_of_loop)
                        INC i
                        IF tokens[i].type = TokenType.Special AND tokens[i].value = ";" THEN
                            contexts.append(ContextEntry(type WITH ContextType.do_single, do_skip WITH out_of_loop))
                        ELSE
                            VAR context: ContextEntry := ContextEntry(type WITH ContextType.do_repetitive, do_skip WITH out_of_loop, do_by WITH 1)
                            IF tokens[i].type = TokenType.Var_symbol AND tokens[i+1].type = TokenType.Operator AND tokens[i+1].value = "=" THEN
                                context.do_var := tokens[i].value
                                i := i + 2
                                vars[context.do_var] := evaluate(tokens, INOUT i)
                                LOOP
                                    IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "TO" THEN
                                        INC i
                                        context.do_to := num(evaluate(tokens, INOUT i))
                                    ELSIF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "BY" THEN
                                        INC i
                                        context.do_by := num(evaluate(tokens, INOUT i))
                                    ELSIF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "FOR" THEN
                                        INC i
                                        context.do_for := num(evaluate(tokens, INOUT i))
                                    ELSE
                                        EXIT LOOP
                                    END IF
                                END LOOP
                            END IF
                            IF NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") THEN
                                IF NOT (tokens[i].type = TokenType.Var_symbol AND tokens[i].value IN ["WHILE", "UNTIL"]) THEN
                                    context.do_rep := num(evaluate(tokens, INOUT i))
                                END IF
                            END IF
                            IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WHILE" THEN
                                INC i
                                LET expr: Number := i
                                LET cond: String := evaluate(tokens, INOUT i)
                                CASE cond
                                    WHEN "0" DO
                                        i := out_of_loop
                                    WHEN "1" DO
                                        context.do_while_condition := expr
                                    WHEN OTHERS DO
                                        ASSERT FALSE, "unexpected cond", cond
                                END CASE
                            END IF
                            context.do_top := i
                            contexts.append(context)
                        END IF
                    WHEN "DROP" DO
                        INC i
                        LOOP
                            IF tokens[i].type = TokenType.Var_symbol THEN
                                -- TODO: need dictionary remove
                                -- vars.remove(tokens[i].value)
                                INC i
                            ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = "(" THEN
                                ASSERT FALSE, "indirect drop"
                            ELSIF tokens[i].type = TokenType.Special AND tokens[i].value = ";" THEN
                                EXIT LOOP
                            ELSE
                                ASSERT FALSE, "unexpected thing to drop"
                            END IF
                        END LOOP
                    WHEN "ELSE" DO
                        CASE contexts[LAST].type
                            WHEN ContextType.if DO
                                i := contexts[LAST].if_skip
                                contexts.resize(contexts.size() - 1)
                            WHEN OTHERS DO
                                ASSERT FALSE, "else found when not in if", contexts[LAST].type
                        END CASE
                    WHEN "END" DO
                        --print("END context \(contexts[LAST].type)")
                        CASE contexts[LAST].type
                            WHEN ContextType.do_single DO
                                INC i
                                contexts.resize(contexts.size() - 1)
                            WHEN ContextType.do_repetitive DO
                                IF do_check_terminate(tokens, INOUT i, INOUT contexts[LAST]) THEN
                                    i := contexts[LAST].do_skip
                                    contexts.resize(contexts.size() - 1)
                                ELSE
                                    i := contexts[LAST].do_top
                                END IF
                            WHEN ContextType.select DO
                                INC i
                                contexts.resize(contexts.size() - 1)
                            WHEN OTHERS DO
                                ASSERT FALSE, "end found for no reason", contexts[LAST].type
                        END CASE
                    WHEN "EXIT" DO
                        INC i
                        LET r: String := evaluate(tokens, INOUT i)
                        sys.exit(rxnum(r))
                    WHEN "IF" DO
                        INC i
                        LET cond: String := evaluate(tokens, INOUT i)
                        ASSERT tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN"
                        INC i
                        skip_if_ncl(tokens, INOUT i)
                        CASE cond
                            WHEN "1" DO
                                VAR else: Number := i
                                skip_instruction(tokens, INOUT else)
                                IF else < tokens.size() AND tokens[else].type = TokenType.Var_symbol AND tokens[else].value = "ELSE" THEN
                                    VAR skip: Number := else + 1
                                    skip_instruction(tokens, INOUT skip)
                                    contexts.append(ContextEntry(type WITH ContextType.if, if_skip WITH skip))
                                END IF
                            WHEN "0" DO
                                skip_instruction(tokens, INOUT i)
                                IF i < tokens.size() AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "ELSE" THEN
                                    INC i
                                END IF
                            WHEN OTHERS DO
                                ASSERT FALSE, "unexpected cond", cond
                        END CASE
                    WHEN "INTERPRET" DO
                        INC i
                        LET expr: String := evaluate(tokens, INOUT i)
                        TRY
                            LET itokens: Array<Token> := tokenise(expr) & [Token(type WITH TokenType.Special, value WITH ";"), Token(type WITH TokenType.Eos)]
                            contexts.append(ContextEntry(type WITH ContextType.call, call_tokens WITH tokens, call_return_ip WITH i))
                            tokens := itokens
                            i := 0
                        TRAP SyntaxException DO
                            VAR lindex: Number
                            IF find_label(source_tokens, signals["SYNTAX"], OUT lindex) THEN
                                vars["SIGL"] := str(tokens[i].line)
                                contexts := []
                                tokens := source_tokens
                                i := lindex + 1
                            END IF
                        END TRY
                    WHEN "OTHERWISE" DO
                        CASE contexts[LAST].type
                            WHEN ContextType.select DO
                                i := contexts[LAST].select_skip
                                contexts.resize(contexts.size() - 1)
                            WHEN OTHERS DO
                                ASSERT FALSE, "unexpected otherwise", contexts[LAST].type
                        END CASE
                    WHEN "PARSE" DO
                        INC i
                        LET upper: Boolean := tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "UPPER"
                        IF upper THEN
                            INC i
                        END IF
                        do_parse(tokens, INOUT i, upper)
                    WHEN "PROCEDURE" DO
                        INC i
                        VAR expose: Array<String> := []
                        IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "EXPOSE" THEN
                            INC i
                            WHILE tokens[i].type = TokenType.Var_symbol DO
                                expose.append(tokens[i].value)
                                INC i
                            END WHILE
                        END IF
                        -- TODO: introduce new variable scope
                    WHEN "PULL" DO
                        do_parse(tokens, INOUT i, upper WITH TRUE)
                    WHEN "RETURN" DO
                        CASE contexts[LAST].type
                            WHEN ContextType.call DO
                                INC i
                                -- TODO: expression is optional
                                LET r: String := evaluate(tokens, INOUT i)
                                vars["RESULT"] := r
                                tokens := contexts[LAST].call_tokens
                                i := contexts[LAST].call_return_ip
                                contexts.resize(contexts.size() - 1)
                            WHEN OTHERS DO
                                ASSERT FALSE, "unexpected return", contexts[LAST].type
                        END CASE
                    WHEN "SAY" DO
                        INC i
                        IF NOT (tokens[i].type = TokenType.Special AND tokens[i].value = ";") THEN
                            LET s: String := evaluate(tokens, INOUT i)
                            print(s)
                        ELSE
                            INC i
                            print("")
                        END IF
                    WHEN "SELECT" DO
                        VAR end_of_select: Number := i
                        skip_instruction(tokens, INOUT end_of_select)
                        INC i
                        skip_if_ncl(tokens, INOUT i)
                        VAR found: Boolean := FALSE
                        WHILE tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "WHEN" DO
                            INC i
                            LET cond: String := evaluate(tokens, INOUT i)
                            ASSERT tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "THEN"
                            INC i
                            skip_if_ncl(tokens, INOUT i)
                            IF cond = "1" THEN
                                contexts.append(ContextEntry(type WITH ContextType.select, select_skip WITH end_of_select))
                                found := TRUE
                                EXIT WHILE
                            ELSIF cond = "0" THEN
                                skip_instruction(tokens, INOUT i)
                            ELSE
                                ASSERT FALSE, "unexpected cond", cond
                            END IF
                        END WHILE
                        IF NOT found AND tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "OTHERWISE" THEN
                            INC i
                        END IF
                    WHEN "SIGNAL" DO
                        INC i
                        IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "ON" THEN
                            INC i
                            IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value IN ["SYNTAX"] THEN
                                LET signal: String := tokens[i].value
                                VAR label: String := signal
                                INC i
                                IF tokens[i].type = TokenType.Var_symbol AND tokens[i].value = "NAME" THEN
                                    INC i
                                    IF tokens[i].type = TokenType.Var_symbol THEN
                                        label := tokens[i].value
                                        INC i
                                    ELSE
                                        ASSERT FALSE, "label expected", tokens[i]
                                    END IF
                                END IF
                                signals[signal] := label
                            ELSE
                                ASSERT FALSE, "unknown signal type", tokens[i]
                            END IF
                        ELSE
                            ASSERT FALSE, "unimplemented signal syntax", tokens[i]
                        END IF
                    WHEN "WHEN" DO
                        CASE contexts[LAST].type
                            WHEN ContextType.select DO
                                i := contexts[LAST].select_skip
                                contexts.resize(contexts.size() - 1)
                            WHEN OTHERS DO
                                ASSERT FALSE, "unexpected when", contexts[LAST].type
                        END CASE
                    WHEN OTHERS DO
                        LET r: String := evaluate(tokens, INOUT i)
                        _ := os.system(r)
                END CASE
            WHEN TokenType.Eos DO
                CASE contexts[LAST].type
                    WHEN ContextType.call DO
                        tokens := contexts[LAST].call_tokens
                        i := contexts[LAST].call_return_ip
                        contexts.resize(contexts.size() - 1)
                    WHEN OTHERS DO
                        EXIT interpret_loop
                END CASE
            WHEN OTHERS DO
                LET r: String := evaluate(tokens, INOUT i)
                _ := os.system(r)
        END CASE
        IF i = orig_i THEN
            ASSERT FALSE, "we are stuck", tokens[i]
        END IF
        skip_if_ncl(tokens, INOUT i)
    END WHILE
END FUNCTION

BEGIN MAIN
    LET bytes: Bytes := file.readBytes(sys.args[1])
    LET source: String := bytes.decodeToString()
    sourcelines := [""] & string.splitLines(source)
    LET tokens: Array<Token> := tokenise(source)
    --FOREACH t IN tokens INDEX i DO
    --    print("\(i) \(t.type) \(t.value)")
    --END FOREACH
    contexts.append(ContextEntry(call_return_ip WITH -1, call_args WITH [string.join(sys.args[2 TO LAST], " ")]))
    interpret(tokens)
    ASSERT contexts.size() = 1
END MAIN
