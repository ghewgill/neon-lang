/*
 ****************************************************************************
 *
 *                   "DHRYSTONE" Benchmark Program
 *                   -----------------------------
 *
 *  Version:    C, Version 2.1
 *
 *  File:       dhry.h (part 1 of 3)
 *
 *  Date:       May 25, 1988
 *
 *  Author:     Reinhold P. Weicker
 *                      Siemens AG, AUT E 51
 *                      Postfach 3220
 *                      8520 Erlangen
 *                      Germany (West)
 *                              Phone:  [+49]-9131-7-20330
 *                                      (8-17 Central European Time)
 *                              Usenet: ..!mcsun!unido!estevax!weicker
 *
 *              Original Version (in Ada) published in
 *              "Communications of the ACM" vol. 27., no. 10 (Oct. 1984),
 *              pp. 1013 - 1030, together with the statistics
 *              on which the distribution of statements etc. is based.
 *
 *              In this C version, the following C library functions are used:
 *              - strcpy, strcmp (inside the measurement loop)
 *              - printf, scanf (outside the measurement loop)
 *              In addition, Berkeley UNIX system calls "times ()" or "time ()"
 *              are used for execution time measurement. For measurements
 *              on other systems, these calls have to be changed.
 *
 *  Collection of Results:
 *              Reinhold Weicker (address see above) and
 *
 *              Rick Richardson
 *              PC Research. Inc.
 *              94 Apple Orchard Drive
 *              Tinton Falls, NJ 07724
 *                      Phone:  (201) 389-8963 (9-17 EST)
 *                      Usenet: ...!uunet!pcrat!rick
 *
 *      Please send results to Rick Richardson and/or Reinhold Weicker.
 *      Complete information should be given on hardware and software used.
 *      Hardware information includes: Machine type, CPU, type and size
 *      of caches; for microprocessors: clock frequency, memory speed
 *      (number of wait states).
 *      Software information includes: Compiler (and runtime library)
 *      manufacturer and version, compilation switches, OS version.
 *      The Operating System version may give an indication about the
 *      compiler; Dhrystone itself performs no OS calls in the measurement loop.
 *
 *      The complete output generated by the program should be mailed
 *      such that at least some checks for correctness can be made.
 *
 ***************************************************************************
 *
 *  History:    This version C/2.1 has been made for two reasons:
 *
 *              1) There is an obvious need for a common C version of
 *              Dhrystone, since C is at present the most popular system
 *              programming language for the class of processors
 *              (microcomputers, minicomputers) where Dhrystone is used most.
 *              There should be, as far as possible, only one C version of
 *              Dhrystone such that results can be compared without
 *              restrictions. In the past, the C versions distributed
 *              by Rick Richardson (Version 1.1) and by Reinhold Weicker
 *              had small (though not significant) differences.
 *
 *              2) As far as it is possible without changes to the Dhrystone
 *              statistics, optimizing compilers should be prevented from
 *              removing significant statements.
 *
 *              This C version has been developed in cooperation with
 *              Rick Richardson (Tinton Falls, NJ), it incorporates many
 *              ideas from the "Version 1.1" distributed previously by
 *              him over the UNIX network Usenet.
 *              I also thank Chaim Benedelac (National Semiconductor),
 *              David Ditzel (SUN), Earl Killian and John Mashey (MIPS),
 *              Alan Smith and Rafael Saavedra-Barrera (UC at Berkeley)
 *              for their help with comments on earlier versions of the
 *              benchmark.
 *
 *  Changes:    In the initialization part, this version follows mostly
 *              Rick Richardson's version distributed via Usenet, not the
 *              version distributed earlier via floppy disk by Reinhold Weicker.
 *              As a concession to older compilers, names have been made
 *              unique within the first 8 characters.
 *              Inside the measurement loop, this version follows the
 *              version previously distributed by Reinhold Weicker.
 *
 *              At several places in the benchmark, code has been added,
 *              but within the measurement loop only in branches that
 *              are not executed. The intention is that optimizing compilers
 *              should be prevented from moving code out of the measurement
 *              loop, or from removing code altogether. Since the statements
 *              that are executed within the measurement loop have NOT been
 *              changed, the numbers defining the "Dhrystone distribution"
 *              (distribution of statements, operand types and locality)
 *              still hold. Except for sophisticated optimizing compilers,
 *              execution times for this version should be the same as
 *              for previous versions.
 *
 *              Since it has proven difficult to subtract the time for the
 *              measurement loop overhead in a correct way, the loop check
 *              has been made a part of the benchmark. This does have
 *              an impact - though a very minor one - on the distribution
 *              statistics which have been updated for this version.
 *
 *              All changes within the measurement loop are described
 *              and discussed in the companion paper "Rationale for
 *              Dhrystone version 2".
 *
 *              Because of the self-imposed limitation that the order and
 *              distribution of the executed statements should not be
 *              changed, there are still cases where optimizing compilers
 *              may not generate code for some statements. To a certain
 *              degree, this is unavoidable for small synthetic benchmarks.
 *              Users of the benchmark are advised to check code listings
 *              whether code is generated for all statements of Dhrystone.
 *
 *              Version 2.1 is identical to version 2.0 distributed via
 *              the UNIX network Usenet in March 1988 except that it corrects
 *              some minor deficiencies that were found by users of version 2.0.
 *              The only change within the measurement loop is that a
 *              non-executed "else" part was added to the "if" statement in
 *              Func_3, and a non-executed "else" part removed from Proc_3.
 *
 ***************************************************************************
 *
 * Defines:     The following "Defines" are possible:
 *              -DREG=register          (default: Not defined)
 *                      As an approximation to what an average C programmer
 *                      might do, the "register" storage class is applied
 *                      (if enabled by -DREG=register)
 *                      - for local variables, if they are used (dynamically)
 *                        five or more times
 *                      - for parameters if they are used (dynamically)
 *                        six or more times
 *                      Note that an optimal "register" strategy is
 *                      compiler-dependent, and that "register" declarations
 *                      do not necessarily lead to faster execution.
 *              -DNOSTRUCTASSIGN        (default: Not defined)
 *                      Define if the C compiler does not support
 *                      assignment of structures.
 *              -DNOENUMS               (default: Not defined)
 *                      Define if the C compiler does not support
 *                      enumeration types.
 *              -DTIMES                 (default)
 *              -DTIME
 *                      The "times" function of UNIX (returning process times)
 *                      or the "time" function (returning wallclock time)
 *                      is used for measurement.
 *                      For single user machines, "time ()" is adequate. For
 *                      multi-user machines where you cannot get single-user
 *                      access, use the "times ()" function. If you have
 *                      neither, use a stopwatch in the dead of night.
 *                      "printf"s are provided marking the points "Start Timer"
 *                      and "Stop Timer". DO NOT use the UNIX "time(1)"
 *                      command, as this will measure the total time to
 *                      run this program, which will (erroneously) include
 *                      the time to allocate storage (malloc) and to perform
 *                      the initialization.
 *              -DHZ=nnn
 *                      In Berkeley UNIX, the function "times" returns process
 *                      time in 1/HZ seconds, with HZ = 60 for most systems.
 *                      CHECK YOUR SYSTEM DESCRIPTION BEFORE YOU JUST APPLY
 *                      A VALUE.
 *
 ***************************************************************************
 *
 *  Compilation model and measurement (IMPORTANT):
 *
 *  This C version of Dhrystone consists of three files:
 *  - dhry.h (this file, containing global definitions and comments)
 *  - dhry_1.c (containing the code corresponding to Ada package Pack_1)
 *  - dhry_2.c (containing the code corresponding to Ada package Pack_2)
 *
 *  The following "ground rules" apply for measurements:
 *  - Separate compilation
 *  - No procedure merging
 *  - Otherwise, compiler optimizations are allowed but should be indicated
 *  - Default results are those without register declarations
 *  See the companion paper "Rationale for Dhrystone Version 2" for a more
 *  detailed discussion of these ground rules.
 *
 *  For 16-Bit processors (e.g. 80186, 80286), times for all compilation
 *  models ("small", "medium", "large" etc.) should be given if possible,
 *  together with a definition of these models for the compiler system used.
 *
 **************************************************************************
 *
 *  Dhrystone (C version) statistics:
 *
 *  [Comment from the first distribution, updated for version 2.
 *   Note that because of language differences, the numbers are slightly
 *   different from the Ada version.]
 *
 *  The following program contains statements of a high level programming
 *  language (here: C) in a distribution considered representative:
 *
 *    assignments                  52 (51.0 %)
 *    control statements           33 (32.4 %)
 *    procedure, function calls    17 (16.7 %)
 *
 *  103 statements are dynamically executed. The program is balanced with
 *  respect to the three aspects:
 *
 *    - statement type
 *    - operand type
 *    - operand locality
 *         operand global, local, parameter, or constant.
 *
 *  The combination of these three aspects is balanced only approximately.
 *
 *  1. Statement Type:
 *  -----------------             number
 *
 *     V1 = V2                     9
 *       (incl. V1 = F(..)
 *     V = Constant               12
 *     Assignment,                 7
 *       with array element
 *     Assignment,                 6
 *       with record component
 *                                --
 *                                34       34
 *
 *     X = Y +|-|"&&"|"|" Z        5
 *     X = Y +|-|"==" Constant     6
 *     X = X +|- 1                 3
 *     X = Y *|/ Z                 2
 *     X = Expression,             1
 *           two operators
 *     X = Expression,             1
 *           three operators
 *                                --
 *                                18       18
 *
 *     if ....                    14
 *       with "else"      7
 *       without "else"   7
 *           executed        3
 *           not executed    4
 *     for ...                     7  |  counted every time
 *     while ...                   4  |  the loop condition
 *     do ... while                1  |  is evaluated
 *     switch ...                  1
 *     break                       1
 *     declaration with            1
 *       initialization
 *                                --
 *                                34       34
 *
 *     P (...)  procedure call    11
 *       user procedure      10
 *       library procedure    1
 *     X = F (...)
 *             function  call      6
 *       user function        5
 *       library function     1
 *                                --
 *                                17       17
 *                                        ---
 *                                        103
 *
 *    The average number of parameters in procedure or function calls
 *    is 1.82 (not counting the function values as implicit parameters).
 *
 *
 *  2. Operators
 *  ------------
 *                          number    approximate
 *                                    percentage
 *
 *    Arithmetic             32          50.8
 *
 *       +                     21          33.3
 *       -                      7          11.1
 *       *                      3           4.8
 *       / (int div)            1           1.6
 *
 *    Comparison             27           42.8
 *
 *       ==                     9           14.3
 *       /=                     4            6.3
 *       >                      1            1.6
 *       <                      3            4.8
 *       >=                     1            1.6
 *       <=                     9           14.3
 *
 *    Logic                   4            6.3
 *
 *       && (AND-THEN)          1            1.6
 *       |  (OR)                1            1.6
 *       !  (NOT)               2            3.2
 *
 *                           --          -----
 *                           63          100.1
 *
 *
 *  3. Operand Type (counted once per operand reference):
 *  ---------------
 *                          number    approximate
 *                                    percentage
 *
 *     Integer               175        72.3 %
 *     Character              45        18.6 %
 *     Pointer                12         5.0 %
 *     String30                6         2.5 %
 *     Array                   2         0.8 %
 *     Record                  2         0.8 %
 *                           ---       -------
 *                           242       100.0 %
 *
 *  When there is an access path leading to the final operand (e.g. a record
 *  component), only the final data type on the access path is counted.
 *
 *
 *  4. Operand Locality:
 *  -------------------
 *                                number    approximate
 *                                          percentage
 *
 *     local variable              114        47.1 %
 *     global variable              22         9.1 %
 *     parameter                    45        18.6 %
 *        value                        23         9.5 %
 *        reference                    22         9.1 %
 *     function result               6         2.5 %
 *     constant                     55        22.7 %
 *                                 ---       -------
 *                                 242       100.0 %
 *
 *
 *  The program does not compute anything meaningful, but it is syntactically
 *  and semantically correct. All variables have a value assigned to them
 *  before they are used as a source operand.
 *
 *  There has been no explicit effort to account for the effects of a
 *  cache, or to balance the use of long or short displacements for code or
 *  data.
 *
 ***************************************************************************
 */

IMPORT math
IMPORT string

TYPE Enumeration IS ENUM
    Ident_1
    Ident_2
    Ident_3
    Ident_4
    Ident_5
END ENUM

-- General definitions:

TYPE One_Thirty     IS Number
TYPE One_Fifty      IS Number
TYPE Capital_Letter IS String
TYPE Str_30         IS String
TYPE Arr_1_Dim      IS Array<Number>
TYPE Arr_2_Dim      IS Array<Array<Number>>

TYPE Record IS CLASS
    Ptr_Comp: POINTER TO Record
    Discr: Enumeration

    Enum_Comp: Enumeration
    Int_Comp: Number
    Str_Comp: String

    E_Comp_2: Enumeration
    Str_2_Comp: String

    Ch_1_Comp: String
    Ch_2_Comp: String
END CLASS

-- Global Variables:

VAR Ptr_Glob, Next_Ptr_Glob: POINTER TO Record
VAR Int_Glob: Number
VAR Bool_Glob: Boolean
VAR Ch_1_Glob, Ch_2_Glob: String
VAR Arr_1_Glob: Array<Number>
VAR Arr_2_Glob: Array<Array<Number>>

-- variables for time measurement:

IMPORT time

CONSTANT Mic_secs_Per_Second: Number := 1000000.0

CONSTANT Too_Small_Time: Number := 2

VAR Begin_Time, End_Time, User_Time: Number
VAR Microseconds, Dhrystones_Per_Second: Number

-- end of variables for time measurement

FUNCTION Proc_1 (Ptr_Val_Par: POINTER TO Record)
    -- executed once

  VAR Next_Record: POINTER TO Record
  IF VALID Ptr_Val_Par THEN
      Next_Record := Ptr_Val_Par->Ptr_Comp
      IF VALID Next_Record THEN
                                        -- == Ptr_Glob_Next
          -- Local variable, initialized with Ptr_Val_Par->Ptr_Comp,
          -- corresponds to "rename" in Ada, "with" in Pascal

          IF VALID Ptr_Glob THEN
            -- No value copy available. valueCopy(Next_Record, Ptr_Glob)
          END IF
          Ptr_Val_Par->Int_Comp := 5
          Next_Record->Int_Comp := Ptr_Val_Par->Int_Comp
          Next_Record->Ptr_Comp := Ptr_Val_Par->Ptr_Comp
          Proc_3 (INOUT Next_Record->Ptr_Comp)
            -- Ptr_Val_Par->Ptr_Comp->Ptr_Comp == Ptr_Glob->Ptr_Comp
          IF Next_Record->Discr = Enumeration.Ident_1 THEN
            -- then, executed
            Next_Record->Int_Comp := 6
            Proc_6 (Ptr_Val_Par->Enum_Comp,
                    OUT Next_Record->Enum_Comp)
            IF VALID Ptr_Glob AS pg THEN
                Next_Record->Ptr_Comp := pg->Ptr_Comp
            END IF
            Proc_7 (Next_Record->Int_Comp, 10,
                    OUT Next_Record->Int_Comp)
          ELSE
            -- No value copy available. valueCopy(Ptr_Val_Par, Next_Record)
          END IF
      END IF
  END IF
END FUNCTION -- Proc_1


FUNCTION Proc_2 (INOUT Int_Par_Ref: Number)
    -- executed once
    -- *Int_Par_Ref == 1, becomes 4

  VAR Int_Loc: One_Fifty
  VAR Enum_Loc: Enumeration := Enumeration.Ident_1

  Int_Loc := Int_Par_Ref + 10
  REPEAT -- executed once
    IF Ch_1_Glob = "A" THEN
      -- then, executed
      Int_Loc := Int_Loc - 1
      Int_Par_Ref := Int_Loc - Int_Glob
      Enum_Loc := Enumeration.Ident_1
    END IF
  UNTIL Enum_Loc = Enumeration.Ident_1 -- true
END FUNCTION -- Proc_2


FUNCTION Proc_3 (INOUT Ptr_Ref_Par: POINTER TO Record)
    -- executed once
    -- Ptr_Ref_Par becomes Ptr_Glob

  IF VALID Ptr_Glob THEN
    -- then, executed
    Ptr_Ref_Par := Ptr_Glob->Ptr_Comp
    Proc_7 (10, Int_Glob, OUT Ptr_Glob->Int_Comp)
  END IF
END FUNCTION -- Proc_3


FUNCTION Proc_4 () -- without parameters
    -- executed once

  VAR Bool_Loc: Boolean

  Bool_Loc := Ch_1_Glob = "A"
  Bool_Glob := Bool_Loc OR Bool_Glob
  Ch_2_Glob := "B"
END FUNCTION -- Proc_4


FUNCTION Proc_5 () -- without parameters
    -- executed once

  Ch_1_Glob := "A"
  Bool_Glob := FALSE
END FUNCTION -- Proc_5


FUNCTION Func_3 (IN Enum_Par_Val: Enumeration): Boolean
    -- executed once
    -- Enum_Par_Val == Ident_3

  VAR Enum_Loc: Enumeration

  Enum_Loc := Enum_Par_Val
  IF Enum_Loc = Enumeration.Ident_3 THEN
    -- then, executed
    RETURN TRUE
  ELSE -- not executed
    RETURN FALSE
  END IF
END FUNCTION -- Func_3


FUNCTION Proc_6 (IN Enum_Val_Par: Enumeration, OUT Enum_Ref_Par: Enumeration)
    -- executed once
    -- Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2

  Enum_Ref_Par := Enum_Val_Par
  IF NOT Func_3 (Enum_Val_Par) THEN
    -- then, not executed
    Enum_Ref_Par := Enumeration.Ident_4
  END IF
  CASE Enum_Val_Par
    WHEN Enumeration.Ident_1 DO
      Enum_Ref_Par := Enumeration.Ident_1
    WHEN Enumeration.Ident_2 DO
      IF Int_Glob > 100 THEN
        -- then
        Enum_Ref_Par := Enumeration.Ident_1
      ELSE
        Enum_Ref_Par := Enumeration.Ident_4
      END IF
    WHEN Enumeration.Ident_3 DO -- executed
      Enum_Ref_Par := Enumeration.Ident_2
    WHEN Enumeration.Ident_4 DO
    WHEN Enumeration.Ident_5 DO
      Enum_Ref_Par := Enumeration.Ident_3
  END CASE
END FUNCTION -- Proc_6


FUNCTION Proc_7 (IN Int_1_Par_Val: One_Fifty, IN Int_2_Par_Val: One_Fifty, OUT Int_Par_Ref: One_Fifty)
    -- executed three times
    -- first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,
    --                  Int_Par_Ref becomes 7
    -- second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5,
    --                  Int_Par_Ref becomes 17
    -- third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10,
    --                  Int_Par_Ref becomes 18

  VAR Int_Loc: One_Fifty

  Int_Loc := Int_1_Par_Val + 2
  Int_Par_Ref := Int_2_Par_Val + Int_Loc
END FUNCTION -- Proc_7


FUNCTION Proc_8 (INOUT Arr_1_Par_Ref: Arr_1_Dim, INOUT Arr_2_Par_Ref: Arr_2_Dim, IN Int_1_Par_Val: Number, IN Int_2_Par_Val: Number)
    -- executed once
    -- Int_Par_Val_1 == 3
    -- Int_Par_Val_2 == 7

  VAR Int_Index: One_Fifty
  VAR Int_Loc: One_Fifty

  Int_Loc := Int_1_Par_Val + 5
  Arr_1_Par_Ref [Int_Loc] := Int_2_Par_Val
  Arr_1_Par_Ref [Int_Loc+1] := Arr_1_Par_Ref [Int_Loc]
  Arr_1_Par_Ref [Int_Loc+30] := Int_Loc
  Int_Index := Int_Loc
  WHILE Int_Index <= Int_Loc+1 DO
    Arr_2_Par_Ref [Int_Loc] [Int_Index] := Int_Loc
    Int_Index := Int_Index + 1
  END WHILE
  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] := Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] + 1
  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] := Arr_1_Par_Ref [Int_Loc]
  Int_Glob := 5
END FUNCTION -- Proc_8


FUNCTION Func_1 (IN Ch_1_Par_Val: String, IN Ch_2_Par_Val: String): Enumeration
    -- executed three times
    -- first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'
    -- second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'
    -- third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'

  VAR Ch_1_Loc: Capital_Letter
  VAR Ch_2_Loc: Capital_Letter

  Ch_1_Loc := Ch_1_Par_Val
  Ch_2_Loc := Ch_1_Loc
  IF Ch_2_Loc <> Ch_2_Par_Val THEN
    -- then, executed
    RETURN Enumeration.Ident_1
  ELSE  -- not executed
    Ch_1_Glob := Ch_1_Loc
    RETURN Enumeration.Ident_2
  END IF
END FUNCTION -- Func_1


FUNCTION Func_2 (IN Str_1_Par_Ref: String, IN Str_2_Par_Ref: String): Boolean
    -- executed once
    -- Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING"
    -- Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING"

  VAR Int_Loc: One_Thirty
  VAR Ch_Loc: Capital_Letter := ""

  Int_Loc := 2
  WHILE Int_Loc <= 2 DO -- loop body executed once
    IF Func_1 (Str_1_Par_Ref[Int_Loc],
               Str_2_Par_Ref[Int_Loc+1]) = Enumeration.Ident_1 THEN
      -- then, executed
      Ch_Loc := "A"
      Int_Loc := Int_Loc + 1
    END IF
  END WHILE
  IF Ch_Loc >= "W" AND Ch_Loc < "Z" THEN
    -- then, not executed
    Int_Loc := 7
  END IF
  IF Ch_Loc = "R" THEN
    -- then, not executed
    RETURN TRUE
  ELSE -- executed
    IF Str_1_Par_Ref > Str_2_Par_Ref THEN
      -- then, not executed
      Int_Loc := Int_Loc + 7
      Int_Glob := Int_Loc
      RETURN TRUE
    ELSE -- executed
      RETURN FALSE
    END IF
  END IF
END FUNCTION -- Func_2


FUNCTION main()

  -- main program, corresponds to procedures
  -- Main and Proc_0 in the Ada version

  VAR Int_1_Loc: One_Fifty := 0
  VAR Int_2_Loc: One_Fifty := 0
  VAR Int_3_Loc: One_Fifty := 0
  VAR Ch_Index: String
  VAR Enum_Loc: Enumeration := Enumeration.Ident_1
  VAR Str_1_Loc: Str_30
  VAR Str_2_Loc: Str_30 := ""
  VAR Run_Index: Number
  VAR Number_Of_Runs: Number

  -- Initializations

  Next_Ptr_Glob := NEW Record
  Ptr_Glob := NEW Record

  IF VALID Ptr_Glob THEN
      Ptr_Glob->Ptr_Comp                    := Next_Ptr_Glob
      Ptr_Glob->Discr                       := Enumeration.Ident_1
      Ptr_Glob->Enum_Comp                   := Enumeration.Ident_3
      Ptr_Glob->Int_Comp                    := 40
      Ptr_Glob->Str_Comp                    := "DHRYSTONE PROGRAM, SOME STRING"
  END IF
  Str_1_Loc := "DHRYSTONE PROGRAM, 1'ST STRING"

  Arr_2_Glob [28] := []     -- Make sure the array is big enough.
  Arr_2_Glob [8][7] := 10

  print ("")
  print ("Dhrystone Benchmark, Version 2.1 (Language: Neon)")
  print ("")
  print ("Please give the number of runs through the benchmark: ")
  Number_Of_Runs := 10000 -- TODO to_number(input())
  print ("")

  print ("Execution starts, " & str(Number_Of_Runs) & " runs through Dhrystone")

  /****************
  ** Start timer **
  ****************/

  Begin_Time := time.now ()

  Run_Index := 1
  WHILE Run_Index <= Number_Of_Runs DO

    Proc_5()
    Proc_4()
      -- Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true
    Int_1_Loc := 2
    Int_2_Loc := 3
    Str_2_Loc := "DHRYSTONE PROGRAM, 2'ND STRING"
    Enum_Loc := Enumeration.Ident_2
    Bool_Glob := NOT Func_2 (Str_1_Loc, Str_2_Loc)
      -- Bool_Glob == 1
    WHILE Int_1_Loc < Int_2_Loc DO  -- loop body executed once
      Int_3_Loc := 5 * Int_1_Loc - Int_2_Loc
        -- Int_3_Loc == 7
      Proc_7 (Int_1_Loc, Int_2_Loc, OUT Int_3_Loc)
        -- Int_3_Loc == 7
      Int_1_Loc := Int_1_Loc + 1
    END WHILE
      -- Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7
    Proc_8 (INOUT Arr_1_Glob, INOUT Arr_2_Glob, Int_1_Loc, Int_3_Loc)
      -- Int_Glob == 5
    Proc_1 (Ptr_Glob)
    Ch_Index := "A"
    WHILE Ch_Index <= Ch_2_Glob DO
                             -- loop body executed twice
      IF Enum_Loc = Func_1 (Ch_Index, "C") THEN
          -- then, not executed
        Proc_6 (Enumeration.Ident_1, OUT Enum_Loc)
        Str_2_Loc := "DHRYSTONE PROGRAM, 3'RD STRING"
        Int_2_Loc := Run_Index
        Int_Glob := Run_Index
      END IF
      Ch_Index := string.fromCodePoint(string.toCodePoint(Ch_Index) + 1)
    END WHILE
      -- Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7
    Int_2_Loc := Int_2_Loc * Int_1_Loc
    Int_1_Loc := math.floor(Int_2_Loc / Int_3_Loc)
    Int_2_Loc := 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc
      -- Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7
    Proc_2 (INOUT Int_1_Loc)
      -- Int_1_Loc == 5

    Run_Index := Run_Index + 1
  END WHILE -- loop "for Run_Index"

  /***************
  ** Stop timer **
  ***************/

  End_Time := time.now ()

  print ("Execution ends")
  print ("")
  print ("Final values of the variables used in the benchmark:")
  print ("")
  print ("Int_Glob:            " & str(Int_Glob))
  print ("        should be:   " & str(5))
  print ("Bool_Glob:           " & Bool_Glob.toString())
  print ("        should be:   TRUE")
  print ("Ch_1_Glob:           " & Ch_1_Glob)
  print ("        should be:   " & "A")
  print ("Ch_2_Glob:           " & Ch_2_Glob)
  print ("        should be:   " & "B")
  print ("Arr_1_Glob[8]:       " & str(Arr_1_Glob[8]))
  print ("        should be:   " & str(7))
  print ("Arr_2_Glob[8][7]:    " & str(Arr_2_Glob[8][7]))
  print ("        should be:   Number_Of_Runs + 10")
  IF VALID Ptr_Glob THEN
    print ("Ptr_Glob->")
    print ("  Ptr_Comp:          ") -- & Ptr_Glob->Ptr_Comp)
    print ("        should be:   (implementation-dependent)")
    print ("  Discr:             " & Ptr_Glob->Discr.toString())
    print ("        should be:   " & "Ident_1")
    print ("  Enum_Comp:         " & Ptr_Glob->Enum_Comp.toString())
    print ("        should be:   " & "Ident_3")
    print ("  Int_Comp:          " & str(Ptr_Glob->Int_Comp))
    print ("        should be:   " & str(17))
    print ("  Str_Comp:          " & Ptr_Glob->Str_Comp)
    print ("        should be:   DHRYSTONE PROGRAM, SOME STRING")
  END IF
  IF VALID Next_Ptr_Glob THEN
    print ("Next_Ptr_Glob->")
    print ("  Ptr_Comp:          ") -- & Next_Ptr_Glob->Ptr_Comp)
    print ("        should be:   (implementation-dependent), same as above")
    print ("  Discr:             " & Next_Ptr_Glob->Discr.toString())
    print ("        should be:   " & "Ident_1")
    print ("  Enum_Comp:         " & Next_Ptr_Glob->Enum_Comp.toString())
    print ("        should be:   " & "Ident_2")
    print ("  Int_Comp:          " & str(Next_Ptr_Glob->Int_Comp))
    print ("        should be:   " & str(18))
    print ("  Str_Comp:          " & Next_Ptr_Glob->Str_Comp)
    print ("        should be:   DHRYSTONE PROGRAM, SOME STRING")
  END IF
  print ("Int_1_Loc:           " & str(Int_1_Loc))
  print ("        should be:   " & str(5))
  print ("Int_2_Loc:           " & str(Int_2_Loc))
  print ("        should be:   " & str(13))
  print ("Int_3_Loc:           " & str(Int_3_Loc))
  print ("        should be:   " & str(7))
  print ("Enum_Loc:            " & Enum_Loc.toString())
  print ("        should be:   " & "Ident_2")
  print ("Str_1_Loc:           " &  Str_1_Loc)
  print ("        should be:   DHRYSTONE PROGRAM, 1'ST STRING")
  print ("Str_2_Loc:           " & Str_2_Loc)
  print ("        should be:   DHRYSTONE PROGRAM, 2'ND STRING")
  print ("")

  User_Time := End_Time - Begin_Time

  IF User_Time < Too_Small_Time THEN
    print ("Measured time too small to obtain meaningful results")
    print ("Please increase number of runs")
    print ("")
  ELSE
    Microseconds := User_Time * Mic_secs_Per_Second / Number_Of_Runs
    Dhrystones_Per_Second := Number_Of_Runs / User_Time
    print ("Microseconds for one run through Dhrystone: " & str(Microseconds))
    print ("Dhrystones per Second:                      " & str(Dhrystones_Per_Second))
    print ("")
  END IF

END FUNCTION

main()
