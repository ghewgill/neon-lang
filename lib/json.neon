%|
 |  File: json
 |
 |  Functions for reading and writing files in JSON format (<http://json.org>).
 |%

EXPORT decode
EXPORT encode

% TODO: This encoder and decoder does not handle all backslash
% character escapes yet.
% TODO: Also, this could probably be improved a lot by using regex.

%|
 |  Exception: JsonFormatException
 |
 |  Indicates that a formatting error was encountered when reading JSON.
 |%
EXCEPTION JsonFormatException

FUNCTION skipWhitespace(json: String, INOUT index: Number)
    WHILE index < json.length() AND (json[index] = " " OR json[index] = "\t" OR json[index] = "\r" OR json[index] = "\n") DO
        INC index
    END WHILE
END FUNCTION

FUNCTION decodePart(json: String, INOUT index: Number): Object
    skipWhitespace(json, INOUT index)
    CASE json[index]
        WHEN "a" TO "z" DO
            LET start: Number := index
            WHILE index < json.length() AND "a" <= json[index] <= "z" DO
                INC index
            END WHILE
            LET s: String := json[start TO index-1]
            CASE s
                WHEN "null" DO
                    RETURN NIL
                WHEN "false" DO
                    RETURN FALSE
                WHEN "true" DO
                    RETURN TRUE
                WHEN OTHERS DO
                    RAISE JsonFormatException(info WITH "null or false or true expected")
            END CASE
        WHEN "-", "0" TO "9" DO
            LET start: Number := index
            WHILE index < json.length() AND ("0" <= json[index] <= "9" OR json[index] = "-" OR json[index] = "+" OR json[index] = "." OR json[index] = "e" OR json[index] = "E") DO
                INC index
            END WHILE
            RETURN num(json[start TO index-1])
        WHEN "\"" DO
            INC index
            VAR t: String := ""
            WHILE index < json.length() AND json[index] <> "\"" DO
                IF json[index] = "\\" THEN
                    % TODO: This just skips over the backslash.
                    % Need to add specific processing for control characters.
                    INC index
                END IF
                t.append(json[index])
                INC index
            END WHILE
            INC index
            RETURN t
        WHEN "[" DO
            INC index
            VAR a: Array<Object> := []
            LOOP
                skipWhitespace(json, INOUT index)
                IF json[index] = "]" THEN
                    EXIT LOOP
                END IF
                a.append(decodePart(json, INOUT index))
                skipWhitespace(json, INOUT index)
                IF json[index] = "," THEN
                    INC index
                ELSIF json[index] <> "]" THEN
                    RAISE JsonFormatException(info WITH ", or ] expected")
                END IF
            END LOOP
            INC index
            RETURN a
        WHEN "{" DO
            INC index
            VAR d: Dictionary<Object> := {}
            LOOP
                skipWhitespace(json, INOUT index)
                IF json[index] = "}" THEN
                    EXIT LOOP
                END IF
                LET vkey: Object := decodePart(json, INOUT index)
                %IF vkey.getType() <> Type.string THEN
                %    RAISE JsonFormatException(info WITH "string key expected")
                %END IF
                LET key: String := vkey
                skipWhitespace(json, INOUT index)
                IF json[index] <> ":" THEN
                    RAISE JsonFormatException(info WITH ": expected")
                END IF
                INC index
                d[key] := decodePart(json, INOUT index)
                skipWhitespace(json, INOUT index)
                IF json[index] = "," THEN
                    INC index
                ELSIF json[index] <> "}" THEN
                    RAISE JsonFormatException(info WITH ", or } expected")
                END IF
            END LOOP
            INC index
            RETURN d
    END CASE
    RETURN NIL
END FUNCTION

%|
 |  Function: decode
 |
 |  Decode JSON data in a string to a result in a <Object>.
 |%
FUNCTION decode(json: String): Object
    VAR i: Number := 0
    RETURN decodePart(json, INOUT i)
END FUNCTION

%|
 |  Function: encode
 |
 |  Encode a value in a <Object> to JSON data in a string.
 |%
FUNCTION encode(data: Object): String
    % TODO: use CASE ISA when available
    IF data.isNull() THEN
        RETURN "null"
    END IF
    IF data ISA Boolean THEN
        RETURN (IF data THEN "true" ELSE "false")
    END IF
    IF data ISA Number THEN
        RETURN str(data)
    END IF
    IF data ISA String THEN
        RETURN "\"" & data & "\""
    END IF
    IF data ISA Array<Object> THEN
        VAR r: String := "["
        LET a: Array<Object> := data
        FOREACH x IN a DO
            IF r.length() > 1 THEN
                r.append(",")
            END IF
            r.append(encode(x))
        END FOREACH
        r.append("]")
        RETURN r
    END IF
    IF data ISA Dictionary<Object> THEN
        VAR r: String := "{"
        LET d: Dictionary<Object> := data
        LET keys: Array<String> := d.keys()
        % TODO: This should just be d.keys(), see t/foreach-value.neon
        FOREACH x IN keys DO
            IF r.length() > 1 THEN
                r.append(",")
            END IF
            r.append(encode(x) & ":" & encode(d[x]))
        END FOREACH
        r.append("}")
        RETURN r
    END IF
    RETURN "?unknown"
END FUNCTION
