%|
 |  File: struct
 |
 |  Functions for working with fixed-size structures.
 |%

EXPORT Struct
EXPORT Field
EXPORT Type
EXPORT make
EXPORT field

IMPORT bitwise
IMPORT variant

%|
 |  Enumeration: Type
 |
 |  The type of a field.
 |
 |  Values:
 |      bool - boolean
 |      int - integer
 |      string - string
 |      bytes - bytes
 |%
TYPE Type IS ENUM
    bool
    int
    string
    bytes
END ENUM

%|
 |  Type: Field
 |
 |  Represents a field in a structure.
 |%
TYPE Field IS RECORD
    name: String
    type: Type
    width: Number
END RECORD

%|
 |  Type: Struct
 |
 |  Represents a complete structure as a sequence of fields.
 |%
TYPE Struct IS RECORD
    PRIVATE fields: Array<Field>
END RECORD

%|
 |  Function: make
 |
 |  Make a <Struct> based on an array of <Fields>.
 |%
FUNCTION make(fields: Array<Field>): Struct
    RETURN Struct(fields)
END FUNCTION

%|
 |  Function: field
 |
 |  Helper function to create <Field> records.
 |%
FUNCTION field(name: String, type: Type, width: Number): Field
    RETURN Field(name, type, width)
END FUNCTION

%|
 |  Function: Struct.pack
 |
 |  Convert a dictionary of values into a structure.
 |%
FUNCTION Struct.pack(self: Struct, values: Dictionary<variant.Variant>): Bytes
    VAR buf: Array<Number>
    FOR f := 0 TO self.fields.size() - 1 DO
        IF self.fields[f].name IN values THEN
            CASE self.fields[f].type
                WHEN Type.bool DO
                    LET b: Boolean := values[self.fields[f].name].getBoolean()
                    buf.append(IF b THEN 1 ELSE 0)
                WHEN Type.int DO
                    LET n: Number := values[self.fields[f].name].getNumber()
                    buf.append(bitwise.and32(bitwise.shiftRight32(n, 24), 0xff))
                    buf.append(bitwise.and32(bitwise.shiftRight32(n, 16), 0xff))
                    buf.append(bitwise.and32(bitwise.shiftRight32(n, 8), 0xff))
                    buf.append(bitwise.and32(n, 0xff))
                WHEN Type.string DO
                    LET s: String := values[self.fields[f].name].getString()
                    FOR i := 0 TO self.fields[f].width - 1 DO
                        buf.append(IF i < s.length() THEN ord(s[i]) ELSE 0)
                    END FOR
                WHEN Type.bytes DO
                    LET a: Array<Number> := values[self.fields[f].name].getBytes().toArray()
                    FOR i := 0 TO self.fields[f].width - 1 DO
                        buf.append(IF i < a.size() THEN a[i] ELSE 0)
                    END FOR
            END CASE
        ELSE
            buf.resize(buf.size() + self.fields[f].width)
        END IF
    END FOR
    VAR r: Bytes
    r.fromArray(buf)
    RETURN r
END FUNCTION

%|
 |  Function: Struct.sizeof
 |
 |  Return the total size of a structure definition.
 |%
FUNCTION Struct.sizeof(self: Struct): Number
    VAR r: Number
    FOR f := 0 TO self.fields.size() - 1 DO
        r := r + self.fields[f].width
    END FOR
    RETURN r
END FUNCTION

%|
 |  Function: Struct.unpack
 |
 |  Convert a structure into a dictionary of values.
 |%
FUNCTION Struct.unpack(self: Struct, data: Bytes): Dictionary<variant.Variant>
    VAR r: Dictionary<variant.Variant>
    LET a: Array<Number> := data.toArray()
    VAR i: Number := 0
    FOR f := 0 TO self.fields.size() - 1 DO
        CASE self.fields[f].type
            WHEN Type.bool DO
                r[self.fields[f].name] := variant.makeBoolean(a[i] # 0)
                inc(i)
            WHEN Type.int DO
                r[self.fields[f].name] := variant.makeNumber(
                    bitwise.shiftLeft32(a[i    ], 24) +
                    bitwise.shiftLeft32(a[i + 1], 16) +
                    bitwise.shiftLeft32(a[i + 2],  8) +
                    a[i + 3])
                i := i + 4
            WHEN Type.string DO
                VAR s: String
                FOR j := 0 TO self.fields[f].width - 1 DO
                    IF a[i + j] = 0 THEN
                        EXIT FOR
                    END IF
                    s.append(chr(a[i + j]))
                END FOR
                r[self.fields[f].name] := variant.makeString(s)
                i := i + self.fields[f].width
            WHEN Type.bytes DO
                VAR b: Bytes
                b.fromArray(a[i TO i + self.fields[f].width - 1])
                r[self.fields[f].name] := variant.makeBytes(b)
                i := i + self.fields[f].width
        END CASE
    END FOR
    RETURN r
END FUNCTION
