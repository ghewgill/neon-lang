IMPORT base
IMPORT string

EXPORT Result
EXPORT Opcode
EXPORT Regex

--EXPORT dump
EXPORT prepare
EXPORT search
EXPORT searchRegex

CONSTANT Debug := TRUE

TYPE Result IS CHOICE
    noMatch
    match: Array<String>
END CHOICE

TYPE Opcode IS CHOICE
    any
    char: String
    begin
    end
    save: Number
    match
    jump: Array<Number>
END CHOICE

TYPE Regex IS Array<Opcode>

INTERFACE Expr
    FUNCTION dump(self: Expr): String
    FUNCTION reduce(self: Expr): Expr
    FUNCTION size(self: Expr): Number
    FUNCTION compile(self: Expr, INOUT regex: Regex)
END INTERFACE

TYPE ExprSequence IS CLASS IMPLEMENTS Expr
    exprs: Array<VALID POINTER TO Expr>
END CLASS

FUNCTION ExprSequence.dump(self: VALID POINTER TO ExprSequence): String
    VAR r := ""
    FOREACH e IN self->exprs DO
        r.append(e->dump())
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION ExprSequence.reduce(self: VALID POINTER TO ExprSequence): POINTER TO Expr
    VAR a: Array<VALID POINTER TO Expr> := []
    FOREACH e IN self->exprs DO
        a.append(e->reduce())
    END FOREACH
    RETURN NEW ExprSequence(exprs WITH a)
END FUNCTION

FUNCTION ExprSequence.size(self: VALID POINTER TO ExprSequence): Number
    VAR r := 0
    FOREACH e IN self->exprs DO
        r := r + e->size()
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION ExprSequence.compile(self: VALID POINTER TO ExprSequence, INOUT regex: Regex)
    FOREACH e IN self->exprs DO
        e->compile(INOUT regex)
    END FOREACH
END FUNCTION

TYPE ExprLiteral IS CLASS IMPLEMENTS Expr
    literal: String
END CLASS

FUNCTION ExprLiteral.dump(self: VALID POINTER TO ExprLiteral): String
    RETURN self->literal
END FUNCTION

FUNCTION ExprLiteral.reduce(self: VALID POINTER TO ExprLiteral): POINTER TO Expr
    RETURN self
END FUNCTION

FUNCTION ExprLiteral.size(self: VALID POINTER TO ExprLiteral): Number
    RETURN 1
END FUNCTION

FUNCTION ExprLiteral.compile(self: VALID POINTER TO ExprLiteral, INOUT regex: Regex)
    regex.append(Opcode.char(self->literal))
END FUNCTION

TYPE ExprClass IS CLASS IMPLEMENTS Expr
    chars: Array<String>
    complement: Boolean
END CLASS

FUNCTION ExprClass.dump(self: VALID POINTER TO ExprClass): String
    RETURN "[" & (IF self->complement THEN "^" ELSE "") & string.join(self->chars, "") & "]"
END FUNCTION

FUNCTION ExprClass.reduce(self: VALID POINTER TO ExprClass): POINTER TO Expr
    VAR a: Array<VALID POINTER TO Expr> := []
    IF self->complement THEN
        FOR x := 0 TO 255 DO
            LET c := string.fromCodePoint(x)
            IF c NOT IN self->chars THEN
                a.append(NEW ExprLiteral(literal WITH c))
            END IF
        END FOR
    ELSE
        FOREACH c IN self->chars DO
            a.append(NEW ExprLiteral(literal WITH c))
        END FOREACH
    END IF
    RETURN NEW ExprAlternative(alternatives WITH a)
END FUNCTION

FUNCTION ExprClass.size(self: VALID POINTER TO ExprClass): Number
    ASSERT FALSE
    RETURN 0
END FUNCTION

FUNCTION ExprClass.compile(self: VALID POINTER TO ExprClass, INOUT regex: Regex)
    ASSERT FALSE
END FUNCTION

TYPE ExprAny IS CLASS IMPLEMENTS Expr
END CLASS

FUNCTION ExprAny.dump(self: VALID POINTER TO ExprAny): String
    RETURN "."
END FUNCTION

FUNCTION ExprAny.reduce(self: VALID POINTER TO ExprAny): POINTER TO Expr
    RETURN self
END FUNCTION

FUNCTION ExprAny.size(self: VALID POINTER TO ExprAny): Number
    RETURN 1
END FUNCTION

FUNCTION ExprAny.compile(self: VALID POINTER TO ExprAny, INOUT regex: Regex)
    regex.append(Opcode.any)
END FUNCTION

TYPE ExprOpt IS CLASS IMPLEMENTS Expr
    expr: VALID POINTER TO Expr
END CLASS

FUNCTION ExprOpt.dump(self: VALID POINTER TO ExprOpt): String
    RETURN self->expr->dump() & "?"
END FUNCTION

FUNCTION ExprOpt.reduce(self: VALID POINTER TO ExprOpt): POINTER TO Expr
    self->expr := self->expr->reduce()
    RETURN self
END FUNCTION

FUNCTION ExprOpt.size(self: VALID POINTER TO ExprOpt): Number
    RETURN 1 + self->expr->size()
END FUNCTION

FUNCTION ExprOpt.compile(self: VALID POINTER TO ExprOpt, INOUT regex: Regex)
    regex.append(Opcode.jump([regex.size() + 1, regex.size() + 1 + self->expr->size()]))
    self->expr->compile(INOUT regex)
END FUNCTION

TYPE ExprStar IS CLASS IMPLEMENTS Expr
    expr: VALID POINTER TO Expr
END CLASS

FUNCTION ExprStar.dump(self: VALID POINTER TO ExprStar): String
    RETURN "\(self->expr->dump())*"
END FUNCTION

FUNCTION ExprStar.reduce(self: VALID POINTER TO ExprStar): POINTER TO Expr
    self->expr := self->expr->reduce()
    RETURN self
END FUNCTION

FUNCTION ExprStar.size(self: VALID POINTER TO ExprStar): Number
    RETURN 1 + self->expr->size() + 1
END FUNCTION

FUNCTION ExprStar.compile(self: VALID POINTER TO ExprStar, INOUT regex: Regex)
    LET top := regex.size()
    regex.append(Opcode.jump([regex.size() + 1, regex.size() + 1 + self->expr->size() + 1]))
    self->expr->compile(INOUT regex)
    regex.append(Opcode.jump([top]))
END FUNCTION

TYPE ExprRepeat IS CLASS IMPLEMENTS Expr
    minimum: Number
    maximum: Number
    expr: VALID POINTER TO Expr
END CLASS

FUNCTION ExprRepeat.dump(self: VALID POINTER TO ExprRepeat): String
    RETURN "\(self->expr->dump()){\(self->minimum),\(self->maximum)}"
END FUNCTION

FUNCTION ExprRepeat.reduce(self: VALID POINTER TO ExprRepeat): POINTER TO Expr
    LET r := NEW ExprSequence(exprs WITH [])
    LET rexpr := self->expr->reduce()
    FOR i := 1 TO self->minimum DO
        r->exprs.append(rexpr)
    END FOR
    IF self->maximum < 0 THEN
        r->exprs.append(NEW ExprStar(expr WITH rexpr))
    ELSE
        FOR i := self->minimum + 1 TO self->maximum DO
            r->exprs.append(NEW ExprOpt(expr WITH rexpr))
        END FOR
    END IF
    RETURN r
END FUNCTION

FUNCTION ExprRepeat.size(self: VALID POINTER TO ExprRepeat): Number
    ASSERT FALSE
    RETURN 0
END FUNCTION

FUNCTION ExprRepeat.compile(self: VALID POINTER TO ExprRepeat, INOUT regex: Regex)
    ASSERT FALSE
END FUNCTION

TYPE ExprBegin IS CLASS IMPLEMENTS Expr
END CLASS

FUNCTION ExprBegin.dump(self: VALID POINTER TO ExprBegin): String
    RETURN "^"
END FUNCTION

FUNCTION ExprBegin.reduce(self: VALID POINTER TO ExprBegin): POINTER TO Expr
    RETURN self
END FUNCTION

FUNCTION ExprBegin.size(self: VALID POINTER TO ExprBegin): Number
    RETURN 1
END FUNCTION

FUNCTION ExprBegin.compile(self: VALID POINTER TO ExprBegin, INOUT regex: Regex)
    regex.append(Opcode.begin)
END FUNCTION

TYPE ExprEnd IS CLASS IMPLEMENTS Expr
END CLASS

FUNCTION ExprEnd.dump(self: VALID POINTER TO ExprEnd): String
    RETURN "$"
END FUNCTION

FUNCTION ExprEnd.reduce(self: VALID POINTER TO ExprEnd): POINTER TO Expr
    RETURN self
END FUNCTION

FUNCTION ExprEnd.size(self: VALID POINTER TO ExprEnd): Number
    RETURN 1
END FUNCTION

FUNCTION ExprEnd.compile(self: VALID POINTER TO ExprEnd, INOUT regex: Regex)
    regex.append(Opcode.end)
END FUNCTION

TYPE ExprGroup IS CLASS IMPLEMENTS Expr
    index: Number
    expr: POINTER TO Expr
END CLASS

FUNCTION ExprGroup.dump(self: VALID POINTER TO ExprGroup): String
    RETURN self->expr->dump()
END FUNCTION

FUNCTION ExprGroup.reduce(self: VALID POINTER TO ExprGroup): POINTER TO Expr
    self->expr := self->expr->reduce()
    RETURN self
END FUNCTION

FUNCTION ExprGroup.size(self: VALID POINTER TO ExprGroup): Number
    RETURN 1 + self->expr->size() + 1
END FUNCTION

FUNCTION ExprGroup.compile(self: VALID POINTER TO ExprGroup, INOUT regex: Regex)
    regex.append(Opcode.save(2*self->index))
    self->expr->compile(INOUT regex)
    regex.append(Opcode.save(2*self->index+1))
END FUNCTION

TYPE ExprAlternative IS CLASS IMPLEMENTS Expr
    alternatives: Array<POINTER TO Expr>
END CLASS

FUNCTION ExprAlternative.dump(self: VALID POINTER TO ExprAlternative): String
    VAR r := ""
    FOREACH a IN self->alternatives DO
        IF r.length() > 0 THEN
            r.append("|")
        END IF
        r.append(a->dump())
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION ExprAlternative.reduce(self: VALID POINTER TO ExprAlternative): POINTER TO Expr
    FOR i := 0 TO self->alternatives.size()-1 DO
        self->alternatives[i] := self->alternatives[i]->reduce()
    END FOR
    RETURN self
END FUNCTION

FUNCTION ExprAlternative.size(self: VALID POINTER TO ExprAlternative): Number
    VAR r := 0
    FOREACH a IN self->alternatives DO
        r := r + 1 + a->size()
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION ExprAlternative.compile(self: VALID POINTER TO ExprAlternative, INOUT regex: Regex)
    LET out := regex.size() + self->size()
    VAR jumps := [regex.size() + 1]
    FOREACH a IN self->alternatives[0 TO LAST-1] DO
        jumps.append(jumps[LAST] + a->size() + 1)
    END FOREACH
    regex.append(Opcode.jump(jumps))
    FOREACH a IN self->alternatives INDEX i DO
        a->compile(INOUT regex)
        IF i + 1 < self->alternatives.size() THEN
            regex.append(Opcode.jump([out]))
        END IF
    END FOREACH
END FUNCTION

FUNCTION parsePart(pattern: String, ignoreCase: Boolean, INOUT i: Number): VALID POINTER TO Expr
    VAR a: POINTER TO ExprAlternative := NIL
    VAR r: VALID POINTER TO ExprSequence := NEW ExprSequence
    VAR groupIndex := 0
    WHILE i < pattern.length() DO
        CASE pattern[i]
            WHEN "^" DO
                r->exprs.append(NEW ExprBegin)
            WHEN "$" DO
                r->exprs.append(NEW ExprEnd)
            WHEN "." DO
                r->exprs.append(NEW ExprAny)
            WHEN "[" DO
                INC i
                LET start := i
                VAR s: Array<String> := []
                VAR complement := FALSE
                WHILE i < pattern.length() DO
                    IF pattern[i] = "]" AND s.size() > 0 THEN
                        EXIT WHILE
                    ELSIF pattern[i] = "^" AND i = start THEN
                        complement := TRUE
                    ELSIF pattern[i] = "-" AND pattern[i+1] <> "]" AND s.size() > 0 THEN
                        INC i
                        VAR c := pattern[i]
                        IF c = "\\" AND pattern[i+1] = "x" THEN
                            c := string.fromCodePoint(base.fromHex(pattern[i+2 TO i+3]))
                            i := i + 2
                        END IF
                        FOR x := string.toCodePoint(s[LAST]) + 1 TO string.toCodePoint(c) DO
                            s.append(string.fromCodePoint(x))
                        END FOR
                    ELSIF pattern[i] = "\\" THEN
                        INC i
                        CASE pattern[i]
                            WHEN "d" DO
                                s.extend(["0","1","2","3","4","5","6","7","8","9"])
                            WHEN "x" DO
                                s.append(string.fromCodePoint(base.fromHex(pattern[i+1 TO i+2])))
                                i := i + 2
                            WHEN OTHERS DO
                                s.append(pattern[i])
                        END CASE
                    ELSE
                        s.append(pattern[i])
                    END IF
                    INC i
                END WHILE
                ASSERT pattern[i] = "]"
                IF ignoreCase AND string.lower(string.join(s, "")) <> string.upper(string.join(s, "")) THEN
                    VAR t: Array<String> := []
                    FOREACH c IN s DO
                        t.append(string.lower(c))
                        t.append(string.upper(c))
                    END FOREACH
                    s := t
                END IF
                r->exprs.append(NEW ExprClass(chars WITH s, complement WITH complement))
            WHEN "?" DO
                CHECK r->exprs.size() > 0 ELSE
                    ASSERT FALSE
                    EXIT PROCESS FAILURE
                END CHECK
                IF i+1 < pattern.length() AND pattern[i+1] = "?" THEN
                    INC i
                    r->exprs[LAST] := NEW ExprOpt(expr WITH r->exprs[LAST])
                ELSE
                    r->exprs[LAST] := NEW ExprOpt(expr WITH r->exprs[LAST])
                END IF
            WHEN "*" DO
                IF i+1 < pattern.length() AND pattern[i+1] = "?" THEN
                    INC i
                    r->exprs[LAST] := NEW ExprStar(expr WITH r->exprs[LAST])
                ELSE
                    r->exprs[LAST] := NEW ExprStar(expr WITH r->exprs[LAST])
                END IF
            WHEN "+" DO
                IF i+1 < pattern.length() AND pattern[i+1] = "?" THEN
                    INC i
                    r->exprs[LAST] := NEW ExprRepeat(minimum WITH 1, maximum WITH -1, expr WITH r->exprs[LAST])
                ELSE
                    r->exprs[LAST] := NEW ExprRepeat(minimum WITH 1, maximum WITH -1, expr WITH r->exprs[LAST])
                END IF
            WHEN "{" DO
                VAR min := 0
                VAR max := -1
                INC i
                VAR j := i
                WHILE j < pattern.length() AND "0" <= pattern[j] <= "9" DO
                    INC j
                END WHILE
                IF j > i THEN
                    min := num(pattern[i TO j-1])
                    i := j
                END IF
                IF pattern[i] = "," THEN
                    INC i
                    j := i
                    WHILE j < pattern.length() AND "0" <= pattern[j] <= "9" DO
                        INC j
                    END WHILE
                    IF j > i THEN
                        max := num(pattern[i TO j-1])
                        i := j
                    END IF
                ELSE
                    max := min
                END IF
                ASSERT pattern[i] = "}"
                r->exprs[LAST] := NEW ExprRepeat(minimum WITH min, maximum WITH max, expr WITH r->exprs[LAST])
            WHEN "(" DO
                INC i
                INC groupIndex
                LET gi := groupIndex
                VAR nonCapture := FALSE
                IF pattern[i] = "?" THEN
                    INC i
                    CASE pattern[i]
                        WHEN ":" DO
                            INC i
                            nonCapture := TRUE
                        WHEN OTHERS DO
                            ASSERT FALSE
                    END CASE
                END IF
                LET e := parsePart(pattern, ignoreCase, INOUT i)
                ASSERT pattern[i] = ")"
                r->exprs.append(NEW ExprGroup(index WITH gi, expr WITH e))
            WHEN ")" DO
                EXIT WHILE
            WHEN "|" DO
                IF VALID a THEN
                    a->alternatives.append(r)
                ELSE
                    a := NEW ExprAlternative(alternatives WITH [r])
                END IF
                r := NEW ExprSequence
            WHEN "\\" DO
                INC i
                CASE pattern[i]
                    WHEN "d" DO
                        r->exprs.append(NEW ExprClass(chars WITH ["0","1","2","3","4","5","6","7","8","9"]))
                    WHEN "s" DO
                        r->exprs.append(NEW ExprClass(chars WITH ["\f","\n","\r","\t"," "]))
                    WHEN "S" DO
                        r->exprs.append(NEW ExprClass(chars WITH ["\f","\n","\r","\t"," "], complement WITH TRUE))
                    WHEN "w" DO
                        VAR j := 0
                        r->exprs.append(parsePart("[A-Z0-9_]", TRUE, INOUT j))
                    WHEN "t" DO
                        r->exprs.append(NEW ExprLiteral(literal WITH "\t"))
                    WHEN "n" DO
                        r->exprs.append(NEW ExprLiteral(literal WITH "\n"))
                    WHEN "r" DO
                        r->exprs.append(NEW ExprLiteral(literal WITH "\r"))
                    WHEN "f" DO
                        r->exprs.append(NEW ExprLiteral(literal WITH "\f"))
                    WHEN "a" DO
                        r->exprs.append(NEW ExprLiteral(literal WITH "\u0007"))
                    WHEN "e" DO
                        r->exprs.append(NEW ExprLiteral(literal WITH "\u001b"))
                    WHEN "c" DO
                        INC i
                        r->exprs.append(NEW ExprLiteral(literal WITH string.fromCodePoint(string.toCodePoint(string.upper(pattern[i])) - 64)))
                    WHEN "x" DO
                        r->exprs.append(NEW ExprLiteral(literal WITH string.fromCodePoint(base.fromHex(pattern[i+1 TO i+2]))))
                        i := i + 2
                    WHEN "N" DO
                        ASSERT FALSE
                    WHEN "o" DO
                        ASSERT FALSE
                    WHEN "0" DO
                        r->exprs.append(NEW ExprLiteral(literal WITH string.fromCodePoint(base.fromOctal(pattern[i TO i+2]))))
                        i := i + 2
                    WHEN "l" DO
                        ASSERT FALSE
                    WHEN "u" DO
                        ASSERT FALSE
                    WHEN "L" DO
                        ASSERT FALSE
                    WHEN "U" DO
                        ASSERT FALSE
                    WHEN "Q" DO
                        ASSERT FALSE
                    WHEN "E" DO
                        ASSERT FALSE
                    WHEN OTHERS DO
                        r->exprs.append(NEW ExprLiteral(literal WITH pattern[i]))
                END CASE
            WHEN OTHERS DO
                IF ignoreCase AND string.lower(pattern[i]) <> string.upper(pattern[i]) THEN
                    r->exprs.append(NEW ExprClass(chars WITH [string.lower(pattern[i]), string.upper(pattern[i])]))
                ELSE
                    r->exprs.append(NEW ExprLiteral(literal WITH pattern[i]))
                END IF
        END CASE
        INC i
    END WHILE
    IF VALID a THEN
        a->alternatives.append(r)
        RETURN a
    ELSE
        RETURN r
    END IF
END FUNCTION

FUNCTION parse(pattern: String, ignoreCase: Boolean DEFAULT FALSE): VALID POINTER TO Expr
    VAR i := 0
    RETURN parsePart(pattern, ignoreCase, INOUT i)
END FUNCTION

FUNCTION compile(expr: VALID POINTER TO Expr): Regex
    VAR r: Regex := []
    VAR e := expr->reduce()
    e := NEW ExprGroup(index WITH 0, expr WITH e)
    -- TODO: This should just be a literal array expression,
    --       but there is a segfault in the compiler for some reason.
    VAR a: Array<VALID POINTER TO Expr> := []
    a.append(NEW ExprStar(expr WITH NEW ExprAny))
    a.append(e)
    e := NEW ExprSequence(exprs WITH a)
    e->compile(INOUT r)
    r.append(Opcode.match)
    RETURN r
END FUNCTION

FUNCTION matchPart(regex: Regex, ri: Number, target: String, ti: Number, INOUT saved: Array<Number>): Result
    LET o := regex[ri]
    CASE o
        WHEN ISA Opcode.any DO
            CHECK ti < target.length() ELSE
                RETURN Result.noMatch
            END CHECK
            RETURN matchPart(regex, ri+1, target, ti+1, INOUT saved)
        WHEN ISA Opcode.char DO
            CHECK ti < target.length() ELSE
                RETURN Result.noMatch
            END CHECK
            IF o.char <> target[ti] THEN
                RETURN Result.noMatch
            END IF
            RETURN matchPart(regex, ri+1, target, ti+1, INOUT saved)
        WHEN ISA Opcode.begin DO
            IF ti > 0 THEN
                RETURN Result.noMatch
            END IF
            RETURN matchPart(regex, ri+1, target, ti, INOUT saved)
        WHEN ISA Opcode.end DO
            CHECK ti >= target.length() ELSE
                RETURN Result.noMatch
            END CHECK
            RETURN matchPart(regex, ri+1, target, ti, INOUT saved)
        WHEN ISA Opcode.save DO
            IF o.save >= saved.size() THEN
                saved.resize((o.save + 2) INTDIV 2 * 2)
            END IF
            LET prev := saved[o.save]
            saved[o.save] := ti
            LET r := matchPart(regex, ri+1, target, ti, INOUT saved)
            IF r ISA Result.match THEN
                RETURN r
            END IF
            saved[o.save] := prev
            RETURN Result.noMatch
        WHEN ISA Opcode.match DO
            RETURN Result.match([])
        WHEN ISA Opcode.jump DO
            FOREACH j IN o.jump DO
                LET r := matchPart(regex, j, target, ti, INOUT saved)
                IF r ISA Result.match THEN
                    RETURN r
                END IF
            END FOREACH
            RETURN Result.noMatch
    END CASE
END FUNCTION

FUNCTION match(regex: Regex, target: String): Result
    VAR saved: Array<Number> := []
    LET r := matchPart(regex, 0, target, 0, INOUT saved)
    IF r ISA Result.match THEN
        ASSERT saved.size() MOD 2 = 0
        FOR i := 0 TO saved.size()-1 STEP 2 DO
            r.match[i/2] := target[saved[i] TO saved[i+1]-1]
        END FOR
    END IF
    RETURN r
END FUNCTION

FUNCTION prepare(pattern: String, ignoreCase: Boolean DEFAULT FALSE): Regex
    LET e := parse(pattern, ignoreCase)
    LET r := compile(e)
    RETURN r
END FUNCTION

FUNCTION search(pattern: String, target: String): Result
    LET r := prepare(pattern)
    RETURN match(r, target)
END FUNCTION

FUNCTION searchRegex(regex: Regex, target: String): Result
    RETURN match(regex, target)
END FUNCTION

FUNCTION test(pattern: String, cases: Array<Array<Object>>)
    print("-- test: \(pattern)")
    LET re := prepare(pattern)
    FOREACH e IN re INDEX i DO
        print("\(i) \(e)")
    END FOREACH
    FOREACH t IN cases DO
        IF Debug THEN
            print("pattern=\(pattern) target=\(t[1]) expect \(t[0])")
        END IF
        LET r := match(re, t[1])
        CASE r
            WHEN ISA Result.noMatch DO
                CHECK NOT t[0] ELSE
                    print("failed")
                    EXIT PROCESS FAILURE
                END CHECK
            WHEN ISA Result.match DO
                CHECK t[0] ELSE
                    print("failed")
                    EXIT PROCESS FAILURE
                END CHECK
                TESTCASE r.match.size() = t[2].size()
                FOREACH m IN r.match INDEX i DO
                    TESTCASE m = t[2][i]
                END FOREACH
        END CASE
    END FOREACH
END FUNCTION

BEGIN MAIN
    LET e := parse("a?b")
    print(e->dump())
    LET r := compile(e)
    FOREACH x IN r INDEX i DO
        print("\(i) \(x)")
    END FOREACH
    test("abc", [
        [TRUE, "abc", ["abc"]],
        [FALSE, "axc"],
    ])
    test("a.c", [
        [TRUE, "abc", ["abc"]],
        [FALSE, "acb"],
    ])
    test("ab?c", [
        [TRUE, "ac", ["ac"]],
        [TRUE, "abc", ["abc"]],
        [FALSE, "abbc"],
    ])
    test("ab*c", [
        [TRUE, "ac", ["ac"]],
        [TRUE, "abc", ["abc"]],
        [TRUE, "abbc", ["abbc"]],
    ])
    test("ab+c", [
        [FALSE, "ac"],
        [TRUE, "abc", ["abc"]],
        [TRUE, "abbc", ["abbc"]],
    ])
    test("ab{2,3}c", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc", ["abbc"]],
        [TRUE, "abbbc", ["abbbc"]],
        [FALSE, "abbbbc"],
    ])
    test("^abc", [
        [TRUE, "abc", ["abc"]],
        [FALSE, "xabc"],
    ])
    test("a(b)c", [
        [TRUE, "abc", ["abc", "b"]],
    ])
    test("a(b){1,2}bc", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc", ["abbc", "b"]],
        [TRUE, "abbbc", ["abbbc", "b"]],
        [FALSE, "abbbbc"],
    ])
    test("a(b{1,2})bc", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc", ["abbc", "b"]],
        [TRUE, "abbbc", ["abbbc", "bb"]],
        [FALSE, "abbbbc"],
    ])
    test("a|bc", [
        [TRUE, "a", ["a"]],
        [TRUE, "bc", ["bc"]],
        [TRUE, "abc", ["a"]],
        [TRUE, "bbc", ["bc"]],
        [FALSE, "b"],
    ])
    test("a|bc|def", [
        [TRUE, "a", ["a"]],
        [TRUE, "bc", ["bc"]],
        [TRUE, "def", ["def"]],
    ])
    test("a(bc)*d", [
        [TRUE, "ad", ["ad"]],
        [FALSE, "abc"],
        [TRUE, "abcd", ["abcd"]],
        [TRUE, "abcbcd", ["abcbcd"]],
    ])
    test("a(b|c)*d", [
        [TRUE, "ad"],
        [TRUE, "abcd"],
        [TRUE, "abbbbcbd"],
        [FALSE, "abc"],
    ])
    test("^(0|(1(01*0)*1))*$", [
        [TRUE, ""],
        [TRUE, "0"],
        [TRUE, "00"],
        [FALSE, "01"],
        [FALSE, "10"],
        [TRUE, "11"],
        [TRUE, "000"],
        [FALSE, "001"],
        [FALSE, "010"],
        [TRUE, "011"],
        [FALSE, "100"],
        [FALSE, "101"],
        [TRUE, "110"],
        [FALSE, "111"],
        [TRUE, "0000"],
        [FALSE, "0001"],
        [FALSE, "0010"],
        [TRUE, "0011"],
        [FALSE, "0100"],
        [FALSE, "0101"],
        [TRUE, "0110"],
        [FALSE, "0111"],
        [FALSE, "1000"],
        [TRUE, "1001"],
        [FALSE, "1010"],
        [FALSE, "1011"],
        [TRUE, "1100"],
        [FALSE, "1101"],
        [FALSE, "1110"],
        [TRUE, "1111"],
        [TRUE, "00000"],
    ])
    test("a*ab", [
        [TRUE, "ab"],
    ])
    test("ab+?bc", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc"],
        [TRUE, "abbbc"],
    ])
    test("^(b+?|a){1,2}?c", [
        [TRUE, "bbac"],
    ])
    test("^$", [
        [TRUE, ""],
        [FALSE, "a"],
    ])
    test("ab(cd)", [
        [TRUE, "abcd", ["abcd", "cd"]],
    ])
    print("passed")
END MAIN
