--IMPORT base
--IMPORT string

EXPORT Match
EXPORT Regex

EXPORT dump
EXPORT parse
EXPORT search
EXPORT searchRegex

TYPE MatchLoopBegin IS RECORD
    minimum: Number
    maximum: Number
    next: Number
END RECORD

FUNCTION MatchLoopBegin.toString(self: MatchLoopBegin): String
    RETURN "MatchLoopBegin(min=\(self.minimum), max=\(self.maximum), next=\(self.next))"
END FUNCTION

TYPE MatchAltBegin IS RECORD
    alternatives: Array<Number>
    next: Number
END RECORD

FUNCTION MatchAltBegin.toString(self: MatchAltBegin): String
    RETURN "MatchAltBegin(alts=\(self.alternatives), next=\(self.next))"
END FUNCTION

TYPE Match IS CHOICE
    any
    literal: String
    begin
    loopBegin: MatchLoopBegin
    loopEnd: Number
    --altBegin: MatchAltBegin
    --altEnd: Number
END CHOICE

TYPE Regex IS Array<Match>

/*
INTERFACE Match
    FUNCTION dump(self: Match): String
    FUNCTION match(self: Match, target: String, INOUT i: Number): Boolean
END INTERFACE

TYPE Regex IS Array<VALID POINTER TO Match>

TYPE MatchLiteral IS CLASS IMPLEMENTS Match
    match: String
END CLASS

FUNCTION MatchLiteral.dump(self: VALID POINTER TO MatchLiteral): String
    RETURN self->match
END FUNCTION

FUNCTION MatchLiteral.match(self: VALID POINTER TO MatchLiteral, target: String, INOUT i: Number): Boolean
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    LET len := self->match.length()
    IF target[i TO i+len-1] <> self->match THEN
        RETURN FALSE
    END IF
    i := i + len
    RETURN TRUE
END FUNCTION

TYPE MatchLiteralIgnoreCase IS CLASS IMPLEMENTS Match
    match: String
END CLASS

FUNCTION MatchLiteralIgnoreCase.dump(self: VALID POINTER TO MatchLiteralIgnoreCase): String
    RETURN self->match
END FUNCTION

FUNCTION MatchLiteralIgnoreCase.match(self: VALID POINTER TO MatchLiteralIgnoreCase, target: String, INOUT i: Number): Boolean
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    LET len := self->match.length()
    IF string.lower(target[i TO i+len-1]) <> self->match THEN
        RETURN FALSE
    END IF
    i := i + len
    RETURN TRUE
END FUNCTION

TYPE MatchAny IS CLASS IMPLEMENTS Match
END CLASS

FUNCTION MatchAny.dump(self: VALID POINTER TO MatchAny): String
    RETURN "."
END FUNCTION

FUNCTION MatchAny.match(self: VALID POINTER TO MatchAny, target: String, INOUT i: Number): Boolean
    INC i
    RETURN TRUE
END FUNCTION

TYPE MatchRepeat IS CLASS IMPLEMENTS Match
    minimum: Number
    maximum: Number
    sub: POINTER TO Match
    tail: Regex
END CLASS

FUNCTION MatchRepeat.dump(self: VALID POINTER TO MatchRepeat): String
    RETURN "\(self->sub->dump()){\(self->minimum),\(self->maximum)}\(dump(self->tail))"
END FUNCTION

FUNCTION MatchRepeat.match(self: VALID POINTER TO MatchRepeat, target: String, INOUT i: Number): Boolean
    VAR n := 0
    VAR backtrack: Array<Number> := []
    WHILE self->maximum < 0 OR n < self->maximum DO
        LET b := i
        IF NOT self->sub->match(target, INOUT i) THEN
            EXIT WHILE
        END IF
        backtrack.append(b)
        INC n
    END WHILE
    WHILE n >= self->minimum DO
        IF match(self->tail, target[i TO LAST]) THEN
            EXIT WHILE
        END IF
        IF backtrack.size() = 0 THEN
            RETURN FALSE
        END IF
        i := backtrack[LAST]
        backtrack := backtrack[FIRST TO LAST-1]
        DEC n
    END WHILE
    RETURN n >= self->minimum
END FUNCTION

TYPE MatchBegin IS CLASS IMPLEMENTS Match
END CLASS

FUNCTION MatchBegin.dump(self: VALID POINTER TO MatchBegin): String
    RETURN "^"
END FUNCTION

FUNCTION MatchBegin.match(self: VALID POINTER TO MatchBegin, target: String, INOUT i: Number): Boolean
    -- TODO: This needs to check that we are at the actual start of the string, not starting a new match in the middle.
    RETURN i = 0
END FUNCTION

TYPE MatchGroup IS CLASS IMPLEMENTS Match
    regex: Regex
END CLASS

FUNCTION MatchGroup.dump(self: VALID POINTER TO MatchGroup): String
    RETURN "(\(dump(self->regex)))"
END FUNCTION

FUNCTION MatchGroup.match(self: VALID POINTER TO MatchGroup, target: String, INOUT i: Number): Boolean
    IF NOT matchPart(self->regex, target, INOUT i) THEN
        RETURN FALSE
    END IF
    RETURN TRUE
END FUNCTION

TYPE MatchAlternative IS CLASS IMPLEMENTS Match
    alternatives: Array<Regex>
END CLASS

FUNCTION MatchAlternative.dump(self: VALID POINTER TO MatchAlternative): String
    VAR r := ""
    FOREACH a IN self->alternatives DO
        IF r.length() > 0 THEN
            r.append("|")
        END IF
        r.append(dump(a))
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION MatchAlternative.match(self: VALID POINTER TO MatchAlternative, target: String, INOUT i: Number): Boolean
    FOREACH a IN self->alternatives DO
    END FOREACH
    RETURN FALSE
END FUNCTION
*/

FUNCTION dump(regex: Regex): String
    VAR r := ""
    FOREACH m IN regex DO
        r.append("\(m)")
        --CASE m
        --    WHEN ISA Match.any DO
        --        r.append(".")
        --    WHEN ISA Match.literal DO
        --        r.append(m.literal)
        --END CASE
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION parse(pattern: String, ignoreCase: Boolean DEFAULT FALSE): Regex
    CHECK pattern.length() > 0 ELSE
        RETURN []
    END CHECK
    VAR r: Regex := []
    VAR groupstart := [0]
    VAR i := 0
    WHILE i < pattern.length() DO
        CASE pattern[i]
            WHEN "^" DO
                r.append(Match.begin)
            WHEN "." DO
                r.append(Match.any)
            WHEN "?" DO
                r := r[FIRST TO LAST-1] & [Match.loopBegin(MatchLoopBegin(minimum WITH 0, maximum WITH 1, next WITH r.size()+2))] & r[LAST TO LAST] & [Match.loopEnd(r.size()-1)]
            WHEN "*" DO
                r := r[FIRST TO LAST-1] & [Match.loopBegin(MatchLoopBegin(minimum WITH 0, maximum WITH -1, next WITH r.size()+2))] & r[LAST TO LAST] & [Match.loopEnd(r.size()-1)]
            WHEN "+" DO
                r := r[FIRST TO LAST-1] & [Match.loopBegin(MatchLoopBegin(minimum WITH 1, maximum WITH -1, next WITH r.size()+2))] & r[LAST TO LAST] & [Match.loopEnd(r.size()-1)]
            WHEN "{" DO
                VAR min := 0
                VAR max := -1
                INC i
                VAR j := i
                WHILE j < pattern.length() AND "0" <= pattern[j] <= "9" DO
                    INC j
                END WHILE
                IF j > i THEN
                    min := num(pattern[i TO j-1])
                    i := j
                END IF
                IF pattern[i] = "," THEN
                    INC i
                    j := i
                    WHILE j < pattern.length() AND "0" <= pattern[j] <= "9" DO
                        INC j
                    END WHILE
                    IF j > i THEN
                        max := num(pattern[i TO j-1])
                        i := j
                    END IF
                ELSE
                    max := min
                END IF
                ASSERT pattern[i] = "}"
                r := r[FIRST TO LAST-1] & [Match.loopBegin(MatchLoopBegin(minimum WITH min, maximum WITH max, next WITH r.size()+2))] & r[LAST TO LAST] & [Match.loopEnd(r.size()-1)]
            WHEN "(" DO
                groupstart.append(r.size())
            WHEN ")" DO
                CHECK groupstart.size() > 1 ELSE
                    -- Syntax error.
                    RETURN []
                END CHECK
                groupstart := groupstart[FIRST TO LAST-1]
            /*
            WHEN "|" DO
                LET gs := groupstart[LAST]
                IF r[gs] ISA Match.altBegin THEN
                    r[gs].alternatives.append(
                ELSE
                    r := r[FIRST TO gs-1] & [Match.altBegin(MatchAltBegin(alternatives WITH [gs+1, 
                END IF
            WHEN "\\" DO
                INC i
                CASE pattern[i]
                    WHEN "t" DO
                        r.append(NEW MatchLiteral(match WITH "\t"))
                    WHEN "n" DO
                        r.append(NEW MatchLiteral(match WITH "\n"))
                    WHEN "r" DO
                        r.append(NEW MatchLiteral(match WITH "\r"))
                    WHEN "f" DO
                        r.append(NEW MatchLiteral(match WITH "\f"))
                    WHEN "a" DO
                        r.append(NEW MatchLiteral(match WITH "\u0007"))
                    WHEN "e" DO
                        r.append(NEW MatchLiteral(match WITH "\u001b"))
                    WHEN "c" DO
                        INC i
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(string.toCodePoint(string.upper(pattern[i])) - 64)))
                    WHEN "x" DO
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(base.fromHex(pattern[i TO i+1]))))
                        i := i + 2
                    WHEN "N" DO
                        ASSERT FALSE
                    WHEN "o" DO
                        ASSERT FALSE
                    WHEN "0", "1" DO
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(base.fromOctal(pattern[i TO i+2]))))
                        i := i + 2
                    WHEN "l" DO
                        ASSERT FALSE
                    WHEN "u" DO
                        ASSERT FALSE
                    WHEN "L" DO
                        ASSERT FALSE
                    WHEN "U" DO
                        ASSERT FALSE
                    WHEN "Q" DO
                        ASSERT FALSE
                    WHEN "E" DO
                        ASSERT FALSE
                    WHEN OTHERS DO
                        r.append(NEW MatchLiteral(match WITH pattern[i]))
                END CASE
            */
            WHEN OTHERS DO
                r.append(Match.literal(pattern[i]))
                /*
                IF ignoreCase THEN
                    r.append(NEW MatchLiteralIgnoreCase(match WITH string.lower(pattern[i])))
                ELSE
                    r.append(NEW MatchLiteral(match WITH pattern[i]))
                END IF
                */
        END CASE
        INC i
    END WHILE
    RETURN r
END FUNCTION

TYPE BacktrackInfo IS RECORD
    instruction: Number
    index: Number
END RECORD

FUNCTION matchPart(regex: Regex, target: String, INOUT i: Number): Boolean
    FUNCTION backtrack(): Boolean
        RETURN FALSE
    END FUNCTION

    CHECK regex.size() > 0 ELSE
        RETURN TRUE
    END CHECK
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    --print("-- matching target: \(target)")
    VAR counters: Array<Number> := []
    VAR context: Array<BacktrackInfo> := []
    VAR ri := 0
    WHILE ri < regex.size() LABEL main DO
        LET m := regex[ri]
        --print("\(ri) \(m)")
        --print("  \(target)")
        --print(string.repeat(" ", 2+i) & "|")
        VAR ok := TRUE
        CASE m
            WHEN ISA Match.any DO
                INC i
            WHEN ISA Match.literal DO
                IF target[i] = m.literal THEN
                    INC i
                ELSE
                    ok := FALSE
                END IF
            WHEN ISA Match.begin DO
                IF i = 0 THEN
                    -- Accept
                ELSE
                    ok := FALSE
                END IF
            WHEN ISA Match.loopBegin DO
                LET next := m.loopBegin.next
                IF ri >= counters.size() THEN
                    counters[ri] := 0
                END IF
                IF m.loopBegin.maximum < 0 OR counters[ri] < m.loopBegin.maximum THEN
                    context.append(BacktrackInfo(
                        instruction WITH ri,
                        index WITH i
                    ))
                    INC counters[ri]
                ELSE
                    ri := next -- TODO: m.loopBegin.next
                    NEXT main
                END IF
            WHEN ISA Match.loopEnd DO
                LET lb := regex[m.loopEnd]
                CHECK lb ISA Match.loopBegin ELSE
                    ASSERT FALSE -- Internal error.
                    RETURN FALSE
                END CHECK
                ri := m.loopEnd
                NEXT main
        END CASE
        IF ok THEN
            INC ri
        ELSE
            WHILE context.size() > 0 DO
                ri := context[LAST].instruction
                i := context[LAST].index
                DEC counters[ri]
                LET lb := regex[ri]
                CHECK lb ISA Match.loopBegin ELSE
                    ASSERT FALSE -- Internal error.
                    RETURN FALSE
                END CHECK
                IF counters[ri] >= lb.loopBegin.minimum THEN
                    ri := lb.loopBegin.next
                    NEXT main
                END IF
                context := context[FIRST TO LAST-1]
            END WHILE
            RETURN FALSE
        END IF
    END WHILE
    RETURN TRUE
END FUNCTION

FUNCTION match(regex: Regex, target: String): Boolean
    VAR i := 0
    RETURN matchPart(regex, target, INOUT i)
END FUNCTION

FUNCTION search(pattern: String, target: String): Boolean
    LET r := parse(pattern)
    RETURN match(r, target)
END FUNCTION

FUNCTION searchRegex(r: Regex, target: String): Boolean
    FOR i := 0 TO target.length() DO
        VAR j := i
        IF matchPart(r, target, INOUT j) THEN
            RETURN TRUE
        END IF
    END FOR
    RETURN FALSE
END FUNCTION

FUNCTION test(pattern: String, cases: Array<Array<Object>>)
    LET r := parse(pattern)
    print(dump(r))
    FOREACH t IN cases DO
        IF t[0] <> match(r, t[1]) THEN
            print("pattern=\(pattern) target=\(t[1]) expect \(t[0])")
            EXIT PROCESS FAILURE
        END IF
    END FOREACH
END FUNCTION

BEGIN MAIN
    test("abc", [
        [TRUE, "abc"],
        [FALSE, "axc"],
    ])
    test("a.c", [
        [TRUE, "abc"],
        [FALSE, "acb"],
    ])
    test("ab?c", [
        [TRUE, "ac"],
        [TRUE, "abc"],
        [FALSE, "abbc"],
    ])
    test("ab*c", [
        [TRUE, "ac"],
        [TRUE, "abc"],
        [TRUE, "abbc"],
    ])
    test("ab+c", [
        [FALSE, "ac"],
        [TRUE, "abc"],
        [TRUE, "abbc"],
    ])
    test("ab{2,3}c", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc"],
        [TRUE, "abbbc"],
        [FALSE, "abbbbc"],
    ])
    test("^abc", [
        [TRUE, "abc"],
        [FALSE, "xabc"],
    ])
    test("a(b)c", [
        [TRUE, "abc"],
    ])
    test("a(b){1,2}bc", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc"],
        [TRUE, "abbbc"],
        [FALSE, "abbbbc"],
    ])
    test("a(b{1,2})bc", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc"],
        [TRUE, "abbbc"],
        [FALSE, "abbbbc"],
    ])
    /*
    test(""a|bc", [
        [TRUE, "a"],
        [TRUE, "bc"],
        [TRUE, "abc"],
        [TRUE, "bbc"],
        [FALSE, "b"],
    ])
    */
    print("passed")
END MAIN
