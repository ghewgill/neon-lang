--IMPORT base
IMPORT string

EXPORT Match
EXPORT Regex

EXPORT dump
EXPORT parse
EXPORT search
EXPORT searchRegex

TYPE MatchLoopBegin IS RECORD
    minimum: Number
    maximum: Number
    next: Number
END RECORD

FUNCTION MatchLoopBegin.toString(self: MatchLoopBegin): String
    RETURN "MatchLoopBegin(min=\(self.minimum), max=\(self.maximum), next=\(self.next))"
END FUNCTION

TYPE Match IS CHOICE
    any
    literal: String
    loopBegin: MatchLoopBegin
    loopEnd: Number
END CHOICE

TYPE Regex IS Array<Match>

/*
INTERFACE Match
    FUNCTION dump(self: Match): String
    FUNCTION match(self: Match, target: String, INOUT i: Number): Boolean
END INTERFACE

TYPE Regex IS Array<VALID POINTER TO Match>

TYPE MatchLiteral IS CLASS IMPLEMENTS Match
    match: String
END CLASS

FUNCTION MatchLiteral.dump(self: VALID POINTER TO MatchLiteral): String
    RETURN self->match
END FUNCTION

FUNCTION MatchLiteral.match(self: VALID POINTER TO MatchLiteral, target: String, INOUT i: Number): Boolean
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    LET len := self->match.length()
    IF target[i TO i+len-1] <> self->match THEN
        RETURN FALSE
    END IF
    i := i + len
    RETURN TRUE
END FUNCTION

TYPE MatchLiteralIgnoreCase IS CLASS IMPLEMENTS Match
    match: String
END CLASS

FUNCTION MatchLiteralIgnoreCase.dump(self: VALID POINTER TO MatchLiteralIgnoreCase): String
    RETURN self->match
END FUNCTION

FUNCTION MatchLiteralIgnoreCase.match(self: VALID POINTER TO MatchLiteralIgnoreCase, target: String, INOUT i: Number): Boolean
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    LET len := self->match.length()
    IF string.lower(target[i TO i+len-1]) <> self->match THEN
        RETURN FALSE
    END IF
    i := i + len
    RETURN TRUE
END FUNCTION

TYPE MatchAny IS CLASS IMPLEMENTS Match
END CLASS

FUNCTION MatchAny.dump(self: VALID POINTER TO MatchAny): String
    RETURN "."
END FUNCTION

FUNCTION MatchAny.match(self: VALID POINTER TO MatchAny, target: String, INOUT i: Number): Boolean
    INC i
    RETURN TRUE
END FUNCTION

TYPE MatchRepeat IS CLASS IMPLEMENTS Match
    minimum: Number
    maximum: Number
    sub: POINTER TO Match
    tail: Regex
END CLASS

FUNCTION MatchRepeat.dump(self: VALID POINTER TO MatchRepeat): String
    RETURN "\(self->sub->dump()){\(self->minimum),\(self->maximum)}\(dump(self->tail))"
END FUNCTION

FUNCTION MatchRepeat.match(self: VALID POINTER TO MatchRepeat, target: String, INOUT i: Number): Boolean
    VAR n := 0
    VAR backtrack: Array<Number> := []
    WHILE self->maximum < 0 OR n < self->maximum DO
        LET b := i
        IF NOT self->sub->match(target, INOUT i) THEN
            EXIT WHILE
        END IF
        backtrack.append(b)
        INC n
    END WHILE
    WHILE n >= self->minimum DO
        IF match(self->tail, target[i TO LAST]) THEN
            EXIT WHILE
        END IF
        IF backtrack.size() = 0 THEN
            RETURN FALSE
        END IF
        i := backtrack[LAST]
        backtrack := backtrack[FIRST TO LAST-1]
        DEC n
    END WHILE
    RETURN n >= self->minimum
END FUNCTION

TYPE MatchBegin IS CLASS IMPLEMENTS Match
END CLASS

FUNCTION MatchBegin.dump(self: VALID POINTER TO MatchBegin): String
    RETURN "^"
END FUNCTION

FUNCTION MatchBegin.match(self: VALID POINTER TO MatchBegin, target: String, INOUT i: Number): Boolean
    -- TODO: This needs to check that we are at the actual start of the string, not starting a new match in the middle.
    RETURN i = 0
END FUNCTION

TYPE MatchGroup IS CLASS IMPLEMENTS Match
    regex: Regex
END CLASS

FUNCTION MatchGroup.dump(self: VALID POINTER TO MatchGroup): String
    RETURN "(\(dump(self->regex)))"
END FUNCTION

FUNCTION MatchGroup.match(self: VALID POINTER TO MatchGroup, target: String, INOUT i: Number): Boolean
    IF NOT matchPart(self->regex, target, INOUT i) THEN
        RETURN FALSE
    END IF
    RETURN TRUE
END FUNCTION

TYPE MatchAlternative IS CLASS IMPLEMENTS Match
    alternatives: Array<Regex>
END CLASS

FUNCTION MatchAlternative.dump(self: VALID POINTER TO MatchAlternative): String
    VAR r := ""
    FOREACH a IN self->alternatives DO
        IF r.length() > 0 THEN
            r.append("|")
        END IF
        r.append(dump(a))
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION MatchAlternative.match(self: VALID POINTER TO MatchAlternative, target: String, INOUT i: Number): Boolean
    FOREACH a IN self->alternatives DO
    END FOREACH
    RETURN FALSE
END FUNCTION
*/

FUNCTION dump(regex: Regex): String
    VAR r := ""
    FOREACH m IN regex DO
        r.append("\(m)")
        --CASE m
        --    WHEN ISA Match.any DO
        --        r.append(".")
        --    WHEN ISA Match.literal DO
        --        r.append(m.literal)
        --END CASE
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION parse(pattern: String, ignoreCase: Boolean DEFAULT FALSE): Regex
    CHECK pattern.length() > 0 ELSE
        RETURN []
    END CHECK
    VAR r: Regex := []
    VAR i := 0
    WHILE i < pattern.length() DO
        CASE pattern[i]
            /*
            WHEN "^" DO
                r.append(NEW MatchBegin())
            */
            WHEN "." DO
                r.append(Match.any)
            WHEN "?" DO
                r := r[FIRST TO LAST-1] & [Match.loopBegin(MatchLoopBegin(minimum WITH 0, maximum WITH 1, next WITH r.size()+2))] & r[LAST TO LAST] & [Match.loopEnd(r.size()-1)]
            /*
            WHEN "*" DO
                INC i
                r[LAST] := NEW MatchRepeat(
                    minimum WITH 0,
                    maximum WITH -1,
                    sub WITH r[LAST],
                    tail WITH parsePart(pattern, INOUT i, ignoreCase WITH ignoreCase)
                )
                EXIT WHILE
            WHEN "+" DO
                INC i
                r[LAST] := NEW MatchRepeat(
                    minimum WITH 1,
                    maximum WITH -1,
                    sub WITH r[LAST],
                    tail WITH parsePart(pattern, INOUT i, ignoreCase WITH ignoreCase)
                )
                EXIT WHILE
            WHEN "{" DO
                VAR min := 0
                VAR max := -1
                INC i
                VAR j := i
                WHILE j < pattern.length() AND "0" <= pattern[j] <= "9" DO
                    INC j
                END WHILE
                IF j > i THEN
                    min := num(pattern[i TO j-1])
                    i := j
                END IF
                IF pattern[i] = "," THEN
                    INC i
                    j := i
                    WHILE j < pattern.length() AND "0" <= pattern[j] <= "9" DO
                        INC j
                    END WHILE
                    IF j > i THEN
                        max := num(pattern[i TO j-1])
                        i := j
                    END IF
                ELSE
                    max := min
                END IF
                ASSERT pattern[i] = "}"
                INC i
                r[LAST] := NEW MatchRepeat(
                    minimum WITH min,
                    maximum WITH max,
                    sub WITH r[LAST],
                    tail WITH parsePart(pattern, INOUT i, ignoreCase WITH ignoreCase)
                )
                EXIT WHILE
            WHEN "(" DO
                INC i
                r.append(NEW MatchGroup(regex WITH parsePart(pattern, INOUT i, ignoreCase)))
            WHEN ")" DO
                EXIT WHILE
            WHEN "|" DO
                IF terminator = "|" THEN
                    EXIT WHILE
                END IF
                LET a := NEW MatchAlternative()
                a->alternatives.append(r)
                WHILE pattern[i] = "|" DO
                    INC i
                    a->alternatives.append(parsePart(pattern, INOUT i, ignoreCase, terminator WITH "|"))
                END WHILE
                RETURN [a]
            WHEN "\\" DO
                INC i
                CASE pattern[i]
                    WHEN "t" DO
                        r.append(NEW MatchLiteral(match WITH "\t"))
                    WHEN "n" DO
                        r.append(NEW MatchLiteral(match WITH "\n"))
                    WHEN "r" DO
                        r.append(NEW MatchLiteral(match WITH "\r"))
                    WHEN "f" DO
                        r.append(NEW MatchLiteral(match WITH "\f"))
                    WHEN "a" DO
                        r.append(NEW MatchLiteral(match WITH "\u0007"))
                    WHEN "e" DO
                        r.append(NEW MatchLiteral(match WITH "\u001b"))
                    WHEN "c" DO
                        INC i
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(string.toCodePoint(string.upper(pattern[i])) - 64)))
                    WHEN "x" DO
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(base.fromHex(pattern[i TO i+1]))))
                        i := i + 2
                    WHEN "N" DO
                        ASSERT FALSE
                    WHEN "o" DO
                        ASSERT FALSE
                    WHEN "0", "1" DO
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(base.fromOctal(pattern[i TO i+2]))))
                        i := i + 2
                    WHEN "l" DO
                        ASSERT FALSE
                    WHEN "u" DO
                        ASSERT FALSE
                    WHEN "L" DO
                        ASSERT FALSE
                    WHEN "U" DO
                        ASSERT FALSE
                    WHEN "Q" DO
                        ASSERT FALSE
                    WHEN "E" DO
                        ASSERT FALSE
                    WHEN OTHERS DO
                        r.append(NEW MatchLiteral(match WITH pattern[i]))
                END CASE
            */
            WHEN OTHERS DO
                r.append(Match.literal(pattern[i]))
                /*
                IF ignoreCase THEN
                    r.append(NEW MatchLiteralIgnoreCase(match WITH string.lower(pattern[i])))
                ELSE
                    r.append(NEW MatchLiteral(match WITH pattern[i]))
                END IF
                */
        END CASE
        INC i
    END WHILE
    RETURN r
END FUNCTION

TYPE BacktrackInfo IS RECORD
    instruction: Number
    index: Number
END RECORD

FUNCTION matchPart(regex: Regex, target: String, INOUT i: Number): Boolean
    FUNCTION backtrack(): Boolean
        RETURN FALSE
    END FUNCTION

    CHECK regex.size() > 0 ELSE
        RETURN TRUE
    END CHECK
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    print("-- matching target: \(target)")
    VAR counters: Array<Number> := []
    VAR context: Array<BacktrackInfo> := []
    VAR ri := 0
    WHILE ri < regex.size() LABEL main DO
        LET m := regex[ri]
        print("\(ri) \(m)")
        print("  \(target)")
        print(string.repeat(" ", 2+i) & "|")
        CASE m
            WHEN ISA Match.any DO
                INC i
            WHEN ISA Match.literal DO
                IF target[i] = m.literal THEN
                    INC i
                ELSE
                    WHILE context.size() > 0 DO
                        ri := context[LAST].instruction
                        i := context[LAST].index
                        DEC counters[ri]
                        LET lb := regex[ri]
                        CHECK lb ISA Match.loopBegin ELSE
                            ASSERT FALSE -- Internal error.
                            RETURN FALSE
                        END CHECK
                        IF counters[ri] >= lb.loopBegin.minimum THEN
                            ri := lb.loopBegin.next
                            NEXT main
                        END IF
                        context := context[FIRST TO LAST-1]
                    END WHILE
                    RETURN FALSE
                END IF
            WHEN ISA Match.loopBegin DO
                LET next := m.loopBegin.next
                IF ri >= counters.size() THEN
                    counters[ri] := 0
                END IF
                IF counters[ri] < m.loopBegin.maximum THEN
                    context.append(BacktrackInfo(
                        instruction WITH ri,
                        index WITH i
                    ))
                    INC counters[ri]
                ELSE
                    ri := next -- TODO: m.loopBegin.next
                    NEXT main
                END IF
            WHEN ISA Match.loopEnd DO
                LET lb := regex[m.loopEnd]
                CHECK lb ISA Match.loopBegin ELSE
                    ASSERT FALSE -- Internal error.
                    RETURN FALSE
                END CHECK
                ri := m.loopEnd
                NEXT main
        END CASE
        INC ri
    END WHILE
    RETURN TRUE
END FUNCTION

FUNCTION match(regex: Regex, target: String): Boolean
    VAR i := 0
    RETURN matchPart(regex, target, INOUT i)
END FUNCTION

FUNCTION search(pattern: String, target: String): Boolean
    LET r := parse(pattern)
    RETURN match(r, target)
END FUNCTION

FUNCTION searchRegex(r: Regex, target: String): Boolean
    FOR i := 0 TO target.length() DO
        VAR j := i
        IF matchPart(r, target, INOUT j) THEN
            RETURN TRUE
        END IF
    END FOR
    RETURN FALSE
END FUNCTION

BEGIN MAIN
    LET r1 := parse("abc")
    print(dump(r1))
    TESTCASE match(r1, "abc")
    TESTCASE NOT match(r1, "axc")
    LET r2 := parse("a.c")
    print(dump(r2))
    TESTCASE match(r2, "abc")
    TESTCASE NOT match(r2, "acb")
    LET r3 := parse("ab?c")
    print(dump(r3))
    TESTCASE match(r3, "ac")
    TESTCASE match(r3, "abc")
    TESTCASE NOT match(r3, "abbc")
    LET r4 := parse("ab*c")
    print(dump(r4))
    TESTCASE match(r4, "ac")
    TESTCASE match(r4, "abc")
    TESTCASE match(r4, "abbc")
    LET r5 := parse("ab+c")
    print(dump(r5))
    TESTCASE NOT match(r5, "ac")
    TESTCASE match(r5, "abc")
    TESTCASE match(r5, "abbc")
    LET r6 := parse("ab{2,3}c")
    print(dump(r6))
    TESTCASE NOT match(r6, "ac")
    TESTCASE NOT match(r6, "abc")
    TESTCASE match(r6, "abbc")
    TESTCASE match(r6, "abbbc")
    TESTCASE NOT match(r6, "abbbbc")
    LET r7 := parse("^abc")
    print(dump(r7))
    TESTCASE match(r7, "abc")
    TESTCASE NOT match(r7, "xabc")
    LET r8 := parse("a(b)c")
    print(dump(r8))
    TESTCASE match(r8, "abc")
    LET r9 := parse("a(b){1,2}bc")
    print(dump(r9))
    TESTCASE NOT match(r9, "ac")
    TESTCASE NOT match(r9, "abc")
    TESTCASE match(r9, "abbc")
    TESTCASE match(r9, "abbbc")
    TESTCASE NOT match(r9, "abbbbc")
    LET r10 := parse("a(b{1,2})bc")
    print(dump(r10))
    TESTCASE NOT match(r10, "ac")
    TESTCASE NOT match(r10, "abc")
    TESTCASE match(r10, "abbc")
    TESTCASE match(r10, "abbbc")
    TESTCASE NOT match(r10, "abbbbc")
    /*
    LET r11 := parse("a|bc")
    print(dump(r11))
    TESTCASE match(r11, "a")
    TESTCASE match(r11, "bc")
    TESTCASE match(r11, "abc")
    TESTCASE NOT match(r11, "b")
    */
END MAIN
