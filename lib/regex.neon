--IMPORT base
IMPORT string

EXPORT Match
EXPORT Regex

EXPORT dump
EXPORT parse
EXPORT search
EXPORT searchRegex

CONSTANT Debug := FALSE

TYPE MatchLoopBegin IS RECORD
    minimum: Number
    maximum: Number
    next: Number
END RECORD

FUNCTION MatchLoopBegin.toString(self: MatchLoopBegin): String
    RETURN "MatchLoopBegin(min=\(self.minimum), max=\(self.maximum), next=\(self.next))"
END FUNCTION

TYPE MatchAltBegin IS RECORD
    alternatives: Array<Number>
    next: Number
END RECORD

FUNCTION MatchAltBegin.toString(self: MatchAltBegin): String
    RETURN "MatchAltBegin(alts=\(self.alternatives), next=\(self.next))"
END FUNCTION

TYPE Match IS CHOICE
    any
    literal: String
    literalIgnoreCase: String
    begin
    end
    loopBeginGreedy: MatchLoopBegin
    loopEndGreedy: Number
    loopBeginNonGreedy: MatchLoopBegin
    loopEndNonGreedy: Number
    altBegin: MatchAltBegin
    altEnd: Number
END CHOICE

TYPE Regex IS Array<Match>

/*
INTERFACE Match
    FUNCTION dump(self: Match): String
    FUNCTION match(self: Match, target: String, INOUT i: Number): Boolean
END INTERFACE

TYPE Regex IS Array<VALID POINTER TO Match>

TYPE MatchLiteral IS CLASS IMPLEMENTS Match
    match: String
END CLASS

FUNCTION MatchLiteral.dump(self: VALID POINTER TO MatchLiteral): String
    RETURN self->match
END FUNCTION

FUNCTION MatchLiteral.match(self: VALID POINTER TO MatchLiteral, target: String, INOUT i: Number): Boolean
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    LET len := self->match.length()
    IF target[i TO i+len-1] <> self->match THEN
        RETURN FALSE
    END IF
    i := i + len
    RETURN TRUE
END FUNCTION

TYPE MatchLiteralIgnoreCase IS CLASS IMPLEMENTS Match
    match: String
END CLASS

FUNCTION MatchLiteralIgnoreCase.dump(self: VALID POINTER TO MatchLiteralIgnoreCase): String
    RETURN self->match
END FUNCTION

FUNCTION MatchLiteralIgnoreCase.match(self: VALID POINTER TO MatchLiteralIgnoreCase, target: String, INOUT i: Number): Boolean
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    LET len := self->match.length()
    IF string.lower(target[i TO i+len-1]) <> self->match THEN
        RETURN FALSE
    END IF
    i := i + len
    RETURN TRUE
END FUNCTION

TYPE MatchAny IS CLASS IMPLEMENTS Match
END CLASS

FUNCTION MatchAny.dump(self: VALID POINTER TO MatchAny): String
    RETURN "."
END FUNCTION

FUNCTION MatchAny.match(self: VALID POINTER TO MatchAny, target: String, INOUT i: Number): Boolean
    INC i
    RETURN TRUE
END FUNCTION

TYPE MatchRepeat IS CLASS IMPLEMENTS Match
    minimum: Number
    maximum: Number
    sub: POINTER TO Match
    tail: Regex
END CLASS

FUNCTION MatchRepeat.dump(self: VALID POINTER TO MatchRepeat): String
    RETURN "\(self->sub->dump()){\(self->minimum),\(self->maximum)}\(dump(self->tail))"
END FUNCTION

FUNCTION MatchRepeat.match(self: VALID POINTER TO MatchRepeat, target: String, INOUT i: Number): Boolean
    VAR n := 0
    VAR backtrack: Array<Number> := []
    WHILE self->maximum < 0 OR n < self->maximum DO
        LET b := i
        IF NOT self->sub->match(target, INOUT i) THEN
            EXIT WHILE
        END IF
        backtrack.append(b)
        INC n
    END WHILE
    WHILE n >= self->minimum DO
        IF match(self->tail, target[i TO LAST]) THEN
            EXIT WHILE
        END IF
        IF backtrack.size() = 0 THEN
            RETURN FALSE
        END IF
        i := backtrack[LAST]
        backtrack := backtrack[FIRST TO LAST-1]
        DEC n
    END WHILE
    RETURN n >= self->minimum
END FUNCTION

TYPE MatchBegin IS CLASS IMPLEMENTS Match
END CLASS

FUNCTION MatchBegin.dump(self: VALID POINTER TO MatchBegin): String
    RETURN "^"
END FUNCTION

FUNCTION MatchBegin.match(self: VALID POINTER TO MatchBegin, target: String, INOUT i: Number): Boolean
    -- TODO: This needs to check that we are at the actual start of the string, not starting a new match in the middle.
    RETURN i = 0
END FUNCTION

TYPE MatchGroup IS CLASS IMPLEMENTS Match
    regex: Regex
END CLASS

FUNCTION MatchGroup.dump(self: VALID POINTER TO MatchGroup): String
    RETURN "(\(dump(self->regex)))"
END FUNCTION

FUNCTION MatchGroup.match(self: VALID POINTER TO MatchGroup, target: String, INOUT i: Number): Boolean
    IF NOT matchPart(self->regex, target, INOUT i) THEN
        RETURN FALSE
    END IF
    RETURN TRUE
END FUNCTION

TYPE MatchAlternative IS CLASS IMPLEMENTS Match
    alternatives: Array<Regex>
END CLASS

FUNCTION MatchAlternative.dump(self: VALID POINTER TO MatchAlternative): String
    VAR r := ""
    FOREACH a IN self->alternatives DO
        IF r.length() > 0 THEN
            r.append("|")
        END IF
        r.append(dump(a))
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION MatchAlternative.match(self: VALID POINTER TO MatchAlternative, target: String, INOUT i: Number): Boolean
    FOREACH a IN self->alternatives DO
    END FOREACH
    RETURN FALSE
END FUNCTION
*/

FUNCTION dump(regex: Regex): String
    VAR r := ""
    FOREACH m IN regex DO
        r.append("\(m)")
        --CASE m
        --    WHEN ISA Match.any DO
        --        r.append(".")
        --    WHEN ISA Match.literal DO
        --        r.append(m.literal)
        --END CASE
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION parse(pattern: String, ignoreCase: Boolean DEFAULT FALSE): Regex
    CHECK pattern.length() > 0 ELSE
        RETURN []
    END CHECK
    VAR r: Regex := []
    VAR groupstart := [0]
    VAR quantifierstart := -1
    VAR i := 0
    WHILE i < pattern.length() DO
        VAR qs := -1
        CASE pattern[i]
            WHEN "^" DO
                r.append(Match.begin)
            WHEN "$" DO
                r.append(Match.end)
            WHEN "." DO
                qs := r.size()
                r.append(Match.any)
            WHEN "?" DO
                IF quantifierstart < 0 THEN
                    -- Syntax error.
                    RETURN []
                END IF
                r := r[FIRST TO quantifierstart-1] & [Match.loopBeginGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH 1, next WITH r.size()-quantifierstart+2))] & r[quantifierstart TO LAST] & [Match.loopEndGreedy(quantifierstart-r.size()-1)]
            WHEN "*" DO
                IF quantifierstart < 0 THEN
                    -- Syntax error.
                    RETURN []
                END IF
                IF i+1 < pattern.length() AND pattern[i+1] = "?" THEN
                    INC i
                    r := r[FIRST TO quantifierstart-1] & [Match.loopBeginNonGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH -1, next WITH r.size()-quantifierstart+2))] & r[quantifierstart TO LAST] & [Match.loopEndNonGreedy(quantifierstart-r.size()-1)]
                ELSE
                    r := r[FIRST TO quantifierstart-1] & [Match.loopBeginGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH -1, next WITH r.size()-quantifierstart+2))] & r[quantifierstart TO LAST] & [Match.loopEndGreedy(quantifierstart-r.size()-1)]
                END IF
            WHEN "+" DO
                IF quantifierstart < 0 THEN
                    -- Syntax error.
                    RETURN []
                END IF
                IF i+1 < pattern.length() AND pattern[i+1] = "?" THEN
                    INC i
                    r := r[FIRST TO quantifierstart-1] & [Match.loopBeginNonGreedy(MatchLoopBegin(minimum WITH 1, maximum WITH -1, next WITH r.size()-quantifierstart+2))] & r[quantifierstart TO LAST] & [Match.loopEndNonGreedy(quantifierstart-r.size()-1)]
                ELSE
                    r := r[FIRST TO quantifierstart-1] & [Match.loopBeginGreedy(MatchLoopBegin(minimum WITH 1, maximum WITH -1, next WITH r.size()-quantifierstart+2))] & r[quantifierstart TO LAST] & [Match.loopEndGreedy(quantifierstart-r.size()-1)]
                END IF
            WHEN "{" DO
                IF quantifierstart < 0 THEN
                    -- Syntax error.
                    RETURN []
                END IF
                VAR min := 0
                VAR max := -1
                INC i
                VAR j := i
                WHILE j < pattern.length() AND "0" <= pattern[j] <= "9" DO
                    INC j
                END WHILE
                IF j > i THEN
                    min := num(pattern[i TO j-1])
                    i := j
                END IF
                IF pattern[i] = "," THEN
                    INC i
                    j := i
                    WHILE j < pattern.length() AND "0" <= pattern[j] <= "9" DO
                        INC j
                    END WHILE
                    IF j > i THEN
                        max := num(pattern[i TO j-1])
                        i := j
                    END IF
                ELSE
                    max := min
                END IF
                ASSERT pattern[i] = "}"
                IF i+1 < pattern.length() AND pattern[i+1] = "?" THEN
                    INC i
                    r := r[FIRST TO quantifierstart-1] & [Match.loopBeginNonGreedy(MatchLoopBegin(minimum WITH min, maximum WITH max, next WITH r.size()-quantifierstart+2))] & r[quantifierstart TO LAST] & [Match.loopEndNonGreedy(quantifierstart-r.size()-1)]
                ELSE
                    r := r[FIRST TO quantifierstart-1] & [Match.loopBeginGreedy(MatchLoopBegin(minimum WITH min, maximum WITH max, next WITH r.size()-quantifierstart+2))] & r[quantifierstart TO LAST] & [Match.loopEndGreedy(quantifierstart-r.size()-1)]
                END IF
            WHEN "(" DO
                groupstart.append(r.size())
            WHEN ")" DO
                CHECK groupstart.size() > 1 ELSE
                    -- Syntax error.
                    RETURN []
                END CHECK
                LET gs := groupstart[LAST]
                LET mgs := r[gs]
                IF mgs ISA Match.altBegin THEN
                    r.append(Match.altEnd(0))
                    r[gs] := Match.altBegin(MatchAltBegin(alternatives WITH mgs.altBegin.alternatives, next WITH r.size()-gs))
                    FOREACH a IN mgs.altBegin.alternatives[1 TO LAST] & [r.size()-gs] DO
                        CHECK r[gs+a-1] ISA Match.altEnd ELSE
                            ASSERT FALSE -- Internal error.
                            EXIT PROCESS FAILURE
                        END CHECK
                        r[gs+a-1] := Match.altEnd(r.size() - a + 1)
                    END FOREACH
                END IF
                qs := gs
                groupstart := groupstart[FIRST TO LAST-1]
            WHEN "|" DO
                LET gs := groupstart[LAST]
                LET mgs := r[gs]
                IF mgs ISA Match.altBegin THEN
                    r.append(Match.altEnd(0))
                    r[gs] := Match.altBegin(MatchAltBegin(alternatives WITH mgs.altBegin.alternatives & [r.size()-gs]))
                ELSE
                    r := r[FIRST TO gs-1] & [Match.altBegin(MatchAltBegin(alternatives WITH [1, r.size()-gs+2]))] & r[gs TO LAST] & [Match.altEnd(0)]
                END IF
            /*
            WHEN "\\" DO
                INC i
                CASE pattern[i]
                    WHEN "t" DO
                        r.append(NEW MatchLiteral(match WITH "\t"))
                    WHEN "n" DO
                        r.append(NEW MatchLiteral(match WITH "\n"))
                    WHEN "r" DO
                        r.append(NEW MatchLiteral(match WITH "\r"))
                    WHEN "f" DO
                        r.append(NEW MatchLiteral(match WITH "\f"))
                    WHEN "a" DO
                        r.append(NEW MatchLiteral(match WITH "\u0007"))
                    WHEN "e" DO
                        r.append(NEW MatchLiteral(match WITH "\u001b"))
                    WHEN "c" DO
                        INC i
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(string.toCodePoint(string.upper(pattern[i])) - 64)))
                    WHEN "x" DO
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(base.fromHex(pattern[i TO i+1]))))
                        i := i + 2
                    WHEN "N" DO
                        ASSERT FALSE
                    WHEN "o" DO
                        ASSERT FALSE
                    WHEN "0", "1" DO
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(base.fromOctal(pattern[i TO i+2]))))
                        i := i + 2
                    WHEN "l" DO
                        ASSERT FALSE
                    WHEN "u" DO
                        ASSERT FALSE
                    WHEN "L" DO
                        ASSERT FALSE
                    WHEN "U" DO
                        ASSERT FALSE
                    WHEN "Q" DO
                        ASSERT FALSE
                    WHEN "E" DO
                        ASSERT FALSE
                    WHEN OTHERS DO
                        r.append(NEW MatchLiteral(match WITH pattern[i]))
                END CASE
            */
            WHEN OTHERS DO
                qs := r.size()
                IF ignoreCase THEN
                    r.append(Match.literalIgnoreCase(pattern[i]))
                ELSE
                    r.append(Match.literal(pattern[i]))
                END IF
        END CASE
        IF qs >= 0 THEN
            quantifierstart := qs
        ELSE
            quantifierstart := -1
        END IF
        INC i
    END WHILE
    LET m0 := r[0]
    IF m0 ISA Match.altBegin THEN
        r[0] := Match.altBegin(MatchAltBegin(alternatives WITH m0.altBegin.alternatives, next WITH r.size()))
        FOREACH a IN m0.altBegin.alternatives[1 TO LAST] DO
            CHECK r[a-1] ISA Match.altEnd ELSE
                ASSERT FALSE -- Internal error.
                EXIT PROCESS FAILURE
            END CHECK
            r[a-1] := Match.altEnd(r.size() - (a-1))
        END FOREACH
    END IF
    IF Debug THEN
        FOREACH m IN r INDEX ii DO
            print("  \(ii) \(dump([m]))")
        END FOREACH
        --print(dump(r))
    END IF
    RETURN r
END FUNCTION

TYPE BacktrackInfo IS RECORD
    instruction: Number
    index: Number
END RECORD

FUNCTION matchPart(regex: Regex, target: String, INOUT i: Number): Boolean
    CHECK regex.size() > 0 ELSE
        RETURN TRUE
    END CHECK
    IF Debug THEN
        print("-- matching target: \(target)")
    END IF
    VAR counters: Array<Array<Number>> := []
    VAR context: Array<BacktrackInfo> := []
    VAR ri := 0
    WHILE ri < regex.size() LABEL main DO
        LET m := regex[ri]
        IF Debug THEN
            print("\(ri) \(m)")
            print(context)
            print(counters)
            print("  \(target)")
            print(string.repeat(" ", 2+i) & "|")
        END IF
        VAR ok := TRUE
        CASE m
            WHEN ISA Match.any DO
                INC i
            WHEN ISA Match.literal DO
                IF i < target.length() AND target[i] = m.literal THEN
                    INC i
                ELSE
                    ok := FALSE
                END IF
            WHEN ISA Match.literalIgnoreCase DO
                IF i < target.length() AND string.lower(target[i]) = string.lower(m.literalIgnoreCase) THEN
                    INC i
                ELSE
                    ok := FALSE
                END IF
            WHEN ISA Match.begin DO
                IF i = 0 THEN
                    -- Accept
                ELSE
                    ok := FALSE
                END IF
            WHEN ISA Match.end DO
                IF i = target.length() THEN
                    -- Accept
                ELSE
                    ok := FALSE
                END IF
            WHEN ISA Match.loopBeginGreedy DO
                -- Handle degenerate case of a 0 maximum repeat group.
                IF m.loopBeginGreedy.maximum = 0 THEN
                    ri := ri + m.loopBeginGreedy.next
                    NEXT main
                END IF
                IF ri >= counters.size() THEN
                    counters[ri] := []
                END IF
                counters[ri].append(0)
                context.append(BacktrackInfo(
                    instruction WITH ri,
                    index WITH i
                ))
            WHEN ISA Match.loopEndGreedy DO
                ri := ri + m.loopEndGreedy
                LET lb := regex[ri]
                CHECK lb ISA Match.loopBeginGreedy ELSE
                    ASSERT FALSE -- Internal error.
                    RETURN FALSE
                END CHECK
                INC counters[ri][LAST]
                IF lb.loopBeginGreedy.maximum < 0 OR counters[ri][LAST] < lb.loopBeginGreedy.maximum THEN
                    context.append(BacktrackInfo(
                        instruction WITH ri,
                        index WITH i
                    ))
                ELSE
                    ri := ri + lb.loopBeginGreedy.next
                    NEXT main
                END IF
            WHEN ISA Match.loopBeginNonGreedy DO
                IF ri >= counters.size() THEN
                    counters[ri] := []
                END IF
                counters[ri].append(0)
                LET next := m.loopBeginNonGreedy.next
                IF m.loopBeginNonGreedy.minimum = 0 THEN
                    context.append(BacktrackInfo(
                        instruction WITH next-1,
                        index WITH i
                    ))
                    ri := next
                END IF
            WHEN ISA Match.loopEndNonGreedy DO
                LET lbi := ri + m.loopEndNonGreedy
                LET lb := regex[lbi]
                CHECK lb ISA Match.loopBeginNonGreedy ELSE
                    ASSERT FALSE -- Internal error.
                    RETURN FALSE
                END CHECK
                context.append(BacktrackInfo(
                    instruction WITH ri,
                    index WITH i
                ))
                INC counters[lbi][LAST]
                IF counters[lbi][LAST] < lb.loopBeginNonGreedy.minimum THEN
                    ri := lbi + 1
                    NEXT main
                END IF
            WHEN ISA Match.altBegin DO
                IF ri >= counters.size() THEN
                    counters[ri] := []
                END IF
                counters[ri].append(0)
                context.append(BacktrackInfo(
                    instruction WITH ri,
                    index WITH i
                ))
            WHEN ISA Match.altEnd DO
                ri := ri + m.altEnd
                NEXT main
        END CASE
        IF ok THEN
            INC ri
        ELSE
            WHILE context.size() > 0 DO
                IF Debug THEN
                    print("backtrack")
                    print(context)
                    print(counters)
                END IF
                LET lastri := ri
                ri := context[LAST].instruction
                i := context[LAST].index
                context.resize(context.size() - 1)
                IF Debug THEN
                    print("  ri=\(ri) i=\(i)")
                END IF
                LET bt := regex[ri]
                CASE bt
                    WHEN ISA Match.loopBeginGreedy DO
                        IF lastri >= ri + bt.loopBeginGreedy.next THEN
                            DEC counters[ri][LAST]
                        END IF
                        IF Debug THEN
                            print("  loopG counter=\(counters[ri][LAST])")
                        END IF
                        IF counters[ri][LAST] >= bt.loopBeginGreedy.minimum THEN
                            ri := ri + bt.loopBeginGreedy.next
                            NEXT main
                        END IF
                        IF counters[ri][LAST] < 0 THEN
                            counters[ri].resize(counters[ri].size() - 1)
                        END IF
                    WHEN ISA Match.loopEndNonGreedy DO
                        LET lbi := ri + bt.loopEndNonGreedy
                        IF Debug THEN
                            print("  loopEndNG counter=\(counters[lbi])")
                        END IF
                        LET lb := regex[lbi]
                        CHECK lb ISA Match.loopBeginNonGreedy ELSE
                            ASSERT FALSE -- Internal error.
                            EXIT PROCESS FAILURE
                        END CHECK
                        IF lb.loopBeginNonGreedy.maximum < 0 OR counters[lbi][LAST] < lb.loopBeginNonGreedy.maximum THEN
                            ri := lbi + 1
                            NEXT main
                        END IF
                        counters[ri].resize(counters[ri].size() - 1)
                    WHEN ISA Match.altBegin DO
                        INC counters[ri][LAST]
                        IF Debug THEN
                            print("  alt counter=\(counters[ri][LAST])")
                        END IF
                        IF counters[ri][LAST] < bt.altBegin.alternatives.size() THEN
                            context.append(BacktrackInfo(
                                instruction WITH ri,
                                index WITH i
                            ))
                            ri := ri + bt.altBegin.alternatives[counters[ri][LAST]]
                            NEXT main
                        END IF
                        counters[ri].resize(counters[ri].size() - 1)
                    WHEN OTHERS DO
                        ASSERT FALSE -- Internal error
                END CASE
            END WHILE
            IF Debug THEN
                print("  failed")
            END IF
            RETURN FALSE
        END IF
    END WHILE
    RETURN TRUE
END FUNCTION

FUNCTION match(regex: Regex, target: String): Boolean
    VAR i := 0
    RETURN matchPart(regex, target, INOUT i)
END FUNCTION

FUNCTION search(pattern: String, target: String): Boolean
    LET r := parse(pattern)
    RETURN match(r, target)
END FUNCTION

FUNCTION searchRegex(r: Regex, target: String): Boolean
    IF Debug THEN
        print("searchRegex \(target)")
    END IF
    FOR i := 0 TO target.length() DO
        VAR j := i
        IF matchPart(r, target, INOUT j) THEN
            RETURN TRUE
        END IF
    END FOR
    RETURN FALSE
END FUNCTION

FUNCTION test(pattern: String, cases: Array<Array<Object>>)
    print(pattern)
    LET r := parse(pattern)
    IF r.size() = 0 THEN
        print("failed pattern parse: \(pattern)")
        EXIT PROCESS FAILURE
    END IF
    FOREACH t IN cases DO
        IF Debug THEN
            print("pattern=\(pattern) target=\(t[1]) expect \(t[0])")
        END IF
        IF t[0] <> searchRegex(r, t[1]) THEN
            print("failed")
            EXIT PROCESS FAILURE
        END IF
    END FOREACH
END FUNCTION

BEGIN MAIN
    test("abc", [
        [TRUE, "abc"],
        [FALSE, "axc"],
    ])
    test("a.c", [
        [TRUE, "abc"],
        [FALSE, "acb"],
    ])
    test("ab?c", [
        [TRUE, "ac"],
        [TRUE, "abc"],
        [FALSE, "abbc"],
    ])
    test("ab*c", [
        [TRUE, "ac"],
        [TRUE, "abc"],
        [TRUE, "abbc"],
    ])
    test("ab+c", [
        [FALSE, "ac"],
        [TRUE, "abc"],
        [TRUE, "abbc"],
    ])
    test("ab{2,3}c", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc"],
        [TRUE, "abbbc"],
        [FALSE, "abbbbc"],
    ])
    test("^abc", [
        [TRUE, "abc"],
        [FALSE, "xabc"],
    ])
    test("a(b)c", [
        [TRUE, "abc"],
    ])
    test("a(b){1,2}bc", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc"],
        [TRUE, "abbbc"],
        [FALSE, "abbbbc"],
    ])
    test("a(b{1,2})bc", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc"],
        [TRUE, "abbbc"],
        [FALSE, "abbbbc"],
    ])
    test("a|bc", [
        [TRUE, "a"],
        [TRUE, "bc"],
        [TRUE, "abc"],
        [TRUE, "bbc"],
        [FALSE, "b"],
    ])
    test("a|bc|def", [
        [TRUE, "a"],
        [TRUE, "bc"],
        [TRUE, "def"],
    ])
    test("a(bc)*d", [
        [TRUE, "ad"],
        [FALSE, "abc"],
        [TRUE, "abcd"],
        [TRUE, "abcbcd"],
    ])
    test("a(b|c)*d", [
        [TRUE, "ad"],
        [TRUE, "abcd"],
        [TRUE, "abbbbcbd"],
        [FALSE, "abc"],
    ])
    test("^(0|(1(01*0)*1))*$", [
        [TRUE, ""],
        [TRUE, "0"],
        [TRUE, "00"],
        [FALSE, "01"],
        [FALSE, "10"],
        [TRUE, "11"],
        [TRUE, "000"],
        [FALSE, "001"],
        [FALSE, "010"],
        [TRUE, "011"],
        [FALSE, "100"],
        [FALSE, "101"],
        [TRUE, "110"],
        [FALSE, "111"],
        [TRUE, "0000"],
        [FALSE, "0001"],
        [FALSE, "0010"],
        [TRUE, "0011"],
        [FALSE, "0100"],
        [FALSE, "0101"],
        [TRUE, "0110"],
        [FALSE, "0111"],
        [FALSE, "1000"],
        [TRUE, "1001"],
        [FALSE, "1010"],
        [FALSE, "1011"],
        [TRUE, "1100"],
        [FALSE, "1101"],
        [FALSE, "1110"],
        [TRUE, "1111"],
        [TRUE, "00000"],
    ])
    test("a*ab", [
        [TRUE, "ab"],
    ])
    test("ab+?bc", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc"],
        [TRUE, "abbbc"],
    ])
    print("passed")
END MAIN
