IMPORT string

EXPORT Match
EXPORT Regex

EXPORT parse
EXPORT search
EXPORT searchRegex

INTERFACE Match
    FUNCTION dump(self: Match, indent: Number DEFAULT 0)
    FUNCTION match(self: Match, target: String): Boolean
END INTERFACE

TYPE Regex IS Array<VALID POINTER TO Match>

TYPE MatchLiteral IS CLASS IMPLEMENTS Match
    match: String
END CLASS

FUNCTION MatchLiteral.dump(self: VALID POINTER TO MatchLiteral, indent: Number)
    print(string.repeat(" ", indent*2) & "Literal " & self->match)
END FUNCTION

FUNCTION MatchLiteral.match(self: VALID POINTER TO MatchLiteral, target: String): Boolean
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    IF target[0] <> self->match THEN
        RETURN FALSE
    END IF
    RETURN TRUE
END FUNCTION

TYPE MatchLiteralIgnoreCase IS CLASS IMPLEMENTS Match
    match: String
END CLASS

FUNCTION MatchLiteralIgnoreCase.dump(self: VALID POINTER TO MatchLiteralIgnoreCase, indent: Number)
    print(string.repeat(" ", indent*2) & "LiteralIgnoreCase " & self->match)
END FUNCTION

FUNCTION MatchLiteralIgnoreCase.match(self: VALID POINTER TO MatchLiteralIgnoreCase, target: String): Boolean
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    IF string.lower(target[0]) <> self->match THEN
        RETURN FALSE
    END IF
    RETURN TRUE
END FUNCTION

TYPE MatchAny IS CLASS IMPLEMENTS Match
END CLASS

FUNCTION MatchAny.dump(self: VALID POINTER TO MatchAny, indent: Number)
    print(string.repeat(" ", indent*2) & "Any")
END FUNCTION

FUNCTION MatchAny.match(self: VALID POINTER TO MatchAny, target: String): Boolean
    RETURN TRUE
END FUNCTION

FUNCTION dump(regex: Regex)
    FOREACH m IN regex DO
        m->dump()
    END FOREACH
END FUNCTION

FUNCTION parse(pattern: String, ignoreCase: Boolean DEFAULT FALSE): Regex
    CHECK pattern.length() > 0 ELSE
        RETURN []
    END CHECK
    VAR r: Regex := []
    VAR i := 0
    WHILE i < pattern.length() DO
        CASE pattern[i]
            WHEN "." DO
                r.append(NEW MatchAny())
            WHEN OTHERS DO
                IF ignoreCase THEN
                    r.append(NEW MatchLiteralIgnoreCase(match WITH string.lower(pattern[i])))
                ELSE
                    r.append(NEW MatchLiteral(match WITH pattern[i]))
                END IF
        END CASE
        INC i
    END WHILE
    RETURN r
END FUNCTION

FUNCTION match(regex: Regex, target: String): Boolean
    CHECK regex.size() > 0 ELSE
        RETURN TRUE
    END CHECK
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    IF NOT regex[0]->match(target[0]) THEN
        RETURN FALSE
    END IF
    RETURN match(regex[1 TO LAST], target[1 TO LAST])
END FUNCTION

FUNCTION search(pattern: String, target: String): Boolean
    LET r := parse(pattern)
    RETURN match(r, target)
END FUNCTION

FUNCTION searchRegex(r: Regex, target: String): Boolean
    FOR i := 0 TO target.length() DO
        IF match(r, target[i TO LAST]) THEN
            RETURN TRUE
        END IF
    END FOR
    RETURN FALSE
END FUNCTION

BEGIN MAIN
    LET r1 := parse("abc")
    dump(r1)
    TESTCASE match(r1, "abc")
    TESTCASE NOT match(r1, "axc")
    LET r2 := parse("a.c")
    dump(r2)
    TESTCASE match(r2, "abc")
    TESTCASE NOT match(r2, "acb")
END MAIN
