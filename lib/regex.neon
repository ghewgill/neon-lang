--IMPORT base
--IMPORT string

--EXPORT Match
EXPORT Regex

--EXPORT dump
EXPORT parse
EXPORT search
--EXPORT searchRegex

CONSTANT Debug := TRUE

TYPE Opcode IS CHOICE
    any
    char: String
    begin
    end
    match
    jump: Array<Number>
END CHOICE

TYPE Regex IS Array<Opcode>

INTERFACE Expr
    FUNCTION dump(self: Expr): String
    FUNCTION reduce(self: Expr): Expr
    FUNCTION size(self: Expr): Number
    FUNCTION compile(self: Expr, INOUT regex: Regex)
END INTERFACE

TYPE ExprSequence IS CLASS IMPLEMENTS Expr
    exprs: Array<VALID POINTER TO Expr>
END CLASS

FUNCTION ExprSequence.dump(self: VALID POINTER TO ExprSequence): String
    VAR r := ""
    FOREACH e IN self->exprs DO
        r.append(e->dump())
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION ExprSequence.reduce(self: VALID POINTER TO ExprSequence): POINTER TO Expr
    VAR a: Array<VALID POINTER TO Expr> := []
    FOREACH e IN self->exprs DO
        a.append(e->reduce())
    END FOREACH
    RETURN NEW ExprSequence(exprs WITH a)
END FUNCTION

FUNCTION ExprSequence.size(self: VALID POINTER TO ExprSequence): Number
    VAR r := 0
    FOREACH e IN self->exprs DO
        r := r + e->size()
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION ExprSequence.compile(self: VALID POINTER TO ExprSequence, INOUT regex: Regex)
    FOREACH e IN self->exprs DO
        e->compile(INOUT regex)
    END FOREACH
END FUNCTION

TYPE ExprLiteral IS CLASS IMPLEMENTS Expr
    literal: String
END CLASS

FUNCTION ExprLiteral.dump(self: VALID POINTER TO ExprLiteral): String
    RETURN self->literal
END FUNCTION

FUNCTION ExprLiteral.reduce(self: VALID POINTER TO ExprLiteral): POINTER TO Expr
    RETURN self
END FUNCTION

FUNCTION ExprLiteral.size(self: VALID POINTER TO ExprLiteral): Number
    RETURN 1
END FUNCTION

FUNCTION ExprLiteral.compile(self: VALID POINTER TO ExprLiteral, INOUT regex: Regex)
    regex.append(Opcode.char(self->literal))
END FUNCTION

TYPE ExprAny IS CLASS IMPLEMENTS Expr
END CLASS

FUNCTION ExprAny.dump(self: VALID POINTER TO ExprAny): String
    RETURN "."
END FUNCTION

FUNCTION ExprAny.reduce(self: VALID POINTER TO ExprAny): POINTER TO Expr
    RETURN self
END FUNCTION

FUNCTION ExprAny.size(self: VALID POINTER TO ExprAny): Number
    RETURN 1
END FUNCTION

FUNCTION ExprAny.compile(self: VALID POINTER TO ExprAny, INOUT regex: Regex)
    regex.append(Opcode.any)
END FUNCTION

TYPE ExprOpt IS CLASS IMPLEMENTS Expr
    expr: VALID POINTER TO Expr
END CLASS

FUNCTION ExprOpt.dump(self: VALID POINTER TO ExprOpt): String
    RETURN self->expr->dump() & "?"
END FUNCTION

FUNCTION ExprOpt.reduce(self: VALID POINTER TO ExprOpt): POINTER TO Expr
    RETURN NEW ExprOpt(expr WITH self->expr->reduce())
END FUNCTION

FUNCTION ExprOpt.size(self: VALID POINTER TO ExprOpt): Number
    RETURN 1 + self->expr->size()
END FUNCTION

FUNCTION ExprOpt.compile(self: VALID POINTER TO ExprOpt, INOUT regex: Regex)
    regex.append(Opcode.jump([regex.size() + 1, regex.size() + 1 + self->expr->size()]))
    self->expr->compile(INOUT regex)
END FUNCTION

TYPE ExprStar IS CLASS IMPLEMENTS Expr
    expr: VALID POINTER TO Expr
END CLASS

FUNCTION ExprStar.dump(self: VALID POINTER TO ExprStar): String
    RETURN "\(self->expr->dump())*"
END FUNCTION

FUNCTION ExprStar.reduce(self: VALID POINTER TO ExprStar): POINTER TO Expr
    RETURN NEW ExprStar(expr WITH self->expr->reduce())
END FUNCTION

FUNCTION ExprStar.size(self: VALID POINTER TO ExprStar): Number
    RETURN 1 + self->expr->size() + 1
END FUNCTION

FUNCTION ExprStar.compile(self: VALID POINTER TO ExprStar, INOUT regex: Regex)
    LET top := regex.size()
    regex.append(Opcode.jump([regex.size() + 1, regex.size() + 1 + self->expr->size() + 1]))
    self->expr->compile(INOUT regex)
    regex.append(Opcode.jump([top]))
END FUNCTION

TYPE ExprRepeat IS CLASS IMPLEMENTS Expr
    minimum: Number
    maximum: Number
    expr: VALID POINTER TO Expr
END CLASS

FUNCTION ExprRepeat.dump(self: VALID POINTER TO ExprRepeat): String
    RETURN "\(self->expr->dump()){\(self->minimum),\(self->maximum)}"
END FUNCTION

FUNCTION ExprRepeat.reduce(self: VALID POINTER TO ExprRepeat): POINTER TO Expr
    LET r := NEW ExprSequence(exprs WITH [])
    LET rexpr := self->expr->reduce()
    FOR i := 1 TO self->minimum DO
        r->exprs.append(rexpr)
    END FOR
    IF self->maximum < 0 THEN
        r->exprs.append(NEW ExprStar(expr WITH rexpr))
    ELSE
        FOR i := self->minimum + 1 TO self->maximum DO
            r->exprs.append(NEW ExprOpt(expr WITH rexpr))
        END FOR
    END IF
    RETURN r
END FUNCTION

FUNCTION ExprRepeat.size(self: VALID POINTER TO ExprRepeat): Number
    ASSERT FALSE
    RETURN 0
END FUNCTION

FUNCTION ExprRepeat.compile(self: VALID POINTER TO ExprRepeat, INOUT regex: Regex)
    ASSERT FALSE
END FUNCTION

TYPE ExprBegin IS CLASS IMPLEMENTS Expr
END CLASS

FUNCTION ExprBegin.dump(self: VALID POINTER TO ExprBegin): String
    RETURN "^"
END FUNCTION

FUNCTION ExprBegin.reduce(self: VALID POINTER TO ExprBegin): POINTER TO Expr
    RETURN self
END FUNCTION

FUNCTION ExprBegin.size(self: VALID POINTER TO ExprBegin): Number
    RETURN 1
END FUNCTION

FUNCTION ExprBegin.compile(self: VALID POINTER TO ExprBegin, INOUT regex: Regex)
    regex.append(Opcode.begin)
END FUNCTION

TYPE ExprEnd IS CLASS IMPLEMENTS Expr
END CLASS

FUNCTION ExprEnd.dump(self: VALID POINTER TO ExprEnd): String
    RETURN "$"
END FUNCTION

FUNCTION ExprEnd.reduce(self: VALID POINTER TO ExprEnd): POINTER TO Expr
    RETURN self
END FUNCTION

FUNCTION ExprEnd.size(self: VALID POINTER TO ExprEnd): Number
    RETURN 1
END FUNCTION

FUNCTION ExprEnd.compile(self: VALID POINTER TO ExprEnd, INOUT regex: Regex)
    regex.append(Opcode.end)
END FUNCTION

TYPE ExprGroup IS CLASS IMPLEMENTS Expr
    expr: POINTER TO Expr
END CLASS

FUNCTION ExprGroup.dump(self: VALID POINTER TO ExprGroup): String
    RETURN self->expr->dump()
END FUNCTION

FUNCTION ExprGroup.reduce(self: VALID POINTER TO ExprGroup): POINTER TO Expr
    RETURN NEW ExprGroup(expr WITH self->expr->reduce())
END FUNCTION

FUNCTION ExprGroup.size(self: VALID POINTER TO ExprGroup): Number
    RETURN self->expr->size()
END FUNCTION

FUNCTION ExprGroup.compile(self: VALID POINTER TO ExprGroup, INOUT regex: Regex)
    self->expr->compile(INOUT regex)
END FUNCTION

TYPE ExprAlternative IS CLASS IMPLEMENTS Expr
    alternatives: Array<POINTER TO Expr>
END CLASS

FUNCTION ExprAlternative.dump(self: VALID POINTER TO ExprAlternative): String
    VAR r := ""
    FOREACH a IN self->alternatives DO
        IF r.length() > 0 THEN
            r.append("|")
        END IF
        r.append(a->dump())
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION ExprAlternative.reduce(self: VALID POINTER TO ExprAlternative): POINTER TO Expr
    VAR e: Array<POINTER TO Expr> := []
    FOREACH a IN self->alternatives DO
        e.append(a->reduce())
    END FOREACH
    RETURN NEW ExprAlternative(alternatives WITH e)
END FUNCTION

FUNCTION ExprAlternative.size(self: VALID POINTER TO ExprAlternative): Number
    VAR r := 0
    FOREACH a IN self->alternatives DO
        r := r + 1 + a->size()
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION ExprAlternative.compile(self: VALID POINTER TO ExprAlternative, INOUT regex: Regex)
    LET out := regex.size() + self->size()
    VAR jumps := [regex.size() + 1]
    FOREACH a IN self->alternatives[0 TO LAST-1] DO
        jumps.append(jumps[LAST] + a->size() + 1)
    END FOREACH
    regex.append(Opcode.jump(jumps))
    FOREACH a IN self->alternatives INDEX i DO
        a->compile(INOUT regex)
        IF i + 1 < self->alternatives.size() THEN
            regex.append(Opcode.jump([out]))
        END IF
    END FOREACH
END FUNCTION

FUNCTION parsePart(pattern: String, INOUT i: Number): VALID POINTER TO Expr
    VAR a: POINTER TO ExprAlternative := NIL
    VAR r: VALID POINTER TO ExprSequence := NEW ExprSequence
    WHILE i < pattern.length() DO
        CASE pattern[i]
            WHEN "^" DO
                r->exprs.append(NEW ExprBegin)
            WHEN "$" DO
                r->exprs.append(NEW ExprEnd)
            WHEN "." DO
                r->exprs.append(NEW ExprAny)
            WHEN "?" DO
                IF i+1 < pattern.length() AND pattern[i+1] = "?" THEN
                    INC i
                    r->exprs[LAST] := NEW ExprOpt(expr WITH r->exprs[LAST])
                ELSE
                    r->exprs[LAST] := NEW ExprOpt(expr WITH r->exprs[LAST])
                END IF
            WHEN "*" DO
                IF i+1 < pattern.length() AND pattern[i+1] = "?" THEN
                    INC i
                    r->exprs[LAST] := NEW ExprStar(expr WITH r->exprs[LAST])
                ELSE
                    r->exprs[LAST] := NEW ExprStar(expr WITH r->exprs[LAST])
                END IF
            WHEN "+" DO
                IF i+1 < pattern.length() AND pattern[i+1] = "?" THEN
                    INC i
                    r->exprs[LAST] := NEW ExprRepeat(minimum WITH 1, maximum WITH -1, expr WITH r->exprs[LAST])
                ELSE
                    r->exprs[LAST] := NEW ExprRepeat(minimum WITH 1, maximum WITH -1, expr WITH r->exprs[LAST])
                END IF
            WHEN "{" DO
                VAR min := 0
                VAR max := -1
                INC i
                VAR j := i
                WHILE j < pattern.length() AND "0" <= pattern[j] <= "9" DO
                    INC j
                END WHILE
                IF j > i THEN
                    min := num(pattern[i TO j-1])
                    i := j
                END IF
                IF pattern[i] = "," THEN
                    INC i
                    j := i
                    WHILE j < pattern.length() AND "0" <= pattern[j] <= "9" DO
                        INC j
                    END WHILE
                    IF j > i THEN
                        max := num(pattern[i TO j-1])
                        i := j
                    END IF
                ELSE
                    max := min
                END IF
                ASSERT pattern[i] = "}"
                r->exprs[LAST] := NEW ExprRepeat(minimum WITH min, maximum WITH max, expr WITH r->exprs[LAST])
            WHEN "(" DO
                INC i
                LET e := parsePart(pattern, INOUT i)
                ASSERT pattern[i] = ")"
                r->exprs.append(NEW ExprGroup(expr WITH e))
            WHEN ")" DO
                EXIT WHILE
            WHEN "|" DO
                IF VALID a THEN
                    a->alternatives.append(r)
                ELSE
                    a := NEW ExprAlternative(alternatives WITH [r])
                END IF
                r := NEW ExprSequence
            WHEN OTHERS DO
                r->exprs.append(NEW ExprLiteral(literal WITH pattern[i]))
        END CASE
        INC i
    END WHILE
    IF VALID a THEN
        a->alternatives.append(r)
        RETURN a
    ELSE
        RETURN r
    END IF
END FUNCTION

FUNCTION parse(pattern: String): VALID POINTER TO Expr
    VAR i := 0
    RETURN parsePart(pattern, INOUT i)
END FUNCTION

/*
            WHEN "\\" DO
                INC i
                CASE pattern[i]
                    WHEN "t" DO
                        r.append(NEW MatchLiteral(match WITH "\t"))
                    WHEN "n" DO
                        r.append(NEW MatchLiteral(match WITH "\n"))
                    WHEN "r" DO
                        r.append(NEW MatchLiteral(match WITH "\r"))
                    WHEN "f" DO
                        r.append(NEW MatchLiteral(match WITH "\f"))
                    WHEN "a" DO
                        r.append(NEW MatchLiteral(match WITH "\u0007"))
                    WHEN "e" DO
                        r.append(NEW MatchLiteral(match WITH "\u001b"))
                    WHEN "c" DO
                        INC i
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(string.toCodePoint(string.upper(pattern[i])) - 64)))
                    WHEN "x" DO
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(base.fromHex(pattern[i TO i+1]))))
                        i := i + 2
                    WHEN "N" DO
                        ASSERT FALSE
                    WHEN "o" DO
                        ASSERT FALSE
                    WHEN "0", "1" DO
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(base.fromOctal(pattern[i TO i+2]))))
                        i := i + 2
                    WHEN "l" DO
                        ASSERT FALSE
                    WHEN "u" DO
                        ASSERT FALSE
                    WHEN "L" DO
                        ASSERT FALSE
                    WHEN "U" DO
                        ASSERT FALSE
                    WHEN "Q" DO
                        ASSERT FALSE
                    WHEN "E" DO
                        ASSERT FALSE
                    WHEN OTHERS DO
                        r.append(NEW MatchLiteral(match WITH pattern[i]))
                END CASE
*/

FUNCTION compile(expr: VALID POINTER TO Expr): Regex
    VAR r: Regex := []
    VAR e := expr->reduce()
    -- TODO: This should just be a literal array expression,
    --       but there is a segfault in the compiler for some reason.
    VAR a: Array<VALID POINTER TO Expr> := []
    a.append(NEW ExprStar(expr WITH NEW ExprAny))
    a.append(e)
    e := NEW ExprSequence(exprs WITH a)
    e->compile(INOUT r)
    r.append(Opcode.match)
    RETURN r
END FUNCTION

FUNCTION matchPart(regex: Regex, ri: Number, target: String, ti: Number): Boolean
    LET o := regex[ri]
    CASE o
        WHEN ISA Opcode.any DO
            CHECK ti < target.length() ELSE
                RETURN FALSE
            END CHECK
            RETURN matchPart(regex, ri+1, target, ti+1)
        WHEN ISA Opcode.char DO
            CHECK ti < target.length() ELSE
                RETURN FALSE
            END CHECK
            IF o.char <> target[ti] THEN
                RETURN FALSE
            END IF
            RETURN matchPart(regex, ri+1, target, ti+1)
        WHEN ISA Opcode.begin DO
            IF ti > 0 THEN
                RETURN FALSE
            END IF
            RETURN matchPart(regex, ri+1, target, ti)
        WHEN ISA Opcode.end DO
            CHECK ti >= target.length() ELSE
                RETURN FALSE
            END CHECK
            RETURN matchPart(regex, ri+1, target, ti)
        WHEN ISA Opcode.match DO
            RETURN TRUE
        WHEN ISA Opcode.jump DO
            FOREACH j IN o.jump DO
                IF matchPart(regex, j, target, ti) THEN
                    RETURN TRUE
                END IF
            END FOREACH
            RETURN FALSE
    END CASE
END FUNCTION

FUNCTION match(regex: Regex, target: String): Boolean
    RETURN matchPart(regex, 0, target, 0)
END FUNCTION

FUNCTION search(pattern: String, target: String): Boolean
    LET r := parse(pattern)
    LET x := compile(r)
    RETURN match(x, target)
END FUNCTION

FUNCTION test(pattern: String, cases: Array<Array<Object>>)
    print(pattern)
    LET r := parse(pattern)
    --IF r.size() = 0 THEN
    --    print("failed pattern parse: \(pattern)")
    --    EXIT PROCESS FAILURE
    --END IF
    LET x := compile(r)
    FOREACH e IN x INDEX i DO
        print("\(i) \(e)")
    END FOREACH
    FOREACH t IN cases DO
        IF Debug THEN
            print("pattern=\(pattern) target=\(t[1]) expect \(t[0])")
        END IF
        IF t[0] <> match(x, t[1]) THEN
            print("failed")
            EXIT PROCESS FAILURE
        END IF
    END FOREACH
END FUNCTION

BEGIN MAIN
    LET e := parse("a?b")
    print(e->dump())
    LET r := compile(e)
    FOREACH x IN r INDEX i DO
        print("\(i) \(x)")
    END FOREACH
    /*
    TESTCASE parse("a") = [
        Match.literal("a"),
    ]
    TESTCASE parse("^a") = [
        Match.begin,
        Match.literal("a"),
    ]
    TESTCASE parse("a$") = [
        Match.literal("a"),
        Match.end,
    ]
    TESTCASE parse("()") = [
        Match.groupStart(TRUE),
        Match.groupEnd,
    ]
    TESTCASE parse("(a)") = [
        Match.groupStart(TRUE),
        Match.literal("a"),
        Match.groupEnd,
    ]
    TESTCASE parse("a?") = [
        Match.loopBeginGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH 1, next WITH 3)),
        Match.literal("a"),
        Match.loopEndGreedy(-2),
    ]
    TESTCASE parse("(a)?") = [
        Match.loopBeginGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH 1, next WITH 5)),
        Match.groupStart(TRUE),
        Match.literal("a"),
        Match.groupEnd,
        Match.loopEndGreedy(-4),
    ]
    TESTCASE parse("(a?)") = [
        Match.groupStart(TRUE),
        Match.loopBeginGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH 1, next WITH 3)),
        Match.literal("a"),
        Match.loopEndGreedy(-2),
        Match.groupEnd,
    ]
    TESTCASE parse("a*") = [
        Match.loopBeginGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH -1, next WITH 3)),
        Match.literal("a"),
        Match.loopEndGreedy(-2),
    ]
    TESTCASE parse("(a)*") = [
        Match.loopBeginGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH -1, next WITH 5)),
        Match.groupStart(TRUE),
        Match.literal("a"),
        Match.groupEnd,
        Match.loopEndGreedy(-4),
    ]
    TESTCASE parse("(a*)") = [
        Match.groupStart(TRUE),
        Match.loopBeginGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH -1, next WITH 3)),
        Match.literal("a"),
        Match.loopEndGreedy(-2),
        Match.groupEnd,
    ]
    TESTCASE parse("a*?") = [
        Match.loopBeginNonGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH -1, next WITH 3)),
        Match.literal("a"),
        Match.loopEndNonGreedy(-2),
    ]
    TESTCASE parse("(a)*?") = [
        Match.loopBeginNonGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH -1, next WITH 5)),
        Match.groupStart(TRUE),
        Match.literal("a"),
        Match.groupEnd,
        Match.loopEndNonGreedy(-4),
    ]
    TESTCASE parse("(a*?)") = [
        Match.groupStart(TRUE),
        Match.loopBeginNonGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH -1, next WITH 3)),
        Match.literal("a"),
        Match.loopEndNonGreedy(-2),
        Match.groupEnd,
    ]
    TESTCASE parse("|") = [
        Match.altBegin(MatchAltBegin(alternatives WITH [1, 2], next WITH 2)),
        Match.altEnd(1),
    ]
    TESTCASE parse("(|)") = [
        Match.groupStart(TRUE),
        Match.altBegin(MatchAltBegin(alternatives WITH [1, 2], next WITH 2)),
        Match.altEnd(1),
        Match.groupEnd,
    ]
    TESTCASE parse("b|c") = [
        Match.altBegin(MatchAltBegin(alternatives WITH [1, 3], next WITH 4)),
        Match.literal("b"),
        Match.altEnd(2),
        Match.literal("c"),
    ]
    TESTCASE parse("(b|c)") = [
        Match.groupStart(TRUE),
        Match.altBegin(MatchAltBegin(alternatives WITH [1, 3], next WITH 4)),
        Match.literal("b"),
        Match.altEnd(2),
        Match.literal("c"),
        Match.groupEnd,
    ]
    TESTCASE parse("b|c|d") = [
        Match.altBegin(MatchAltBegin(alternatives WITH [1, 3, 5], next WITH 6)),
        Match.literal("b"),
        Match.altEnd(4),
        Match.literal("c"),
        Match.altEnd(2),
        Match.literal("d"),
    ]
    TESTCASE parse("(b|c|d)") = [
        Match.groupStart(TRUE),
        Match.altBegin(MatchAltBegin(alternatives WITH [1, 3, 5], next WITH 6)),
        Match.literal("b"),
        Match.altEnd(4),
        Match.literal("c"),
        Match.altEnd(2),
        Match.literal("d"),
        Match.groupEnd,
    ]
    TESTCASE parse("((b|c)|d)") = [
        Match.groupStart(TRUE),
        Match.altBegin(MatchAltBegin(alternatives WITH [1, 8], next WITH 9)),
        Match.groupStart(TRUE),
        Match.altBegin(MatchAltBegin(alternatives WITH [1, 3], next WITH 4)),
        Match.literal("b"),
        Match.altEnd(2),
        Match.literal("c"),
        Match.groupEnd,
        Match.altEnd(2),
        Match.literal("d"),
        Match.groupEnd,
    ]
    TESTCASE parse("(b|(c|d))") = [
        Match.groupStart(TRUE),
        Match.altBegin(MatchAltBegin(alternatives WITH [1, 3], next WITH 9)),
        Match.literal("b"),
        Match.altEnd(7),
        Match.groupStart(TRUE),
        Match.altBegin(MatchAltBegin(alternatives WITH [1, 3], next WITH 4)),
        Match.literal("c"),
        Match.altEnd(2),
        Match.literal("d"),
        Match.groupEnd,
        Match.groupEnd,
    ]
    TESTCASE parse("a(b|c)d") = [
        Match.literal("a"),
        Match.groupStart(TRUE),
        Match.altBegin(MatchAltBegin(alternatives WITH [1, 3], next WITH 4)),
        Match.literal("b"),
        Match.altEnd(2),
        Match.literal("c"),
        Match.groupEnd,
        Match.literal("d"),
    ]
    TESTCASE parse("a(b|c)*d") = [
        Match.literal("a"),
        Match.loopBeginGreedy(MatchLoopBegin(minimum WITH 0, maximum WITH -1, next WITH 8)),
        Match.groupStart(TRUE),
        Match.altBegin(MatchAltBegin(alternatives WITH [1, 3], next WITH 4)),
        Match.literal("b"),
        Match.altEnd(2),
        Match.literal("c"),
        Match.groupEnd,
        Match.loopEndGreedy(-7),
        Match.literal("d"),
    ]
    */
    test("abc", [
        [TRUE, "abc"],
        [FALSE, "axc"],
    ])
    test("a.c", [
        [TRUE, "abc"],
        [FALSE, "acb"],
    ])
    test("ab?c", [
        [TRUE, "ac"],
        [TRUE, "abc"],
        [FALSE, "abbc"],
    ])
    test("ab*c", [
        [TRUE, "ac"],
        [TRUE, "abc"],
        [TRUE, "abbc"],
    ])
    test("ab+c", [
        [FALSE, "ac"],
        [TRUE, "abc"],
        [TRUE, "abbc"],
    ])
    test("ab{2,3}c", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc"],
        [TRUE, "abbbc"],
        [FALSE, "abbbbc"],
    ])
    test("^abc", [
        [TRUE, "abc"],
        [FALSE, "xabc"],
    ])
    test("a(b)c", [
        [TRUE, "abc"],
    ])
    test("a(b){1,2}bc", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc"],
        [TRUE, "abbbc"],
        [FALSE, "abbbbc"],
    ])
    test("a(b{1,2})bc", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc"],
        [TRUE, "abbbc"],
        [FALSE, "abbbbc"],
    ])
    test("a|bc", [
        [TRUE, "a"],
        [TRUE, "bc"],
        [TRUE, "abc"],
        [TRUE, "bbc"],
        [FALSE, "b"],
    ])
    test("a|bc|def", [
        [TRUE, "a"],
        [TRUE, "bc"],
        [TRUE, "def"],
    ])
    test("a(bc)*d", [
        [TRUE, "ad"],
        [FALSE, "abc"],
        [TRUE, "abcd"],
        [TRUE, "abcbcd"],
    ])
    test("a(b|c)*d", [
        [TRUE, "ad"],
        [TRUE, "abcd"],
        [TRUE, "abbbbcbd"],
        [FALSE, "abc"],
    ])
    test("^(0|(1(01*0)*1))*$", [
        [TRUE, ""],
        [TRUE, "0"],
        [TRUE, "00"],
        [FALSE, "01"],
        [FALSE, "10"],
        [TRUE, "11"],
        [TRUE, "000"],
        [FALSE, "001"],
        [FALSE, "010"],
        [TRUE, "011"],
        [FALSE, "100"],
        [FALSE, "101"],
        [TRUE, "110"],
        [FALSE, "111"],
        [TRUE, "0000"],
        [FALSE, "0001"],
        [FALSE, "0010"],
        [TRUE, "0011"],
        [FALSE, "0100"],
        [FALSE, "0101"],
        [TRUE, "0110"],
        [FALSE, "0111"],
        [FALSE, "1000"],
        [TRUE, "1001"],
        [FALSE, "1010"],
        [FALSE, "1011"],
        [TRUE, "1100"],
        [FALSE, "1101"],
        [FALSE, "1110"],
        [TRUE, "1111"],
        [TRUE, "00000"],
    ])
    test("a*ab", [
        [TRUE, "ab"],
    ])
    test("ab+?bc", [
        [FALSE, "ac"],
        [FALSE, "abc"],
        [TRUE, "abbc"],
        [TRUE, "abbbc"],
    ])
    test("^(b+?|a){1,2}?c", [
        [TRUE, "bbac"],
    ])
    print("passed")
END MAIN
