IMPORT base
IMPORT string

EXPORT Match
EXPORT Regex

EXPORT dump
EXPORT parse
EXPORT search
EXPORT searchRegex

INTERFACE Match
    FUNCTION dump(self: Match): String
    FUNCTION match(self: Match, target: String, INOUT i: Number): Boolean
END INTERFACE

TYPE Regex IS Array<VALID POINTER TO Match>

TYPE MatchLiteral IS CLASS IMPLEMENTS Match
    match: String
END CLASS

FUNCTION MatchLiteral.dump(self: VALID POINTER TO MatchLiteral): String
    RETURN self->match
END FUNCTION

FUNCTION MatchLiteral.match(self: VALID POINTER TO MatchLiteral, target: String, INOUT i: Number): Boolean
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    LET len := self->match.length()
    IF target[i TO i+len-1] <> self->match THEN
        RETURN FALSE
    END IF
    i := i + len
    RETURN TRUE
END FUNCTION

TYPE MatchLiteralIgnoreCase IS CLASS IMPLEMENTS Match
    match: String
END CLASS

FUNCTION MatchLiteralIgnoreCase.dump(self: VALID POINTER TO MatchLiteralIgnoreCase): String
    RETURN self->match
END FUNCTION

FUNCTION MatchLiteralIgnoreCase.match(self: VALID POINTER TO MatchLiteralIgnoreCase, target: String, INOUT i: Number): Boolean
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    LET len := self->match.length()
    IF string.lower(target[i TO i+len-1]) <> self->match THEN
        RETURN FALSE
    END IF
    i := i + len
    RETURN TRUE
END FUNCTION

TYPE MatchAny IS CLASS IMPLEMENTS Match
END CLASS

FUNCTION MatchAny.dump(self: VALID POINTER TO MatchAny): String
    RETURN "."
END FUNCTION

FUNCTION MatchAny.match(self: VALID POINTER TO MatchAny, target: String, INOUT i: Number): Boolean
    INC i
    RETURN TRUE
END FUNCTION

TYPE MatchRepeat IS CLASS IMPLEMENTS Match
    minimum: Number
    maximum: Number
    sub: POINTER TO Match
    tail: Regex
END CLASS

FUNCTION MatchRepeat.dump(self: VALID POINTER TO MatchRepeat): String
    RETURN "\(self->sub->dump()){\(self->minimum),\(self->maximum)}\(dump(self->tail))"
END FUNCTION

FUNCTION MatchRepeat.match(self: VALID POINTER TO MatchRepeat, target: String, INOUT i: Number): Boolean
    VAR n := 0
    VAR backtrack: Array<Number> := []
    WHILE self->maximum < 0 OR n < self->maximum DO
        LET b := i
        IF NOT self->sub->match(target, INOUT i) THEN
            EXIT WHILE
        END IF
        backtrack.append(b)
        INC n
    END WHILE
    WHILE n >= self->minimum DO
        IF match(self->tail, target[i TO LAST]) THEN
            EXIT WHILE
        END IF
        IF backtrack.size() = 0 THEN
            RETURN FALSE
        END IF
        i := backtrack[LAST]
        backtrack := backtrack[FIRST TO LAST-1]
        DEC n
    END WHILE
    RETURN n >= self->minimum
END FUNCTION

TYPE MatchBegin IS CLASS IMPLEMENTS Match
END CLASS

FUNCTION MatchBegin.dump(self: VALID POINTER TO MatchBegin): String
    RETURN "^"
END FUNCTION

FUNCTION MatchBegin.match(self: VALID POINTER TO MatchBegin, target: String, INOUT i: Number): Boolean
    -- TODO: This needs to check that we are at the actual start of the string, not starting a new match in the middle.
    RETURN i = 0
END FUNCTION

TYPE MatchGroup IS CLASS IMPLEMENTS Match
    regex: Regex
END CLASS

FUNCTION MatchGroup.dump(self: VALID POINTER TO MatchGroup): String
    RETURN "(\(dump(self->regex)))"
END FUNCTION

FUNCTION MatchGroup.match(self: VALID POINTER TO MatchGroup, target: String, INOUT i: Number): Boolean
    IF NOT matchPart(self->regex, target, INOUT i) THEN
        RETURN FALSE
    END IF
    RETURN TRUE
END FUNCTION

FUNCTION dump(regex: Regex): String
    VAR r := ""
    FOREACH m IN regex DO
        r.append(m->dump())
    END FOREACH
    RETURN r
END FUNCTION

FUNCTION parsePart(pattern: String, INOUT i: Number, ignoreCase: Boolean DEFAULT FALSE): Regex
    CHECK pattern.length() > 0 ELSE
        RETURN []
    END CHECK
    VAR r: Regex := []
    WHILE i < pattern.length() DO
        CASE pattern[i]
            WHEN "^" DO
                r.append(NEW MatchBegin())
            WHEN "." DO
                r.append(NEW MatchAny())
            WHEN "?" DO
                INC i
                r[LAST] := NEW MatchRepeat(
                    minimum WITH 0,
                    maximum WITH 1,
                    sub WITH r[LAST],
                    tail WITH parsePart(pattern, INOUT i, ignoreCase WITH ignoreCase)
                )
                EXIT WHILE
            WHEN "*" DO
                INC i
                r[LAST] := NEW MatchRepeat(
                    minimum WITH 0,
                    maximum WITH -1,
                    sub WITH r[LAST],
                    tail WITH parsePart(pattern, INOUT i, ignoreCase WITH ignoreCase)
                )
                EXIT WHILE
            WHEN "+" DO
                INC i
                r[LAST] := NEW MatchRepeat(
                    minimum WITH 1,
                    maximum WITH -1,
                    sub WITH r[LAST],
                    tail WITH parsePart(pattern, INOUT i, ignoreCase WITH ignoreCase)
                )
                EXIT WHILE
            WHEN "{" DO
                VAR min := 0
                VAR max := -1
                INC i
                VAR j := i
                WHILE j < pattern.length() AND "0" <= pattern[j] <= "9" DO
                    INC j
                END WHILE
                IF j > i THEN
                    min := num(pattern[i TO j-1])
                    i := j
                END IF
                IF pattern[i] = "," THEN
                    INC i
                    j := i
                    WHILE j < pattern.length() AND "0" <= pattern[j] <= "9" DO
                        INC j
                    END WHILE
                    IF j > i THEN
                        max := num(pattern[i TO j-1])
                        i := j
                    END IF
                ELSE
                    max := min
                END IF
                ASSERT pattern[i] = "}"
                INC i
                r[LAST] := NEW MatchRepeat(
                    minimum WITH min,
                    maximum WITH max,
                    sub WITH r[LAST],
                    tail WITH parsePart(pattern, INOUT i, ignoreCase WITH ignoreCase)
                )
                EXIT WHILE
            WHEN "(" DO
                INC i
                r.append(NEW MatchGroup(regex WITH parsePart(pattern, INOUT i, ignoreCase)))
            WHEN ")" DO
                EXIT WHILE
            WHEN "\\" DO
                INC i
                CASE pattern[i]
                    WHEN "t" DO
                        r.append(NEW MatchLiteral(match WITH "\t"))
                    WHEN "n" DO
                        r.append(NEW MatchLiteral(match WITH "\n"))
                    WHEN "r" DO
                        r.append(NEW MatchLiteral(match WITH "\r"))
                    WHEN "f" DO
                        r.append(NEW MatchLiteral(match WITH "\f"))
                    WHEN "a" DO
                        r.append(NEW MatchLiteral(match WITH "\u0007"))
                    WHEN "e" DO
                        r.append(NEW MatchLiteral(match WITH "\u001b"))
                    WHEN "c" DO
                        INC i
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(string.toCodePoint(string.upper(pattern[i])) - 64)))
                    WHEN "x" DO
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(base.fromHex(pattern[i TO i+1]))))
                        i := i + 2
                    WHEN "N" DO
                        ASSERT FALSE
                    WHEN "o" DO
                        ASSERT FALSE
                    WHEN "0", "1" DO
                        r.append(NEW MatchLiteral(match WITH string.fromCodePoint(base.fromOctal(pattern[i TO i+2]))))
                        i := i + 2
                    WHEN "l" DO
                        ASSERT FALSE
                    WHEN "u" DO
                        ASSERT FALSE
                    WHEN "L" DO
                        ASSERT FALSE
                    WHEN "U" DO
                        ASSERT FALSE
                    WHEN "Q" DO
                        ASSERT FALSE
                    WHEN "E" DO
                        ASSERT FALSE
                    WHEN OTHERS DO
                        r.append(NEW MatchLiteral(match WITH pattern[i]))
                END CASE
            WHEN OTHERS DO
                IF ignoreCase THEN
                    r.append(NEW MatchLiteralIgnoreCase(match WITH string.lower(pattern[i])))
                ELSE
                    r.append(NEW MatchLiteral(match WITH pattern[i]))
                END IF
        END CASE
        INC i
    END WHILE
    RETURN r
END FUNCTION

FUNCTION parse(pattern: String, ignoreCase: Boolean DEFAULT FALSE): Regex
    VAR i := 0
    LET r := parsePart(pattern, INOUT i, ignoreCase)
    IF i < pattern.length() THEN
        print(pattern)
        print(string.repeat(" ", i) & "^ syntax error here")
        RETURN []
    END IF
    RETURN r
END FUNCTION

FUNCTION matchPart(regex: Regex, target: String, INOUT i: Number): Boolean
    CHECK regex.size() > 0 ELSE
        RETURN TRUE
    END CHECK
    CHECK target.length() > 0 ELSE
        RETURN FALSE
    END CHECK
    FOREACH m IN regex DO
        IF NOT m->match(target, INOUT i) THEN
            RETURN FALSE
        END IF
    END FOREACH
    RETURN TRUE
END FUNCTION

FUNCTION match(regex: Regex, target: String): Boolean
    VAR i := 0
    RETURN matchPart(regex, target, INOUT i)
END FUNCTION

FUNCTION search(pattern: String, target: String): Boolean
    LET r := parse(pattern)
    RETURN match(r, target)
END FUNCTION

FUNCTION searchRegex(r: Regex, target: String): Boolean
    FOR i := 0 TO target.length() DO
        VAR j := i
        IF matchPart(r, target, INOUT j) THEN
            RETURN TRUE
        END IF
    END FOR
    RETURN FALSE
END FUNCTION

BEGIN MAIN
    LET r1 := parse("abc")
    print(dump(r1))
    TESTCASE match(r1, "abc")
    TESTCASE NOT match(r1, "axc")
    LET r2 := parse("a.c")
    print(dump(r2))
    TESTCASE match(r2, "abc")
    TESTCASE NOT match(r2, "acb")
    LET r3 := parse("ab?c")
    print(dump(r3))
    TESTCASE match(r3, "ac")
    TESTCASE match(r3, "abc")
    TESTCASE NOT match(r3, "abbc")
    LET r4 := parse("ab*c")
    print(dump(r4))
    TESTCASE match(r4, "ac")
    TESTCASE match(r4, "abc")
    TESTCASE match(r4, "abbc")
    LET r5 := parse("ab+c")
    print(dump(r5))
    TESTCASE NOT match(r5, "ac")
    TESTCASE match(r5, "abc")
    TESTCASE match(r5, "abbc")
    LET r6 := parse("ab{2,3}c")
    print(dump(r6))
    TESTCASE NOT match(r6, "ac")
    TESTCASE NOT match(r6, "abc")
    TESTCASE match(r6, "abbc")
    TESTCASE match(r6, "abbbc")
    TESTCASE NOT match(r6, "abbbbc")
    LET r7 := parse("^abc")
    print(dump(r7))
    TESTCASE match(r7, "abc")
    TESTCASE NOT match(r7, "xabc")
    LET r8 := parse("a(b)c")
    print(dump(r8))
    TESTCASE match(r8, "abc")
    LET r9 := parse("a(b){1,2}c")
    print(dump(r9))
    TESTCASE NOT match(r9, "ac")
    TESTCASE match(r9, "abc")
    TESTCASE match(r9, "abbc")
    TESTCASE NOT match(r9, "abbbc")
END MAIN
