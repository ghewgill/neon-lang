EXPORT BigInt
EXPORT ZERO
EXPORT ONE
EXPORT make
EXPORT make_from_string
EXPORT abs
EXPORT add
EXPORT equals
EXPORT less
EXPORT mul
EXPORT neg
EXPORT sub

IMPORT math

CONST DIGITS: Number := 6
CONST BASE: Number := 10^DIGITS

TYPE Comparison := ENUM
    less
    equal
    greater
END ENUM

TYPE BigInt := RECORD
    sign: Number
    digits: Array<Number>
END RECORD

% TODO: Make these constants
LET ZERO: BigInt := BigInt(1, [0])
LET ONE: BigInt := BigInt(1, [1])

FUNCTION normalise(INOUT r: BigInt)
    WHILE r.digits.size() >= 2 AND r.digits[LAST] = 0 DO
        r.digits := r.digits[FIRST TO LAST-1]
    END WHILE
    IF r.digits = [0] THEN
        r.sign := 1
    END IF
END FUNCTION

FUNCTION make(x: Number): BigInt
    VAR r: BigInt
    r.sign := IF x < 0 THEN -1 ELSE 1
    VAR n: Number := math.floor(math.abs(x))
    r.digits[0] := 0
    VAR i: Number := 0
    WHILE n > 0 DO
        r.digits[i] := n MOD BASE
        n := math.floor(n / BASE)
        inc(i)
    END WHILE
    RETURN r
END FUNCTION

FUNCTION make_from_string(s: String): BigInt
    VAR r: BigInt
    VAR t: String := s
    r.sign := 1
    IF t[0] = "-" THEN
        r.sign := -1
        t := t[1 TO LAST]
    END IF
    VAR i: Number := 0
    VAR j: Number := t.length() - DIGITS
    WHILE j >= 0 DO
        r.digits[i] := num(t[j TO j+DIGITS-1])
        inc(i)
        j := j - DIGITS
    END WHILE
    IF j > -DIGITS THEN
        r.digits[i] := num(t[FIRST TO j+DIGITS-1])
    END IF
    RETURN r
END FUNCTION

FUNCTION add(x, y: BigInt): BigInt
    IF x.sign = y.sign THEN
        VAR r: BigInt
        r.sign := x.sign
        VAR i: Number := 0
        VAR carry: Number := 0
        WHILE i < x.digits.size() OR i < y.digits.size() OR carry # 0 DO
            r.digits[i] := (IF i < x.digits.size() THEN x.digits[i] ELSE 0) + (IF i < y.digits.size() THEN y.digits[i] ELSE 0) + carry
            IF r.digits[i] >= BASE THEN
                r.digits[i] := r.digits[i] - BASE
                carry := 1
            ELSE
                carry := 0
            END IF
            inc(i)
        END WHILE
        RETURN r
    ELSE
        RETURN sub(x, neg(y))
    END IF
END FUNCTION

FUNCTION sub(x, y: BigInt): BigInt
    IF x.sign = y.sign THEN
        IF NOT less(abs(x), abs(y)) THEN
            VAR r: BigInt
            r.sign := x.sign
            VAR i: Number := 0
            VAR borrow: Number := 0
            WHILE i < x.digits.size() DO
                r.digits[i] := (IF i < x.digits.size() THEN x.digits[i] ELSE 0) - (IF i < y.digits.size() THEN y.digits[i] ELSE 0) - borrow
                IF r.digits[i] < 0 THEN
                    r.digits[i] := r.digits[i] + BASE
                    borrow := 1
                ELSE
                    borrow := 0
                END IF
                inc(i)
            END WHILE
            normalise(r)
            RETURN r
        ELSE
            RETURN neg(sub(y, x))
        END IF
    ELSE
        RETURN add(x, neg(y))
    END IF
END FUNCTION

FUNCTION mul(x, y: BigInt): BigInt
    VAR r: BigInt := ZERO
    FOR i := 0 TO y.digits.size()-1 DO
        VAR p: BigInt := ZERO
        VAR carry: Number := 0
        FOR j := 0 TO x.digits.size()-1 DO
            LET z: Number := (IF j < x.digits.size() THEN x.digits[j] ELSE 0) * y.digits[i] + carry
            p.digits[i+j] := z MOD BASE
            carry := math.floor(z / BASE)
        END FOR
        IF carry # 0 THEN
            p.digits[i+x.digits.size()] := carry
        END IF
        r := r.add(p)
    END FOR
    r.sign := x.sign * y.sign
    normalise(r)
    RETURN r
END FUNCTION

FUNCTION abs(x: BigInt): BigInt
    VAR r: BigInt := x
    r.sign := 1
    RETURN r
END FUNCTION

FUNCTION neg(x: BigInt): BigInt
    VAR r: BigInt := x
    r.sign := -r.sign
    RETURN r
END FUNCTION

FUNCTION less(x, y: BigInt): Boolean
    IF x.sign # y.sign THEN
        RETURN x.sign < y.sign
    END IF
    IF x.digits.size() # y.digits.size() THEN
        RETURN x.sign*x.digits.size() < y.sign*y.digits.size()
    END IF
    FOR i := x.digits.size()-1 TO 0 STEP -1 DO
        IF x.digits[i] # y.digits[i] THEN
            RETURN x.sign*x.digits[i] < y.sign*y.digits[i]
        END IF
    END FOR
    RETURN FALSE
END FUNCTION

FUNCTION equals(x, y: BigInt): Boolean
    RETURN x.sign = y.sign AND x.digits = y.digits
END FUNCTION

FUNCTION BigInt.add(self, x: BigInt): BigInt
    RETURN add(self, x)
END FUNCTION

FUNCTION BigInt.equals(self, x: BigInt): Boolean
    RETURN equals(self, x)
END FUNCTION

FUNCTION BigInt.mul(self, x: BigInt): BigInt
    RETURN mul(self, x)
END FUNCTION

FUNCTION BigInt.sub(self, x: BigInt): BigInt
    RETURN sub(self, x)
END FUNCTION

FUNCTION BigInt.to_string(self: BigInt): String
    VAR s: String
    FOR i := 0 TO self.digits.size()-1 DO
        IF i < self.digits.size()-1 THEN
            s := format(str(self.digits[i]), "0\(DIGITS)d") & s
        ELSE
            s := str(self.digits[i]) & s
        END IF
    END FOR
    RETURN s
END FUNCTION
