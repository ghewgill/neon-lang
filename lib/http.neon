/*  File: http
 *
 *  Functions for making HTTP requests.
 */
IMPORT net
IMPORT string

EXPORT HttpException

EXPORT get
EXPORT post
EXPORT setRequireValidCertificate

/*  Exception: HttpException
 *
 *  Raised when an HTTP request returns anything other than 200 OK.
 */
EXCEPTION HttpException

VAR g_validateMode: net.TlsPeerValidateMode := net.TlsPeerValidateMode.RequireValidCertificate

/*  Function: get
 *
 *  Perform an HTTP GET operation with the specified url.
 *
 *  Parameters:
 *      url - the url
 *      headers - the response headers from the server
 */
FUNCTION get(url: String, requestHeaders: Dictionary<String>, OUT responseHeaders: Array<String> DEFAULT _): Bytes
    RETURN exec("GET", url, "", requestHeaders, OUT responseHeaders)
END FUNCTION

/*  Function: post
 *
 *  Perform an HTTP POST operation with the specified url and post data.
 *
 *  Parameters:
 *      url - the url
 *      post_data - the body of the POST request
 *      headers - the response headers from the server
 */
FUNCTION post(url: String, post_data: String, requestHeaders: Dictionary<String>, OUT responseHeaders: Array<String> DEFAULT _): Bytes
    RETURN exec("POST", url, post_data, requestHeaders, OUT responseHeaders)
END FUNCTION

/*  Function: setRequireValidCertificate
 *
 *  Set whether certificate validation is required for HTTPS requests.
 *  Note: Turning off certificate validation is a security concern.
 *
 *  Parameters:
 *      requireValid - TRUE if certificate validation is required
 */
FUNCTION setRequireValidCertificate(requireValid: Boolean)
    g_validateMode := (IF requireValid THEN net.TlsPeerValidateMode.RequireValidCertificate ELSE net.TlsPeerValidateMode.AllowInvalidCertificate)
END FUNCTION

FUNCTION exec(method: String, url: String, post_data: String, requestHeaders: Dictionary<String>, OUT responseHeaders: Array<String> DEFAULT _): Bytes
    VAR scheme: String
    VAR server: String
    VAR port: Number
    VAR path: String
    decomposeUrl(url, OUT scheme, OUT server, OUT port, OUT path)
    LET s: net.Socket := (IF scheme = "https" THEN net.tlsClientSocket(validateMode WITH g_validateMode) ELSE net.tcpSocket())
    s.connect(server, port)
    VAR request: String := "\(method) \(path) HTTP/1.0\r\n"
    request.append("Host: \(server)\r\n")
    IF method = "POST" THEN
        request.append("Content-Length: \(post_data.length())\r\n")
    END IF
    FOREACH h IN requestHeaders.keys() DO
        request.append("\(h): \(requestHeaders[h])\r\n")
    END FOREACH
    request.append("\r\n")
    s.send(request.toBytes())
    IF method = "POST" THEN
        s.send(post_data.toBytes())
    END IF
    VAR response: Bytes := HEXBYTES ""
    LOOP
        VAR buf: Bytes
        IF NOT s.recv(1024, OUT buf) THEN
            EXIT LOOP
        END IF
        response := response & buf
    END LOOP
    responseHeaders := []
    VAR i: Number := 0
    LET status: String := nextLine(response, INOUT i)
    LOOP
        LET header: String := nextLine(response, INOUT i)
        IF header = "" THEN
            EXIT LOOP
        END IF
        responseHeaders.append(header)
    END LOOP
    s.close()
    RETURN response[i TO LAST]
END FUNCTION

FUNCTION decomposeUrl(url: String, OUT scheme: String, OUT server: String, OUT port: Number, OUT path: String)
    LET schemecolon: Number := string.find(url, ":")
    CHECK schemecolon >= 0 ELSE
        RAISE HttpException("url format error")
    END CHECK
    scheme := url[FIRST TO schemecolon-1]
    CHECK scheme IN ["http", "https"] ELSE
        RAISE HttpException("url scheme not supported")
    END CHECK
    CHECK url[schemecolon TO schemecolon+2] = "://" ELSE
        RAISE HttpException("url format error")
    END CHECK
    LET tail: String := url[schemecolon+3 TO LAST]
    LET slash: Number := string.find(tail, "/")
    CHECK slash >= 0 ELSE
        RAISE HttpException("url format error")
    END CHECK
    LET portcolon: Number := string.find(tail, ":")
    server := tail[FIRST TO (IF portcolon >= 0 THEN portcolon-1 ELSE slash-1)]
    port := (IF 0 <= portcolon < slash THEN num(tail[portcolon+1 TO slash-1]) ELSE (IF scheme = "https" THEN 443 ELSE 80))
    path := tail[slash TO LAST]
END FUNCTION

FUNCTION nextLine(buf: Bytes, INOUT i: Number): String
    LET a: Array<Number> := buf.toArray()
    LET start: Number := i
    VAR lastchar: Number := i-1
    WHILE string.fromCodePoint(a[i]) <> "\n" DO
        IF string.fromCodePoint(a[i]) <> "\r" THEN
            lastchar := i
        END IF
        INC i
    END WHILE
    INC i
    RETURN buf[start TO lastchar].decodeToString()
END FUNCTION

BEGIN MAIN
    FUNCTION check(url: String, scheme: String, server: String, port: Number, path: String)
        VAR c: String
        VAR s: String
        VAR p: Number
        VAR t: String
        decomposeUrl(url, OUT c, OUT s, OUT p, OUT t)
        TESTCASE c = scheme
        TESTCASE s = server
        TESTCASE p = port
        TESTCASE t = path
    END FUNCTION
    check("http://hello/world", "http", "hello", 80, "/world")
    check("http://hello:1234/world", "http", "hello", 1234, "/world")
    check("https://hello/world", "https", "hello", 443, "/world")

    VAR x: String := "hello\r\nworld\r\n\r\n"
    VAR b: Bytes := x.toBytes()
    VAR i: Number := 0
    TESTCASE nextLine(b, INOUT i) = "hello"
    TESTCASE i = 7
    TESTCASE nextLine(b, INOUT i) = "world"
    TESTCASE i = 14
    TESTCASE nextLine(b, INOUT i) = ""
    TESTCASE i = 16

    VAR responseHeaders: Array<String>
    LET r: Bytes := get("http://neverssl.com/", {}, OUT responseHeaders)
    FOREACH h IN responseHeaders DO
        print(h)
    END FOREACH
    print("size=\(r.size())")
END MAIN
