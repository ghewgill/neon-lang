EXPORT Variant
EXPORT Type
EXPORT TypeMismatch
EXPORT make_null
EXPORT make_boolean
EXPORT make_number
EXPORT make_string
EXPORT make_bytes
EXPORT make_array
EXPORT make_dictionary

DECLARE EXCEPTION TypeMismatch

TYPE Type := ENUM
    null
    boolean
    number
    string
    bytes
    array
    dictionary
END ENUM

TYPE Variant := RECORD
    PRIVATE type: Type
    PRIVATE val_boolean: Boolean
    PRIVATE val_number: Number
    PRIVATE val_string: String
    PRIVATE val_bytes: Bytes
    PRIVATE val_array: Array<Variant>
    PRIVATE val_dictionary: Dictionary<Variant>
END RECORD

FUNCTION make_null(): Variant
    VAR r: Variant
    r.set_null()
    RETURN r
END FUNCTION

FUNCTION make_boolean(b: Boolean): Variant
    VAR r: Variant
    r.set_boolean(b)
    RETURN r
END FUNCTION

FUNCTION make_number(n: Number): Variant
    VAR r: Variant
    r.set_number(n)
    RETURN r
END FUNCTION

FUNCTION make_string(s: String): Variant
    VAR r: Variant
    r.set_string(s)
    RETURN r
END FUNCTION

FUNCTION make_bytes(b: Bytes): Variant
    VAR r: Variant
    r.set_bytes(b)
    RETURN r
END FUNCTION

FUNCTION make_array(a: Array<Variant>): Variant
    VAR r: Variant
    r.set_array(a)
    RETURN r
END FUNCTION

FUNCTION make_dictionary(d: Dictionary<Variant>): Variant
    VAR r: Variant
    r.set_dictionary(d)
    RETURN r
END FUNCTION

FUNCTION Variant.get_type(IN self: Variant): Type
    RETURN self.type
END FUNCTION

FUNCTION Variant.set_null(INOUT self: Variant)
    self.type := Type.null
END FUNCTION

FUNCTION Variant.is_null(IN self: Variant): Boolean
    RETURN self.type = Type.null
END FUNCTION

FUNCTION Variant.set_boolean(INOUT self: Variant, b: Boolean)
    self.type := Type.boolean
    self.val_boolean := b
END FUNCTION

FUNCTION Variant.get_boolean(IN self: Variant): Boolean
    IF self.type # Type.boolean THEN
        RAISE TypeMismatch
    END IF
    RETURN self.val_boolean
END FUNCTION

FUNCTION Variant.set_number(INOUT self: Variant, n: Number)
    self.type := Type.number
    self.val_number := n
END FUNCTION

FUNCTION Variant.get_number(IN self: Variant): Number
    IF self.type # Type.number THEN
        RAISE TypeMismatch
    END IF
    RETURN self.val_number
END FUNCTION

FUNCTION Variant.set_string(INOUT self: Variant, s: String)
    self.type := Type.string
    self.val_string := s
END FUNCTION

FUNCTION Variant.get_string(IN self: Variant): String
    IF self.type # Type.string THEN
        RAISE TypeMismatch
    END IF
    RETURN self.val_string
END FUNCTION

FUNCTION Variant.set_bytes(INOUT self: Variant, s: Bytes)
    self.type := Type.bytes
    self.val_bytes := s
END FUNCTION

FUNCTION Variant.get_bytes(IN self: Variant): Bytes
    IF self.type # Type.bytes THEN
        RAISE TypeMismatch
    END IF
    RETURN self.val_bytes
END FUNCTION

FUNCTION Variant.set_array(INOUT self: Variant, a: Array<Variant>)
    self.type := Type.array
    self.val_array := a
END FUNCTION

FUNCTION Variant.get_array(IN self: Variant): Array<Variant>
    IF self.type # Type.array THEN
        RAISE TypeMismatch
    END IF
    RETURN self.val_array
END FUNCTION

FUNCTION Variant.set_dictionary(INOUT self: Variant, d: Dictionary<Variant>)
    self.type := Type.dictionary
    self.val_dictionary := d
END FUNCTION

FUNCTION Variant.get_dictionary(IN self: Variant): Dictionary<Variant>
    IF self.type # Type.dictionary THEN
        RAISE TypeMismatch
    END IF
    RETURN self.val_dictionary
END FUNCTION

FUNCTION Variant.to_string(IN self: Variant): String
    CASE self.type
        WHEN Type.null DO
            RETURN "null"
        WHEN Type.boolean DO
            RETURN IF self.val_boolean THEN "true" ELSE "false"
        WHEN Type.number DO
            RETURN str(self.val_number)
        WHEN Type.string DO
            RETURN self.val_string
        WHEN Type.bytes DO
            RETURN "<bytes>"
        WHEN Type.array DO
            VAR r: String := "["
            FOREACH x OF self.val_array INDEX i DO
                IF i > 0 THEN
                    r.append(", ")
                END IF
                IF x.get_type() = Type.string THEN
                    r.append("\"\(x)\"")
                ELSE
                    r.append(x.to_string())
                END IF
            END FOREACH
            r.append("]")
            RETURN r
        WHEN Type.dictionary DO
            VAR r: String := "{"
            LET keys: Array<String> := self.val_dictionary.keys() % TODO: remove this temporary
            FOREACH x OF keys INDEX i DO
                IF i > 0 THEN
                    r.append(", ")
                END IF
                r.append("\"\(x)\": ")
                IF self.val_dictionary[x].get_type() = Type.string THEN
                    r.append("\"\(self.val_dictionary[x])\"")
                ELSE
                    r.append(" \(self.val_dictionary[x])")
                END IF
            END FOREACH
            r.append("}")
            RETURN r
    END CASE
    RETURN "TODO"
END FUNCTION
