IMPORT binary
IMPORT file
IMPORT math
IMPORT regex
IMPORT string
IMPORT sys
IMPORT textio

CONSTANT BYTECODE_VERSION: Number := 3

EXCEPTION InternalException

FUNCTION quoted(s: String): String
    VAR r := "\""
    FOREACH c IN s DO
        CASE c
            WHEN "\b" DO
                r.append("\\b")
            WHEN "\f" DO
                r.append("\\f")
            WHEN "\n" DO
                r.append("\\n")
            WHEN "\r" DO
                r.append("\\r")
            WHEN "\t" DO
                r.append("\\t")
            WHEN "\"", "\\" DO
                r.append("\\")
                r.append(c)
            WHEN OTHERS DO
                LET p := string.toCodePoint(c)
                IF c >= " " AND p < 0x7f THEN
                    r.append(c)
                ELSIF p < 0x10000 THEN
                    r.append("\\u\(p:04x)")
                ELSE
                    r.append("\\U\(p:08x)")
                END IF
        END CASE
    END FOREACH
    r.append("\"")
    RETURN r
END FUNCTION

FUNCTION getVint(a: Array<Number>, INOUT i: Number): Number
    VAR r: Number := 0
    LOOP
        LET x: Number := a[i]
        INC i
        r := binary.or64(binary.shiftLeft64(r, 7), binary.and32(x, 0x7f))
        IF binary.and32(x, 0x80) = 0 THEN
            EXIT LOOP
        END IF
    END LOOP
    RETURN r
END FUNCTION

FUNCTION getBytesTable(a: Array<Number>): Array<Bytes>
    VAR r: Array<Bytes> := []
    VAR i: Number := 0
    WHILE i < a.size() DO
        LET len: Number := getVint(a, INOUT i)
        r.append(a[i TO i+len-1].toBytes())
        i := i + len
    END WHILE
    RETURN r
END FUNCTION

TYPE Import IS RECORD
    name: Number
    optional: Boolean
    hash: Bytes
END RECORD

TYPE Function IS RECORD
    name: Number
    nest: Number
    params: Number
    locals: Number
    entry: Number
END RECORD

TYPE Exception IS RECORD
    start: Number
    end: Number
    excid: Number
    handler: Number
    stack_depth: Number
END RECORD

TYPE ClassInfo IS RECORD
    name: Number
    interfaces: Array<Array<Number>>
END RECORD

TYPE Bytecode IS RECORD
    version: Number
    sourceHash: Bytes
    globalSize: Number
    strtable: Array<String>
    bytestable: Array<Bytes>
    imports: Array<Import>
    functions: Array<Function>
    exceptions: Array<Exception>
    classes: Array<ClassInfo>
    code: Array<Number>
END RECORD

FUNCTION decodeBytecode(bytes: Bytes): Bytecode
    VAR r: Bytecode := Bytecode()
    LET a: Array<Number> := bytes.toArray()
    VAR i: Number := 0

    ASSERT bytes[0 TO 3] = HEXBYTES "4e 65 00 6e"
    i := i + 4

    r.version := getVint(a, INOUT i)
    ASSERT r.version = BYTECODE_VERSION

    r.sourceHash := bytes[i TO i+31]
    i := i + 32
    r.globalSize := getVint(a, INOUT i)

    LET strtablesize: Number := getVint(a, INOUT i)
    r.bytestable := getBytesTable(a[i TO i+strtablesize-1])
    FOR j := 0 TO r.bytestable.size()-1 DO
        LET dr: DecodeResult := r.bytestable[j].decodeToString()
        IF dr ISA DecodeResult.string THEN
            r.strtable[j] := dr.string
        ELSE
            -- Leave the strtable entry empty if it can't be decoded.
        END IF
    END FOR
    i := i + strtablesize

    LET typesize: Number := getVint(a, INOUT i)
    ASSERT typesize = 0

    LET constantsize: Number := getVint(a, INOUT i)
    ASSERT constantsize = 0

    LET variablesize: Number := getVint(a, INOUT i)
    ASSERT variablesize = 0

    LET exportfunctionsize: Number := getVint(a, INOUT i)
    ASSERT exportfunctionsize = 0

    LET exceptionexportsize: Number := getVint(a, INOUT i)
    ASSERT exceptionexportsize = 0

    LET interfaceexportsize: Number := getVint(a, INOUT i)
    ASSERT interfaceexportsize = 0

    LET importsize: Number := getVint(a, INOUT i)
    FOR z := 1 TO importsize DO
        VAR imp: Import := Import()
        imp.name := getVint(a, INOUT i)
        imp.optional := getVint(a, INOUT i) <> 0
        imp.hash := bytes[i TO i+31]
        i := i + 32
        r.imports.append(imp)
    END FOR

    LET functionsize: Number := getVint(a, INOUT i)
    FOR z := 1 TO functionsize DO
        VAR f: Function := Function()
        f.name := getVint(a, INOUT i)
        f.nest := getVint(a, INOUT i)
        f.params := getVint(a, INOUT i)
        f.locals := getVint(a, INOUT i)
        f.entry := getVint(a, INOUT i)
        r.functions.append(f)
    END FOR

    LET exceptionsize: Number := getVint(a, INOUT i)
    FOR z := 1 TO exceptionsize DO
        VAR e: Exception := Exception()
        e.start := getVint(a, INOUT i)
        e.end := getVint(a, INOUT i)
        e.excid := getVint(a, INOUT i)
        e.handler := getVint(a, INOUT i)
        e.stack_depth := getVint(a, INOUT i)
        r.exceptions.append(e)
    END FOR

    LET classsize: Number := getVint(a, INOUT i)
    FOR z := 1 TO classsize DO
        VAR c: ClassInfo := ClassInfo()
        c.name := getVint(a, INOUT i)
        LET interfacecount: Number := getVint(a, INOUT i)
        FOR zi := 1 TO interfacecount DO
            LET methods: Array<Number> := []
            LET methodcount: Number := getVint(a, INOUT i)
            FOR zm := 1 TO methodcount DO
                methods.append(getVint(a, INOUT i))
            END FOR
            c.interfaces.append(methods)
        END FOR
        r.classes.append(c)
    END FOR

    r.code := a[i TO LAST]

    RETURN r
END FUNCTION

TYPE Type IS ENUM
    none
    pointer
    boolean
    number
    string
    bytes
    object
    array
    dictionary
    classinfo
END ENUM

TYPE Value IS CLASS
    type: Type
    p: POINTER TO Value
    b: Boolean
    n: Number
    s: String
    y: Bytes
    o: Object
    a: Array<POINTER TO Value>
    d: Dictionary<POINTER TO Value>
    ci: ClassInfo
END CLASS

FUNCTION makeValueNone(): VALID POINTER TO Value
    RETURN NEW Value(type WITH Type.none)
END FUNCTION

FUNCTION makeValuePointer(p: POINTER TO Value): VALID POINTER TO Value
    RETURN NEW Value(type WITH Type.pointer, p WITH p)
END FUNCTION

FUNCTION makeValueBoolean(b: Boolean): VALID POINTER TO Value
    RETURN NEW Value(type WITH Type.boolean, b WITH b)
END FUNCTION

FUNCTION makeValueNumber(n: Number): VALID POINTER TO Value
    RETURN NEW Value(type WITH Type.number, n WITH n)
END FUNCTION

FUNCTION makeValueString(s: String): VALID POINTER TO Value
    RETURN NEW Value(type WITH Type.string, s WITH s)
END FUNCTION

FUNCTION makeValueBytes(y: Bytes): VALID POINTER TO Value
    RETURN NEW Value(type WITH Type.bytes, y WITH y)
END FUNCTION

FUNCTION makeValueObject(o: Object): VALID POINTER TO Value
    RETURN NEW Value(type WITH Type.object, o WITH o)
END FUNCTION

FUNCTION makeValueArray(a: Array<POINTER TO Value>): VALID POINTER TO Value
    RETURN NEW Value(type WITH Type.array, a WITH a)
END FUNCTION

FUNCTION makeValueDictionary(d: Dictionary<POINTER TO Value>): VALID POINTER TO Value
    RETURN NEW Value(type WITH Type.dictionary, d WITH d)
END FUNCTION

FUNCTION makeValueClassInfo(ci: ClassInfo): VALID POINTER TO Value
    RETURN NEW Value(type WITH Type.classinfo, ci WITH ci)
END FUNCTION

FUNCTION makeObjectFromValue(v: VALID POINTER TO Value): Object
    CASE v->type
        WHEN Type.none DO
            RETURN NIL
        WHEN Type.pointer DO
            RETURN NIL
        WHEN Type.boolean DO
            RETURN v->b
        WHEN Type.number DO
            RETURN v->n
        WHEN Type.string DO
            RETURN v->s
        WHEN Type.bytes DO
            RETURN v->y
        WHEN Type.object DO
            RETURN v->o
        WHEN Type.array DO
            VAR a: Array<Object> := []
            FOREACH x IN v->a DO
                IF VALID x THEN
                    a.append(makeObjectFromValue(x))
                ELSE
                    a.append(NIL)
                END IF
            END FOREACH
            RETURN a
        WHEN Type.dictionary DO
            VAR d: Dictionary<Object> := {}
            FOREACH k IN v->d.keys() DO
                IF VALID v->d[k] AS p THEN
                    d[k] := makeObjectFromValue(p)
                ELSE
                    d[k] := NIL
                END IF
            END FOREACH
            RETURN d
        WHEN Type.classinfo DO
            ASSERT FALSE
    END CASE
    RETURN NIL
END FUNCTION

TYPE Frame IS RECORD
    locals: Array<POINTER TO Value>
    opstack_depth: Number
END RECORD

TYPE Executor IS RECORD
    bytecode: Bytecode
    ip: Number
    stack: Array<POINTER TO Value>
    callstack: Array<Number>
    globals: Array<POINTER TO Value>
    frames: Array<Frame>
END RECORD

LET DispatchTable: Array<FUNCTION(INOUT self: Executor)> := [
    f_pushb,
    f_pushn,
    f_pushs,
    f_pushy,
    f_pushpg,
    f_pushppg,
    f_pushpmg,
    f_pushpl,
    f_pushpol,
    f_pushi,
    f_loadb,
    f_loadn,
    f_loads,
    f_loady,
    f_loada,
    f_loadd,
    f_loadp,
    f_loadj,
    f_storeb,
    f_storen,
    f_stores,
    f_storey,
    f_storea,
    f_stored,
    f_storep,
    f_storej,
    f_negn,
    f_addn,
    f_subn,
    f_muln,
    f_divn,
    f_modn,
    f_expn,
    f_eqb,
    f_neb,
    f_eqn,
    f_nen,
    f_ltn,
    f_gtn,
    f_len,
    f_gen,
    f_eqs,
    f_nes,
    f_lts,
    f_gts,
    f_les,
    f_ges,
    f_eqy,
    f_ney,
    f_lty,
    f_gty,
    f_ley,
    f_gey,
    f_eqa,
    f_nea,
    f_eqd,
    f_ned,
    f_eqp,
    f_nep,
    f_andb,
    f_orb,
    f_notb,
    f_indexar,
    f_indexaw,
    f_indexav,
    f_indexan,
    f_indexdr,
    f_indexdw,
    f_indexdv,
    f_ina,
    f_ind,
    f_callp,
    f_callf,
    f_callmf,
    f_calli,
    f_jump,
    f_jf,
    f_jt,
    f_dup,
    f_dupx1,
    f_drop,
    f_ret,
    f_consa,
    f_consd,
    f_except,
    f_alloc,
    f_pushnil,
    f_resetc,
    f_pushpeg,
    f_jumptbl,
    f_callx,
    f_swap,
    f_dropn,
    f_pushfp,
    f_callv,
    f_pushci,
]

FUNCTION Executor.run(INOUT self: Executor)
    WHILE self.ip < self.bytecode.code.size() DO
        --textio.writeLine(textio.stderr, "ip=\(self.ip) op=\(self.bytecode.code[self.ip]) depth=\(self.stack.size())")
        --IF self.stack.size() > 0 THEN
        --    IF VALID self.stack[LAST] AS p THEN
        --        textio.writeLine(textio.stderr, "  top=\(p->type) o=\(p->o)")
        --    END IF
        --END IF
        LET f: FUNCTION(INOUT self: Executor) := DispatchTable[self.bytecode.code[self.ip]]
        f(INOUT self)
    END WHILE
END FUNCTION

FUNCTION Executor.pop(INOUT self: Executor): VALID POINTER TO Value
    LET r: POINTER TO Value := self.stack[LAST]
    CHECK VALID r ELSE
        RAISE InternalException
    END CHECK
    self.stack.resize(self.stack.size()-1)
    RETURN r
END FUNCTION

FUNCTION Executor.invoke(INOUT self: Executor, index: Number)
    self.callstack.append(self.ip)
    LET params: Number := self.bytecode.functions[index].params
    LET locals: Number := self.bytecode.functions[index].locals
    VAR frame: Frame := Frame()
    WHILE frame.locals.size() < locals DO
        frame.locals.append(makeValueNone())
    END WHILE
    frame.opstack_depth := self.stack.size() - params
    self.frames.append(frame)
    self.ip := self.bytecode.functions[index].entry
END FUNCTION

FUNCTION Executor.raise_literal(INOUT self: Executor, exception: String, info: Object)
    VAR exceptionvar: Array<POINTER TO Value> := [
        makeValueString(exception),
        makeValueObject(info),
        makeValueNumber(self.ip),
    ]
    VAR tip: Number := self.ip
    VAR sp: Number := self.callstack.size()
    LOOP
        FOREACH e IN self.bytecode.exceptions DO
            IF e.start <= tip < e.end THEN
                LET handler: String := self.bytecode.strtable[e.excid]
                IF exception = handler
                OR (exception.length() > handler.length() AND exception[FIRST TO handler.length()-1] = handler AND exception[handler.length()] = ".") THEN
                    self.ip := e.handler
                    WHILE self.stack.size() > (IF self.frames.size() = 0 THEN 0 ELSE self.frames[LAST].opstack_depth) + e.stack_depth DO
                        _ := self.pop()
                    END WHILE
                    self.callstack.resize(sp)
                    self.stack.append(makeValueArray(exceptionvar))
                    EXIT FUNCTION
                END IF
            END IF
        END FOREACH
        IF sp = 0 THEN
            EXIT LOOP
        END IF
        DEC sp
        IF self.frames.size() > 0 THEN
            self.frames.resize(self.frames.size()-1)
        END IF
        tip := self.callstack[sp]
    END LOOP
    textio.writeLine(textio.stderr, "Unhandled exception \(exception) (\(info))")
    sys.exit(1)
END FUNCTION

FUNCTION f_pushb(INOUT self: Executor)
    INC self.ip
    LET val: Number := self.bytecode.code[self.ip]
    INC self.ip
    self.stack.append(makeValueBoolean(val <> 0))
END FUNCTION

FUNCTION f_pushn(INOUT self: Executor)
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    self.stack.append(makeValueNumber(num(self.bytecode.strtable[val])))
END FUNCTION

FUNCTION f_pushs(INOUT self: Executor)
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    self.stack.append(makeValueString(self.bytecode.strtable[val]))
END FUNCTION

FUNCTION f_pushy(INOUT self: Executor)
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    self.stack.append(makeValueBytes(self.bytecode.bytestable[val]))
END FUNCTION

FUNCTION f_pushpg(INOUT self: Executor)
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    self.stack.append(makeValuePointer(self.globals[val]))
END FUNCTION

FUNCTION f_pushppg(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_pushpmg(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_pushpl(INOUT self: Executor)
    INC self.ip
    LET addr: Number := getVint(self.bytecode.code, INOUT self.ip)
    self.stack.append(makeValuePointer(self.frames[LAST].locals[addr]))
END FUNCTION

FUNCTION f_pushpol(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_pushi(INOUT self: Executor)
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    self.stack.append(makeValueNumber(val))
END FUNCTION

FUNCTION f_loadb(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    self.stack.append(makeValueBoolean(addr->b))
END FUNCTION

FUNCTION f_loadn(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    IF VALID addr THEN
        self.stack.append(makeValueNumber(addr->n))
    ELSE
        ASSERT FALSE
    END IF
END FUNCTION

FUNCTION f_loads(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    self.stack.append(makeValueString(addr->s))
END FUNCTION

FUNCTION f_loady(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    self.stack.append(makeValueBytes(addr->y))
END FUNCTION

FUNCTION f_loada(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    IF VALID addr THEN
        self.stack.append(makeValueArray(addr->a))
    ELSE
        ASSERT FALSE
    END IF
END FUNCTION

FUNCTION f_loadd(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    self.stack.append(makeValueDictionary(addr->d))
END FUNCTION

FUNCTION f_loadp(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    self.stack.append(makeValuePointer(addr->p))
END FUNCTION

FUNCTION f_loadj(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    self.stack.append(makeValueObject(addr->o))
END FUNCTION

FUNCTION f_storeb(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    addr->b := self.pop()->b
END FUNCTION

FUNCTION f_storen(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    IF VALID addr THEN
        addr->n := self.pop()->n
    ELSE
        ASSERT FALSE
    END IF
END FUNCTION

FUNCTION f_stores(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    addr->s := self.pop()->s
END FUNCTION

FUNCTION f_storey(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    addr->y := self.pop()->y
END FUNCTION

FUNCTION f_storea(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    IF VALID addr THEN
        addr->a := self.pop()->a
    ELSE
        ASSERT FALSE
    END IF
END FUNCTION

FUNCTION f_stored(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    addr->d := self.pop()->d
END FUNCTION

FUNCTION f_storep(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    addr->p := self.pop()->p
END FUNCTION

FUNCTION f_storej(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    addr->type := Type.object -- TODO: It looks like this is probably necessary for other store opcodes too.
    addr->o := self.pop()->o
END FUNCTION

FUNCTION f_negn(INOUT self: Executor)
    INC self.ip
    LET x: Number := self.pop()->n
    self.stack.append(makeValueNumber(-x))
END FUNCTION

FUNCTION f_addn(INOUT self: Executor)
    INC self.ip
    LET b: Number := self.pop()->n
    LET a: Number := self.pop()->n
    self.stack.append(makeValueNumber(a + b))
END FUNCTION

FUNCTION f_subn(INOUT self: Executor)
    INC self.ip
    LET b: Number := self.pop()->n
    LET a: Number := self.pop()->n
    self.stack.append(makeValueNumber(a - b))
END FUNCTION

FUNCTION f_muln(INOUT self: Executor)
    INC self.ip
    LET b: Number := self.pop()->n
    LET a: Number := self.pop()->n
    self.stack.append(makeValueNumber(a * b))
END FUNCTION

FUNCTION f_divn(INOUT self: Executor)
    INC self.ip
    LET b: Number := self.pop()->n
    LET a: Number := self.pop()->n
    CHECK b <> 0 ELSE
        self.raise_literal("NumberException.DivideByZero", "")
        EXIT FUNCTION
    END CHECK
    self.stack.append(makeValueNumber(a / b))
END FUNCTION

FUNCTION f_modn(INOUT self: Executor)
    INC self.ip
    LET b: Number := self.pop()->n
    LET a: Number := self.pop()->n
    self.stack.append(makeValueNumber(a MOD b))
END FUNCTION

FUNCTION f_expn(INOUT self: Executor)
    INC self.ip
    LET b: Number := self.pop()->n
    LET a: Number := self.pop()->n
    self.stack.append(makeValueNumber(a ^ b))
END FUNCTION

FUNCTION f_eqb(INOUT self: Executor)
    INC self.ip
    LET b: Boolean := self.pop()->b
    LET a: Boolean := self.pop()->b
    self.stack.append(makeValueBoolean(a = b))
END FUNCTION

FUNCTION f_neb(INOUT self: Executor)
    INC self.ip
    LET b: Boolean := self.pop()->b
    LET a: Boolean := self.pop()->b
    self.stack.append(makeValueBoolean(a <> b))
END FUNCTION

FUNCTION f_eqn(INOUT self: Executor)
    INC self.ip
    LET b: Number := self.pop()->n
    LET a: Number := self.pop()->n
    self.stack.append(makeValueBoolean(a = b))
END FUNCTION

FUNCTION f_nen(INOUT self: Executor)
    INC self.ip
    LET b: Number := self.pop()->n
    LET a: Number := self.pop()->n
    self.stack.append(makeValueBoolean(a <> b))
END FUNCTION

FUNCTION f_ltn(INOUT self: Executor)
    INC self.ip
    LET b: Number := self.pop()->n
    LET a: Number := self.pop()->n
    self.stack.append(makeValueBoolean(a < b))
END FUNCTION

FUNCTION f_gtn(INOUT self: Executor)
    INC self.ip
    LET b: Number := self.pop()->n
    LET a: Number := self.pop()->n
    self.stack.append(makeValueBoolean(a > b))
END FUNCTION

FUNCTION f_len(INOUT self: Executor)
    INC self.ip
    LET b: Number := self.pop()->n
    LET a: Number := self.pop()->n
    self.stack.append(makeValueBoolean(a <= b))
END FUNCTION

FUNCTION f_gen(INOUT self: Executor)
    INC self.ip
    LET b: Number := self.pop()->n
    LET a: Number := self.pop()->n
    self.stack.append(makeValueBoolean(a >= b))
END FUNCTION

FUNCTION f_eqs(INOUT self: Executor)
    INC self.ip
    LET b: String := self.pop()->s
    LET a: String := self.pop()->s
    self.stack.append(makeValueBoolean(a = b))
END FUNCTION

FUNCTION f_nes(INOUT self: Executor)
    INC self.ip
    LET b: String := self.pop()->s
    LET a: String := self.pop()->s
    self.stack.append(makeValueBoolean(a <> b))
END FUNCTION

FUNCTION f_lts(INOUT self: Executor)
    INC self.ip
    LET b: String := self.pop()->s
    LET a: String := self.pop()->s
    self.stack.append(makeValueBoolean(a < b))
END FUNCTION

FUNCTION f_gts(INOUT self: Executor)
    INC self.ip
    LET b: String := self.pop()->s
    LET a: String := self.pop()->s
    self.stack.append(makeValueBoolean(a > b))
END FUNCTION

FUNCTION f_les(INOUT self: Executor)
    INC self.ip
    LET b: String := self.pop()->s
    LET a: String := self.pop()->s
    self.stack.append(makeValueBoolean(a <= b))
END FUNCTION

FUNCTION f_ges(INOUT self: Executor)
    INC self.ip
    LET b: String := self.pop()->s
    LET a: String := self.pop()->s
    self.stack.append(makeValueBoolean(a >= b))
END FUNCTION

FUNCTION f_eqy(INOUT self: Executor)
    INC self.ip
    LET b: Bytes := self.pop()->y
    LET a: Bytes := self.pop()->y
    self.stack.append(makeValueBoolean(a = b))
END FUNCTION

FUNCTION f_ney(INOUT self: Executor)
    INC self.ip
    LET b: Bytes := self.pop()->y
    LET a: Bytes := self.pop()->y
    self.stack.append(makeValueBoolean(a <> b))
END FUNCTION

FUNCTION f_lty(INOUT self: Executor)
    INC self.ip
    LET b: Bytes := self.pop()->y
    LET a: Bytes := self.pop()->y
    self.stack.append(makeValueBoolean(a < b))
END FUNCTION

FUNCTION f_gty(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_ley(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_gey(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_eqa(INOUT self: Executor)
    INC self.ip
    LET b: Array<POINTER TO Value> := self.pop()->a
    LET a: Array<POINTER TO Value> := self.pop()->a
    -- TODO: This needs to compare actual values, not just pointers.
    self.stack.append(NEW Value(b WITH a = b))
END FUNCTION

FUNCTION f_nea(INOUT self: Executor)
    INC self.ip
    LET b: Array<POINTER TO Value> := self.pop()->a
    LET a: Array<POINTER TO Value> := self.pop()->a
    -- TODO: This needs to compare actual values, not just pointers.
    self.stack.append(NEW Value(b WITH a <> b))
END FUNCTION

FUNCTION f_eqd(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_ned(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_eqp(INOUT self: Executor)
    INC self.ip
    LET b: POINTER TO Value := self.pop()->p
    LET a: POINTER TO Value := self.pop()->p
    self.stack.append(makeValueBoolean(a = b))
END FUNCTION

FUNCTION f_nep(INOUT self: Executor)
    INC self.ip
    LET b: POINTER TO Value := self.pop()->p
    LET a: POINTER TO Value := self.pop()->p
    self.stack.append(makeValueBoolean(a <> b))
END FUNCTION

FUNCTION f_andb(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_orb(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_notb(INOUT self: Executor)
    INC self.ip
    LET x: Boolean := self.pop()->b
    self.stack.append(makeValueBoolean(NOT x))
END FUNCTION

FUNCTION f_indexar(INOUT self: Executor)
    INC self.ip
    LET index: Number := self.pop()->n
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    CHECK index = math.trunc(index) ELSE
        self.raise_literal("PANIC", "Array index not an integer: \(index)")
        EXIT FUNCTION
    END CHECK
    CHECK index >= 0 ELSE
        self.raise_literal("PANIC", "Array index is negative: \(index)")
        EXIT FUNCTION
    END CHECK
    CHECK index < addr->a.size() ELSE
        self.raise_literal("PANIC", "Array index exceeds size \(addr->a.size()): \(index)")
        EXIT FUNCTION
    END CHECK
    self.stack.append(makeValuePointer(addr->a[index]))
END FUNCTION

FUNCTION f_indexaw(INOUT self: Executor)
    INC self.ip
    LET index: Number := self.pop()->n
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    CHECK index = math.trunc(index) ELSE
        self.raise_literal("PANIC", "Array index not an integer: \(index)")
        EXIT FUNCTION
    END CHECK
    CHECK index >= 0 ELSE
        self.raise_literal("PANIC", "Array index is negative: \(index)")
        EXIT FUNCTION
    END CHECK
    WHILE index >= addr->a.size() DO
        addr->a.append(NEW Value())
    END WHILE
    self.stack.append(makeValuePointer(addr->a[index]))
END FUNCTION

FUNCTION f_indexav(INOUT self: Executor)
    INC self.ip
    LET index: Number := self.pop()->n
    LET array: Array<POINTER TO Value> := self.pop()->a
    CHECK index = math.trunc(index) ELSE
        self.raise_literal("PANIC", "Array index not an integer: \(index)")
        EXIT FUNCTION
    END CHECK
    CHECK index >= 0 ELSE
        self.raise_literal("PANIC", "Array index is negative: \(index)")
        EXIT FUNCTION
    END CHECK
    CHECK index < array.size() ELSE
        self.raise_literal("PANIC", "Array index exceeds size \(array.size()): \(index)")
        EXIT FUNCTION
    END CHECK
    self.stack.append(array[index])
END FUNCTION

FUNCTION f_indexan(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_indexdr(INOUT self: Executor)
    INC self.ip
    LET key: String := self.pop()->s
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    CHECK key IN addr->d ELSE
        self.raise_literal("PANIC", "Dictionary key not found: \(key)")
        EXIT FUNCTION
    END CHECK
    self.stack.append(makeValuePointer(addr->d[key]))
END FUNCTION

FUNCTION f_indexdw(INOUT self: Executor)
    INC self.ip
    LET key: String := self.pop()->s
    LET addr: POINTER TO Value := self.pop()->p
    CHECK VALID addr ELSE
        RAISE InternalException
    END CHECK
    IF key NOT IN addr->d THEN
        addr->d[key] := NEW Value()
    END IF
    self.stack.append(makeValuePointer(addr->d[key]))
END FUNCTION

FUNCTION f_indexdv(INOUT self: Executor)
    INC self.ip
    LET key: String := self.pop()->s
    LET dict: Dictionary<POINTER TO Value> := self.pop()->d
    CHECK key IN dict ELSE
        self.raise_literal("PANIC", "Dictionary key not found: \(key)")
        EXIT FUNCTION
    END CHECK
    self.stack.append(dict[key])
END FUNCTION

FUNCTION f_ina(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_ind(INOUT self: Executor)
    INC self.ip
    LET dict: Dictionary<POINTER TO Value> := self.pop()->d
    LET key: String := self.pop()->s
    self.stack.append(makeValueBoolean(key IN dict))
END FUNCTION

FUNCTION f_callp(INOUT self: Executor)
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    LET f: String := self.bytecode.strtable[val]
    CASE f
        WHEN "builtin$array__append" DO
            LET v: VALID POINTER TO Value := self.pop()
            LET addr: POINTER TO Value := self.pop()->p
            IF VALID addr THEN
                addr->a.append(v)
            ELSE
                RAISE InternalException
            END IF
        --WHEN "builtin$array__find" DO
        --    LET e: VALID POINTER TO Value := self.pop()
        --    LET a: Array<POINTER TO Value> := self.pop()->a
        --    VAR found: Boolean := FALSE
        --    FOREACH x IN a INDEX i DO
        --        IF x = e THEN
        --            self.stack.append(makeValueNumber(i))
        --            found := TRUE
        --            EXIT FOREACH
        --        END IF
        --    END FOREACH
        --    IF NOT found THEN
        --        self.raise_literal("PANIC", "value not found in array")
        --    END IF
        WHEN "builtin$array__size" DO
            LET a: VALID POINTER TO Value := self.pop()
            self.stack.append(makeValueNumber(a->a.size()))
        WHEN "builtin$array__toBytes__number" DO
            LET a: Array<POINTER TO Value> := self.pop()->a
            VAR an: Array<Number> := []
            FOREACH p IN a INDEX i DO
                IF VALID p THEN
                    IF NOT (0 <= p->n < 256) THEN
                        self.raise_literal("PANIC", "Byte value out of range at offset \(i): \(p->n)")
                        EXIT FUNCTION
                    END IF
                    an.append(p->n)
                END IF
            END FOREACH
            self.stack.append(makeValueBytes(an.toBytes()))
        WHEN "builtin$array__toString__number" DO
            LET a: Array<POINTER TO Value> := self.pop()->a
            VAR r: String := "["
            FOR i := 0 TO a.size()-1 DO
                IF i > 0 THEN
                    r.append(", ")
                END IF
                IF VALID a[i] AS x THEN
                    r.append(str(x->n))
                END IF
            END FOR
            r.append("]")
            self.stack.append(makeValueString(r))
        WHEN "builtin$array__toString__object" DO
            LET a: Array<POINTER TO Value> := self.pop()->a
            VAR r: String := "["
            FOREACH x IN a INDEX i DO
                IF i > 0 THEN
                    r.append(", ")
                END IF
                IF VALID x THEN
                    -- TODO: this fails object.neon test because it formats numbers with quotes
                    LET s := "\(x->o)"
                    r.append(quoted(s))
                END IF
            END FOREACH
            r.append("]")
            self.stack.append(makeValueString(r))
        WHEN "builtin$array__toString__string" DO
            LET a: Array<POINTER TO Value> := self.pop()->a
            VAR r: String := "["
            FOR i := 0 TO a.size()-1 DO
                IF i > 0 THEN
                    r.append(", ")
                END IF
                IF VALID a[i] AS x THEN
                    r.append(quoted(x->s))
                END IF
            END FOR
            r.append("]")
            self.stack.append(makeValueString(r))
        WHEN "builtin$boolean__toString" DO
            LET b: Boolean := self.pop()->b
            self.stack.append(makeValueString(b.toString()))
        WHEN "builtin$bytes__append" DO
            LET b: Bytes := self.pop()->y
            LET a: POINTER TO Value := self.pop()->p
            CHECK VALID a ELSE
                RAISE InternalException
            END CHECK
            a->y.append(b)
        WHEN "builtin$bytes__concat" DO
            LET b: Bytes := self.pop()->y
            LET a: Bytes := self.pop()->y
            self.stack.append(makeValueBytes(a & b))
        WHEN "global$Bytes__decodeToString" DO
            LET y: Bytes := self.pop()->y
            LET r: DecodeResult := y.decodeToString()
            CASE r
                WHEN ISA DecodeResult.string DO
                    self.stack.append(makeValueArray([makeValueNumber(0), makeValueString(r.string)]))
                WHEN ISA DecodeResult.error DO
                    self.stack.append(makeValueArray([makeValueNumber(1), makeValueArray([makeValueNumber(r.error.offset)])]))
            END CASE
        WHEN "builtin$bytes__index" DO
            LET index: Number := self.pop()->n
            LET y: Bytes := self.pop()->y
            self.stack.append(makeValueNumber(y[index]))
        WHEN "builtin$bytes__range" DO
            LET last_from_end: Boolean := self.pop()->b
            VAR last: Number := self.pop()->n
            LET first_from_end: Boolean := self.pop()->b
            VAR first: Number := self.pop()->n
            LET y: Bytes := self.pop()->y
            IF first_from_end THEN
                first := first + y.size() - 1
            END IF
            IF last_from_end THEN
                last := last + y.size() - 1
            END IF
            IF first < 0 THEN
                first := 0
            ELSIF first > y.size() THEN
                first := y.size()
            END IF
            IF last >= y.size() THEN
                last := y.size() - 1
            ELSIF last < 0 THEN
                last := -1
            END IF
            IF last < first THEN
                self.stack.append(makeValueBytes(HEXBYTES ""))
            ELSE
                self.stack.append(makeValueBytes(y[first TO last]))
            END IF
        WHEN "builtin$bytes__size" DO
            LET y: Bytes := self.pop()->y
            self.stack.append(makeValueNumber(y.size()))
        WHEN "builtin$bytes__splice" DO
            LET last_from_end: Boolean := self.pop()->b
            VAR last: Number := self.pop()->n
            LET first_from_end: Boolean := self.pop()->b
            VAR first: Number := self.pop()->n
            LET a: Bytes := self.pop()->y
            LET b: Bytes := self.pop()->y
            IF first_from_end THEN
                first := first + a.size() - 1
            END IF
            IF last_from_end THEN
                last := last + a.size() - 1
            END IF
            LET r: Bytes := a[0 TO first-1] & b & a[last+1 TO LAST]
            self.stack.append(makeValueBytes(r))
        WHEN "builtin$bytes__store" DO
            LET index: Number := self.pop()->n
            LET a: POINTER TO Value := self.pop()->p
            CHECK VALID a ELSE
                RAISE InternalException
            END CHECK
            LET b: Number := self.pop()->n
            a->y[index] := b
        WHEN "builtin$bytes__toArray" DO
            LET y: Bytes := self.pop()->y
            LET a: Array<Number> := y.toArray()
            VAR r: Array<POINTER TO Value> := []
            FOR i := 0 TO a.size()-1 DO
                r.append(makeValueNumber(a[i]))
            END FOR
            self.stack.append(makeValueArray(r))
        WHEN "builtin$bytes__toString" DO
            LET y: Bytes := self.pop()->y
            self.stack.append(makeValueString(y.toString()))
        WHEN "builtin$dictionary__keys" DO
            LET d: Dictionary<POINTER TO Value> := self.pop()->d
            LET a: Array<POINTER TO Value> := []
            FOREACH k IN d.keys() DO
                a.append(makeValueString(k))
            END FOREACH
            self.stack.append(makeValueArray(a))
        WHEN "builtin$dictionary__remove" DO
            LET key: String := self.pop()->s
            LET a: POINTER TO Value := self.pop()->p
            IF VALID a THEN
                a->d.remove(key)
            END IF
        WHEN "builtin$dictionary__toString__object" DO
            LET d: Dictionary<POINTER TO Value> := self.pop()->d
            VAR r: String := "{"
            FOREACH k IN d.keys() INDEX i DO
                IF i > 0 THEN
                    r.append(", ")
                END IF
                r.append(quoted(k))
                r.append(": ")
                IF VALID d[k] AS x THEN
                    LET s := "\(x->o)"
                    r.append(quoted(s))
                END IF
            END FOREACH
            r.append("}")
            self.stack.append(makeValueString(r))
        WHEN "builtin$dictionary__toString__string" DO
            LET d: Dictionary<POINTER TO Value> := self.pop()->d
            VAR r: String := "{"
            FOREACH k IN d.keys() INDEX i DO
                IF i > 0 THEN
                    r.append(", ")
                END IF
                r.append(quoted(k))
                r.append(": ")
                IF VALID d[k] AS x THEN
                    r.append(quoted(x->s))
                END IF
            END FOREACH
            r.append("}")
            self.stack.append(makeValueString(r))
        WHEN "global$num" DO
            LET s: String := self.pop()->s
            IF regex.search(@"^[-+]?\d+(\.\d+)?([eE][-+]?\d+)?$", s) ISA regex.Result.match THEN
                self.stack.append(makeValueNumber(num(s)))
            ELSE
                self.raise_literal("PANIC", "num() argument not a number")
            END IF
        WHEN "builtin$object__getArray" DO
            TRY
                LET a: Array<Object> := self.pop()->o
                VAR r: Array<POINTER TO Value> := []
                FOREACH x IN a DO
                    r.append(makeValueObject(x))
                END FOREACH
                self.stack.append(makeValueArray(r))
            TRAP DynamicConversionException DO
                self.raise_literal("DynamicConversionException", "to Array")
            END TRY
        WHEN "builtin$object__getBoolean" DO
            TRY
                self.stack.append(makeValueBoolean(self.pop()->o))
            TRAP DynamicConversionException DO
                self.raise_literal("DynamicConversionException", "to Boolean")
            END TRY
        WHEN "builtin$object__getBytes" DO
            TRY
                self.stack.append(makeValueBytes(self.pop()->o))
            TRAP DynamicConversionException DO
                self.raise_literal("DynamicConversionException", "to Bytes")
            END TRY
        WHEN "builtin$object__getDictionary" DO
            TRY
                -- TODO: Evaluate right hand side only once, should not need temporary o.
                LET o: Object := self.pop()->o
                LET d: Dictionary<Object> := o
                VAR r: Dictionary<POINTER TO Value> := {}
                FOREACH k IN d.keys() DO
                    r[k] := makeValueObject(d[k])
                END FOREACH
                self.stack.append(makeValueDictionary(r))
            TRAP DynamicConversionException DO
                self.raise_literal("DynamicConversionException", "to Dictionary")
            END TRY
        WHEN "builtin$object__getNumber" DO
            TRY
                self.stack.append(makeValueNumber(self.pop()->o))
            TRAP DynamicConversionException DO
                self.raise_literal("DynamicConversionException", "to Number")
            END TRY
        WHEN "builtin$object__getString" DO
            TRY
                self.stack.append(makeValueString(self.pop()->o))
            TRAP DynamicConversionException DO
                self.raise_literal("DynamicConversionException", "to String")
            END TRY
        WHEN "builtin$object__isNull" DO
            self.stack.append(makeValueBoolean(self.pop()->o = NIL))
        WHEN "builtin$object__makeArray" DO
            self.stack.append(makeValueObject(makeObjectFromValue(self.pop())))
        WHEN "builtin$object__makeBoolean" DO
            self.stack.append(makeValueObject(makeObjectFromValue(self.pop())))
        WHEN "builtin$object__makeBytes" DO
            self.stack.append(makeValueObject(makeObjectFromValue(self.pop())))
        WHEN "builtin$object__makeDictionary" DO
            self.stack.append(makeValueObject(makeObjectFromValue(self.pop())))
        WHEN "builtin$object__makeNull" DO
            self.stack.append(makeValueObject(NIL))
        WHEN "builtin$object__makeNumber" DO
            self.stack.append(makeValueObject(makeObjectFromValue(self.pop())))
        WHEN "builtin$object__makeString" DO
            self.stack.append(makeValueObject(makeObjectFromValue(self.pop())))
        WHEN "builtin$object__subscript" DO
            LET index: Object := self.pop()->o
            LET obj: Object := self.pop()->o
            IF obj = NIL THEN
                self.raise_literal("DynamicConversionException", "object is null")
            ELSIF index = NIL THEN
                self.raise_literal("DynamicConversionException", "index is null")
            ELSIF obj ISA Array<Object> AND index ISA Number THEN
                LET i: Number := index
                IF i < obj.size() THEN
                    self.stack.append(makeValueObject(obj[index]))
                ELSE
                    self.raise_literal("PANIC", "Array index exceeds size \(obj.size()): \(index)")
                END IF
            ELSE
                TRY
                    self.stack.append(makeValueObject(obj[index]))
                TRAP DynamicConversionException AS e DO
                    self.raise_literal("DynamicConversionException", e.info)
                TRAP ObjectSubscriptException AS e DO
                    self.raise_literal("ObjectSubscriptException", e.info)
                END TRY
            END IF
        WHEN "builtin$object__toString" DO
            self.stack.append(makeValueString("\(self.pop()->o)"))
        WHEN "global$print" DO
            print(self.pop()->o)
        WHEN "runtime$assertionsEnabled" DO
            self.stack.append(makeValueBoolean(TRUE))
        WHEN "runtime$debugEnabled" DO
            self.stack.append(makeValueBoolean(FALSE))
        WHEN "runtime$executorName" DO
            self.stack.append(makeValueString("nenex"))
        WHEN "global$str", "builtin$number__toString" DO
            LET n: Number := self.pop()->n
            self.stack.append(makeValueString(str(n)))
        WHEN "builtin$string__concat" DO
            LET b: String := self.pop()->s
            LET a: String := self.pop()->s
            self.stack.append(makeValueString(a & b))
        WHEN "builtin$string__index" DO
            LET index: Number := self.pop()->n
            LET s: String := self.pop()->s
            self.stack.append(makeValueString(s[index TO index]))
        WHEN "builtin$string__length" DO
            LET s: String := self.pop()->s
            self.stack.append(makeValueNumber(s.length()))
        WHEN "builtin$string__substring" DO
            LET last_from_end: Boolean := self.pop()->b
            ASSERT last_from_end = last_from_end
            LET last: Number := self.pop()->n
            LET first_from_end: Boolean := self.pop()->b
            ASSERT first_from_end = first_from_end
            LET first: Number := self.pop()->n
            LET s: String := self.pop()->s
            self.stack.append(makeValueString(s[first TO last]))
        WHEN "string$fromCodePoint" DO
            LET n: Number := self.pop()->n
            self.stack.append(makeValueString(string.fromCodePoint(n)))
        WHEN "string$toCodePoint" DO
            LET s: String := self.pop()->s
            self.stack.append(makeValueNumber(string.toCodePoint(s)))
        WHEN OTHERS DO
            textio.writeLine(textio.stderr, "unexpected function: \(f)")
            sys.exit(1)
    END CASE
END FUNCTION

FUNCTION f_callf(INOUT self: Executor)
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    self.invoke(val)
END FUNCTION

FUNCTION f_callmf(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_calli(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_jump(INOUT self: Executor)
    INC self.ip
    LET target: Number := getVint(self.bytecode.code, INOUT self.ip)
    self.ip := target
END FUNCTION

FUNCTION f_jf(INOUT self: Executor)
    INC self.ip
    LET target: Number := getVint(self.bytecode.code, INOUT self.ip)
    LET b: Boolean := self.pop()->b
    IF NOT b THEN
        self.ip := target
    END IF
END FUNCTION

FUNCTION f_jt(INOUT self: Executor)
    INC self.ip
    LET target: Number := getVint(self.bytecode.code, INOUT self.ip)
    LET b: Boolean := self.pop()->b
    IF b THEN
        self.ip := target
    END IF
END FUNCTION

FUNCTION f_dup(INOUT self: Executor)
    INC self.ip
    VAR x: VALID POINTER TO Value := self.pop()
    self.stack.append(x)
    self.stack.append(x)
END FUNCTION

FUNCTION f_dupx1(INOUT self: Executor)
    INC self.ip
    LET a: POINTER TO Value := self.pop()
    LET b: POINTER TO Value := self.pop()
    self.stack.append(a)
    self.stack.append(b)
    self.stack.append(a)
END FUNCTION

FUNCTION f_drop(INOUT self: Executor)
    INC self.ip
    _ := self.pop()
END FUNCTION

FUNCTION f_ret(INOUT self: Executor)
    IF self.frames.size() > 0 THEN
        self.frames.resize(self.frames.size()-1)
    END IF
    self.ip := self.callstack[LAST]
    self.callstack.resize(self.callstack.size()-1)
END FUNCTION

FUNCTION f_consa(INOUT self: Executor)
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    VAR a: Array<POINTER TO Value> := []
    FOR i := 1 TO val DO
        a.append(self.pop())
    END FOR
    self.stack.append(makeValueArray(a))
END FUNCTION

FUNCTION f_consd(INOUT self: Executor)
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    VAR d: Dictionary<POINTER TO Value> := {}
    FOR i := 1 TO val DO
        LET v: POINTER TO Value := self.pop()
        LET k: String := self.pop()->s
        d[k] := v
    END FOR
    self.stack.append(makeValueDictionary(d))
END FUNCTION

FUNCTION f_except(INOUT self: Executor)
    LET start_ip: Number := self.ip
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    self.ip := start_ip
    LET info: Object := self.pop()->o
    self.raise_literal(self.bytecode.strtable[val], info)
END FUNCTION

FUNCTION f_alloc(INOUT self: Executor)
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    VAR a: Array<POINTER TO Value> := []
    FOR i := 1 TO val DO
        a.append(NEW Value())
    END FOR
    self.stack.append(makeValuePointer(makeValueArray(a)))
END FUNCTION

FUNCTION f_pushnil(INOUT self: Executor)
    INC self.ip
    self.stack.append(makeValuePointer(NIL))
END FUNCTION

FUNCTION f_resetc(INOUT self: Executor)
    INC self.ip
    LET addr: POINTER TO Value := self.pop()->p
    IF VALID addr THEN
        addr->p := NIL
        addr->b := FALSE
        addr->n := 0
        addr->s := ""
        addr->y := HEXBYTES ""
        addr->a := []
        addr->d := {}
        addr->ci := ClassInfo()
    ELSE
        ASSERT FALSE
    END IF
END FUNCTION

FUNCTION f_pushpeg(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_jumptbl(INOUT self: Executor)
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    LET n: Number := math.trunc(self.pop()->n)
    IF 0 <= n < val THEN
        self.ip := self.ip + (6 * n)
    ELSE
        self.ip := self.ip + (6 * val)
    END IF
END FUNCTION

FUNCTION f_callx(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_swap(INOUT self: Executor)
    INC self.ip
    LET a: VALID POINTER TO Value := self.pop()
    LET b: VALID POINTER TO Value := self.pop()
    self.stack.append(a)
    self.stack.append(b)
END FUNCTION

FUNCTION f_dropn(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_pushfp(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_callv(INOUT self: Executor)
    ASSERT FALSE
END FUNCTION

FUNCTION f_pushci(INOUT self: Executor)
    INC self.ip
    LET val: Number := getVint(self.bytecode.code, INOUT self.ip)
    LET dot: Number := string.find(self.bytecode.strtable[val], ".")
    IF dot < 0 THEN
        FOREACH c IN self.bytecode.classes DO
            IF c.name = val THEN
                LET a: Array<POINTER TO Value> := [
                    NEW Value(ci WITH c)
                ]
                self.stack.append(makeValueArray(a))
                EXIT FUNCTION
            END IF
        END FOREACH
    END IF
    textio.writeLine(textio.stderr, "neon: unknown class name \(self.bytecode.strtable[val])")
    sys.exit(1)
END FUNCTION

FUNCTION makeExecutor(bytes: Bytes): Executor
    VAR r: Executor := Executor()
    r.bytecode := decodeBytecode(bytes)
    r.ip := 0
    r.stack := []
    r.callstack := [r.bytecode.code.size()]
    r.globals := []
    FOR i := 0 TO r.bytecode.globalSize-1 DO
        r.globals[i] := NEW Value()
    END FOR
    RETURN r
END FUNCTION

BEGIN MAIN
    VAR e: Executor := makeExecutor(file.readBytes(sys.args[1]))
    e.run()
END MAIN
